<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Stephen&#39;s Blog</title>
  
  <subtitle>welcome to Stephen&#39;s Blog</subtitle>
  <link href="https://www.daipeihong.top/atom.xml" rel="self"/>
  
  <link href="https://www.daipeihong.top/"/>
  <updated>2022-10-23T08:19:15.573Z</updated>
  <id>https://www.daipeihong.top/</id>
  
  <author>
    <name>DaiPeihong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Markdown语法笔记</title>
    <link href="https://www.daipeihong.top/2022/10/23/markdown-yu-fa-bi-ji/"/>
    <id>https://www.daipeihong.top/2022/10/23/markdown-yu-fa-bi-ji/</id>
    <published>2022-10-23T08:14:00.000Z</published>
    <updated>2022-10-23T08:19:15.573Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="1-代码块"><a href="#1-代码块" class="headerlink" title="1.代码块"></a>1.代码块</h1><pre class=" language-markdown"><code class="language-markdown"></code></pre><h1 id="2-标题"><a href="#2-标题" class="headerlink" title="2.标题"></a>2.标题</h1><h1 id="3-字体"><a href="#3-字体" class="headerlink" title="3.字体"></a>3.字体</h1><h2 id="3-1样式"><a href="#3-1样式" class="headerlink" title="3.1样式"></a>3.1样式</h2><p>在 Markdown 语法中，使用&nbsp;<code>&lt;font&gt;</code>&nbsp;标签的&nbsp;<code>face</code>&nbsp;属性修改文字字体。字体在不同环境中支持程度不同，表现结果可能也不同。</p><pre class=" language-markdown"><code class="language-markdown"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">face</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>HEI<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>这里是黑体<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">face</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>KAI<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>这里是楷体<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">face</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>GB18030 Bitmap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>这里是扩展字体<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span></code></pre><p><font face="HEI">这里是黑体</font><br><font face="KAI">这里是楷体</font><br><font face="GB18030 Bitmap">这里是扩展字体</font></p><h2 id="3-2字号"><a href="#3-2字号" class="headerlink" title="3.2字号"></a>3.2字号</h2><p>Markdown 有三种主要方式：</p><h3 id="3-2-1使用-lt-font-gt-标签；"><a href="#3-2-1使用-lt-font-gt-标签；" class="headerlink" title="3.2.1使用&nbsp;<font>&nbsp;标签；"></a>3.2.1使用&nbsp;<code>&lt;font&gt;</code>&nbsp;标签；</h3><p>使用&nbsp;<code>&lt;font&gt;</code>&nbsp;标签&nbsp;<code>size</code>&nbsp;属性修改局部字号</p><pre class=" language-markdown"><code class="language-markdown"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>1号字 最小<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>2号字<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>3<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>3号字 默认<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>4<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>4号字<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>5<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>5号字<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>6<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>6号字<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>7<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>7号字 最大<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span></code></pre><p><font size="1">1号字 最小</font><br><font size="2">2号字</font><br><font size="3">3号字 默认</font><br><font size="4">4号字</font><br><font size="5">5号字</font><br><font size="6">6号字</font><br><font size="7">7号字 最大</font></p><h3 id="3-2-2通过-lt-big-gt-或者-lt-small-gt-标签"><a href="#3-2-2通过-lt-big-gt-或者-lt-small-gt-标签" class="headerlink" title="3.2.2通过&nbsp;<big>&nbsp;或者&nbsp;<small>&nbsp;标签"></a>3.2.2通过&nbsp;<code>&lt;big&gt;</code>&nbsp;或者&nbsp;<code>&lt;small&gt;</code>&nbsp;标签</h3><h3 id="3-2-3通过修改-style-样式实现。"><a href="#3-2-3通过修改-style-样式实现。" class="headerlink" title="3.2.3通过修改&nbsp;style&nbsp;样式实现。"></a>3.2.3通过修改&nbsp;<code>style</code>&nbsp;样式实现。</h3><h2 id="3-3字体颜色"><a href="#3-3字体颜色" class="headerlink" title="3.3字体颜色"></a>3.3字体颜色</h2><p>在 Markdown 语法中，使用&nbsp;<code>&lt;font&gt;</code>&nbsp;标签的&nbsp;<code>color</code>&nbsp;属性修改文字颜色。</p><pre class=" language-markdown"><code class="language-markdown"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>red<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>红色<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>green<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>绿色<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>blue<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>蓝色<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>rgb(200, 100, 100)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>使用 rgb 颜色值<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#FF00BB<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>使用十六进制颜色值<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span></code></pre><p><font color="red">红色</font><br><font color="green">绿色</font><br><font color="blue">蓝色</font><br><font color="rgb(200, 100, 100)">使用 rgb 颜色值</font><br><font color="#FF00BB">使用十六进制颜色值</font></p><pre class=" language-markdown"><code class="language-markdown"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">background</span><span class="token punctuation">:</span> <span class="token function">linear-gradient</span><span class="token punctuation">(</span> to right, <span class="token hexcode">#ff1616</span>, <span class="token hexcode">#ff7716</span>, <span class="token hexcode">#ffdc16</span>, <span class="token hexcode">#36c945</span>, <span class="token hexcode">#10a5ce</span>, <span class="token hexcode">#0f0096</span>, <span class="token hexcode">#a51eff</span>, <span class="token hexcode">#ff1616</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>这是七色光彩背景颜色<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span></code></pre><p><font style="background: linear-gradient( to right, #ff1616, #ff7716, #ffdc16, #36c945, #10a5ce, #0f0096, #a51eff, #ff1616);">这是七色光彩背景颜色</font></p><h2 id="3-4粗体斜体"><a href="#3-4粗体斜体" class="headerlink" title="3.4粗体斜体"></a>3.4粗体斜体</h2><p>使用 <code>*</code> 和 <code>**</code> 分别表示斜体和粗体，例如<br><em>斜体</em><br><strong>粗体</strong><br><em><strong>又斜又粗</strong></em></p><h2 id="3-5-高亮"><a href="#3-5-高亮" class="headerlink" title="3.5 高亮"></a>3.5 高亮</h2><p>==高亮==</p><h2 id="3-6跨行注释"><a href="#3-6跨行注释" class="headerlink" title="3.6跨行注释"></a>3.6跨行注释</h2><p>这里是行内注释：<br>%%预览模式下你将看不到这句话%%<br>这里是跨行注释：<br>%% 所谓跨行<br>就是可以有很多行 %%</p><h1 id="4-分割线"><a href="#4-分割线" class="headerlink" title="4.分割线"></a>4.分割线</h1><pre class=" language-markdown"><code class="language-markdown"><span class="token italic"><span class="token punctuation">*</span><span class="token punctuation">*</span><span class="token punctuation">*</span></span> 或者 ---</code></pre><hr><hr><h1 id="5-删除线"><a href="#5-删除线" class="headerlink" title="5.删除线"></a>5.删除线</h1><p>使用<code>~~双波浪线~~</code>表示删除线<br><del>删除线</del></p><h1 id="6-列表"><a href="#6-列表" class="headerlink" title="6.列表"></a>6.列表</h1><h2 id="6-1有序列表"><a href="#6-1有序列表" class="headerlink" title="6.1有序列表"></a>6.1有序列表</h2><p>语法：<code>数字</code>＋<code>.</code>＋<code>空格</code></p><pre class=" language-markdown"><code class="language-markdown">1. 2. 3. </code></pre><ol><li>第一</li><li>第二</li><li>第三</li></ol><h2 id="6-2无序列表"><a href="#6-2无序列表" class="headerlink" title="6.2无序列表"></a>6.2无序列表</h2><p>语法： <code>-</code> 或者<code>+</code> 或者<code>*</code> ＋<code>space</code></p><pre class=" language-markdown"><code class="language-markdown">* - + </code></pre><ul><li>第一</li></ul><ul><li>第二</li></ul><ul><li>第三</li></ul><h2 id="6-3列表嵌套"><a href="#6-3列表嵌套" class="headerlink" title="6.3列表嵌套"></a>6.3列表嵌套</h2><p>table键控制缩进，shift＋table取消缩进</p><ul><li>第一层 1<ul><li>第二层 1<ul><li>第三层 1<ul><li>第四层 1<ul><li>第五层 1</li></ul></li></ul></li><li>第三层 2</li></ul></li><li>第二层 2</li></ul></li></ul><h1 id="7-引用"><a href="#7-引用" class="headerlink" title="7.引用"></a>7.引用</h1><p>使用 <code>&gt;</code> 表示，可以有多个 <code>&gt;</code>，表示层级更深，例如</p><blockquote><p>第一层</p><blockquote><p>第二层</p><blockquote><p>第三层</p><blockquote><p>第四层</p></blockquote></blockquote></blockquote></blockquote><h1 id="8-代码样式"><a href="#8-代码样式" class="headerlink" title="8.代码样式"></a>8.代码样式</h1><h2 id="8-1行内代码"><a href="#8-1行内代码" class="headerlink" title="8.1行内代码"></a>8.1行内代码</h2><p>使用 「反引号&nbsp;<code>`</code>」符号定义行内代码。<br><code>行内代码</code></p><h2 id="8-2代码块"><a href="#8-2代码块" class="headerlink" title="8.2代码块"></a>8.2代码块</h2><p>使用四个空格缩进表示代码块，例如<br>    print(‘hello,world’)<br>    print(‘hello,world’)<br>        print(‘hello,world’)<br>        print(‘hello,world’)<br>        print(‘hello,world’)</p><h1 id="8-超链接"><a href="#8-超链接" class="headerlink" title="8.超链接"></a>8.超链接</h1><p>语法：<code>中括号[链接名称](目标链接)</code></p><pre class=" language-markdown"><code class="language-markdown">[Stephen<span class="token italic"><span class="token punctuation">_</span>Dai的个人空间<span class="token punctuation">_</span></span>哔哩哔哩](https://space.bilibili.com/444343706?spm<span class="token italic"><span class="token punctuation">_</span>id<span class="token punctuation">_</span></span>from=333.1007.0.0)</code></pre><p><a href="https://space.bilibili.com/444343706?spm_id_from=333.1007.0.0">Stephen_Dai的个人空间_哔哩哔哩</a></p><p>==TIPS: 若超链接为视频，可在<strong>阅读模式</strong>下Ctrl+单击链接，在软件内打开==</p><h1 id="9-表格"><a href="#9-表格" class="headerlink" title="9.表格"></a>9.表格</h1><p><strong>Markdown 表格包含三个部分：表头、分割线、数据。</strong></p><ul><li><strong>表头</strong>&nbsp;用来对列名对象进行描述，也就是通常所说的列名；</li><li><strong>数据</strong>&nbsp;用来展示每行的具体内容，数据是表格的核心；</li><li><strong>分割线</strong>&nbsp;用来区分表头和数据，也是 Markdown 中表格定义的最基本语法要求。</li></ul><p><strong>Markdown 表格由 「竖线&nbsp;<code>|</code>」、「减号&nbsp;<code>-</code>」、「冒号&nbsp;<code>:</code>」三种符号组成。</strong></p><ul><li><strong>竖线</strong>&nbsp;用来定义列，每两个竖线之间为一个单元格元素；</li><li><strong>减号</strong>&nbsp;用来定义分割线，也就是分割表头和数据体；</li><li><strong>冒号</strong>&nbsp;配合减号使用，用于定义列数据的对齐属性。</li></ul><pre class=" language-markdown"><code class="language-markdown">|商品|数量|单价||---|---:|:---:||苹果|10|\$1||电脑|1|\$1999|</code></pre><table><thead><tr><th>商品</th><th>数量</th><th>单价</th></tr></thead><tbody><tr><td>苹果</td><td>10</td><td>$1</td></tr><tr><td>电脑</td><td>1</td><td>$1999</td></tr></tbody></table><h1 id="10-数学公式"><a href="#10-数学公式" class="headerlink" title="10.数学公式"></a>10.数学公式</h1><p>Markdown 中的数学公式支持支持 <strong>LaTeX</strong>，分为「行中公式」和「独立公式」两种。</p><p>行中公式用两个单独的「美元符&nbsp;<code>$</code>」表示。</p><p>世界上最难的问题$1+1=2$，如何证明？</p><p>独立公式用两个连续的「美元符&nbsp;<code>$$</code>」表示，换行通过&nbsp;<code>\</code>&nbsp;实现。</p><p>平均数符号：$overline{xyz}$<br>开二次方符号：$sqrt x$<br>开方符号：$sqrt[3]{x+y}$<br>对数符号：$log(x)$<br>极限符号：$lim^{x to infty}<em>{y to 0}{frac{x}{y}}$<br>极限符号：$displaystyle lim^{x to infty}</em>{y to 0}{frac{x}{y}}$<br>求和符号：$sum^{x to infty}<em>{y to 0}{frac{x}{y}}$<br>求和符号：$displaystyle sum^{x to infty}</em>{y to 0}{frac{x}{y}}$<br>积分符号：$int^{infty}<em>{0}{xdx}$<br>积分符号：$displaystyle int^{infty}</em>{0}{xdx}$ </p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;1-代码块&quot;&gt;&lt;a href=&quot;#1-代码块&quot; class=&quot;headerlink&quot; title=&quot;1.代码块&quot;&gt;&lt;/a&gt;1.代码块&lt;/h1&gt;&lt;pre class=&quot; language-markdown&quot;&gt;&lt;code class=&quot;language-ma</summary>
      
    
    
    
    <category term="猎奇" scheme="https://www.daipeihong.top/categories/%E7%8C%8E%E5%A5%87/"/>
    
    
    <category term="Markdown" scheme="https://www.daipeihong.top/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>WordPress安装教程</title>
    <link href="https://www.daipeihong.top/2022/10/22/wordpress-an-zhuang-jiao-cheng/"/>
    <id>https://www.daipeihong.top/2022/10/22/wordpress-an-zhuang-jiao-cheng/</id>
    <published>2022-10-22T14:06:00.000Z</published>
    <updated>2022-10-23T07:37:40.470Z</updated>
    
    <content type="html"><![CDATA[<p>首先，需要购买一台云服务器/轻量云服务器，步骤如下<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222121301.png"><br>选择云服务器配置<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222126775.png"><br>购买完成后即可在如下位置看见已购买的云服务器（此处我购买的为轻量云服务器）<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222130358.png"><br>点击进入<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222131547.png"><br>接下来进入管理面板<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222133025.png"></p><p>要访问宝塔面板，防火墙/安全组需要放行面板[8888]端口，操作如下：<br>点进如下界面<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222134745.png"></p><p>点击添加规则<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222135726.png"></p><p>在端口一栏输入<strong>8888</strong>以开放端口<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222135122.png"></p><p>之后在“应用管理”界面复制命令，点击登录<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222135918.png"></p><p>此处需要登录一下<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222136412.png"></p><p>粘贴刚才复制的命令，回车<br>得到宝塔面板的登录信息，可以保存下来方便后面使用<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222136778.png"></p><p>浏览器中输入刚保存的外网面板地址，输入刚保存的账户密码登录<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222136087.png"></p><p>绑定宝塔账号(没有就去<a href="https://www.bt.cn/new/index.html">宝塔面板官网</a>)注册一个再来绑定）<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222136339.png"></p><p>点击查看，新建API密钥<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222137388.png"></p><p>点击新建密钥，密钥就会出现在下方<br>复制APPID、Secretid、SecretKey输入到刚才关联API密钥界面即可<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222138035.png"></p><p>此处选择急速安装与编译安装都可以，之后点击一键安装<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222138624.png"></p><p>接下来等待安装完成就行<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222138905.png"></p><p>安装完成后，在软件商店搜索wordpress，如下<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222120098.png"><br>这里需要填写自己购买的域名，域名的购买可参考我的另一篇博客==（链接）==<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222141667.png"></p><hr><p>——————————————分割线——————————————————<br>==注意：以下属于购买域名部分的不同处：==<br>在对域名进行解析时，需要将记录值添加为云服务器的公网IP<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222146786.png"><br>云服务器的公网IP在这里获取：<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222146682.png"><br>——————————————分割线——————————————————–<br>填好域名后，<img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222148697.png"><br>进入wordpress安装界面（建议在这一步安装之前，先部署ssl证书，否则可能访问不了安装页面，如何获取ssl证书见下一步）<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222148503.png"><br>进入此页面，搜索ssl证书，点击进入<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222149111.png"><br>在“我的证书”里面进行购买（免费）<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222150531.png"><br>选择如下<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222150546.png"><br>填写信息<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222152165.png"><br>根据给出得主机记录、记录类型、记录值添加域名解析记录==（见我的另一篇关于域名购买的博客）==<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222152866.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222152753.png"><br>之后验证域名<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222154908.png"><br>验证通过之后在“我的证书”里面下载<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222155303.png"><br>请根据服务器类型选择证书下载:<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222155468.png"><br>下载解压打开，有如下文件<br><img src="/!%5B%5D(https:/cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/20221022215719.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/20221022215719.png"><br>进入宝塔面板如下页面：<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222156120.png"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222157240.png"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222158087.png"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222158808.png"></p><p>完成之后在此进入Wordpress安装界面，点击安装<img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222159505.png"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222159244.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222159535.png"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222159668.png"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222200184.png"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222200978.png"><br>WordPress安装完成，接下来更改相关设置<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222200401.png"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/PRWK3%7BWQOU40_0%5B21ZF0%5DOQ.png"><br>进入如下页面<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222201542.png"></p><p>选择好之后回到宝塔页面<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222202188.png"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222202515.png"><br>再回到wordpress<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222202459.png"><br>设置更新完成<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/~2$6O0@%7DQLSFCET5H3L3Z5M.png"></p><p>至此，WordPress安装全部完成，可以通过自己购买的域名访问WordPress<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222203746.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先，需要购买一台云服务器/轻量云服务器，步骤如下&lt;br&gt;&lt;img src=&quot;https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222121301.png&quot;&gt;&lt;b</summary>
      
    
    
    
    <category term="Web前端" scheme="https://www.daipeihong.top/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="WordPress" scheme="https://www.daipeihong.top/tags/WordPress/"/>
    
    <category term="安装教程" scheme="https://www.daipeihong.top/tags/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>后期思路（一）图片管理方法</title>
    <link href="https://www.daipeihong.top/2022/10/21/hou-qi-si-lu-yi-tu-pian-guan-li-fang-fa/"/>
    <id>https://www.daipeihong.top/2022/10/21/hou-qi-si-lu-yi-tu-pian-guan-li-fang-fa/</id>
    <published>2022-10-21T04:18:00.000Z</published>
    <updated>2022-10-21T05:54:55.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-文件管理体系"><a href="#一-文件管理体系" class="headerlink" title="(一)文件管理体系"></a>(一)文件管理体系</h2><ol><li>使用<font color="#7030a0">摄影日期</font>(或加上<font color="rgb(227, 108, 9)">地名</font>)命名文件夹</li><li>按照文件格式分类分别保存JEPG、RAW、视频文件</li><li>新建加水印图片的文件夹，保存缩小尺寸、添加水印的照片，用于网络分享</li></ol><h2 id="二-lightroom导入照片的方式"><a href="#二-lightroom导入照片的方式" class="headerlink" title="(二)lightroom导入照片的方式"></a>(二)lightroom导入照片的方式</h2><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210211231869.png"><br><font color="#fac08f">复制</font>：将照片复制到新位置并添加到目录<br><font color="#00b0f0">移动</font>：将照片移到新位置并添加到目录<br><font color="#b2a2c7">添加</font>：将照片添加到目录而不移动</p><h2 id="三-筛选和照片分类"><a href="#三-筛选和照片分类" class="headerlink" title="(三)筛选和照片分类"></a>(三)筛选和照片分类</h2><p><strong>可以对照片进行旗标、评定星级和添加颜色标签，以及添加人脸标签来进行标记和分类</strong></p><h3 id="1-添加旗帜"><a href="#1-添加旗帜" class="headerlink" title="1. 添加旗帜"></a>1. 添加旗帜</h3><p>可以把想要保留的照片添加旗标<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210211245144.png"><br>在过滤器中选择留用即可在当前窗口只保留被标记旗子的照片<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210211246948.png"></p><h3 id="2-设置星级"><a href="#2-设置星级" class="headerlink" title="2. 设置星级"></a>2. 设置星级</h3><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210211248403.png"></p><h3 id="3-颜色标签"><a href="#3-颜色标签" class="headerlink" title="3. 颜色标签"></a>3. 颜色标签</h3><p>可以对照片的类型做一个区分，区分日落、夜景等等<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210211250975.png"></p><h3 id="4-人脸标签"><a href="#4-人脸标签" class="headerlink" title="4. 人脸标签"></a>4. 人脸标签</h3><p>通过一张照片上的人脸识别，可以让Lightroom自动搜索所有的照片，并且添加人物标签。</p><h2 id="四-添加导出预设"><a href="#四-添加导出预设" class="headerlink" title="(四)添加导出预设"></a>(四)添加导出预设</h2><p>建议建一个原尺寸JPEG导出预设，其他根据需要添加自定义导出预设<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210211300675.png"></p><p>如果照片导出后预览颜色奇怪，或者在其他设备上看到的颜色和原片不—样，多半是这个色彩空间没有选择sRGB的原因</p><h2 id="五-添加水印"><a href="#五-添加水印" class="headerlink" title="(五)添加水印"></a>(五)添加水印</h2><p>可添加<font color="#ffc000">文字</font>/<font color="#00b0f0">图片</font>水印，导出时勾选即可<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210211303104.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-文件管理体系&quot;&gt;&lt;a href=&quot;#一-文件管理体系&quot; class=&quot;headerlink&quot; title=&quot;(一)文件管理体系&quot;&gt;&lt;/a&gt;(一)文件管理体系&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;使用&lt;font color=&quot;#7030a0&quot;&gt;摄影日期&lt;/font&gt;(或加</summary>
      
    
    
    
    <category term="摄影后期" scheme="https://www.daipeihong.top/categories/%E6%91%84%E5%BD%B1%E5%90%8E%E6%9C%9F/"/>
    
    
    <category term="lightroom" scheme="https://www.daipeihong.top/tags/lightroom/"/>
    
    <category term="后期思路" scheme="https://www.daipeihong.top/tags/%E5%90%8E%E6%9C%9F%E6%80%9D%E8%B7%AF/"/>
    
    <category term="图片管理" scheme="https://www.daipeihong.top/tags/%E5%9B%BE%E7%89%87%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>SystemVerilog学习笔记(七)</title>
    <link href="https://www.daipeihong.top/2022/10/20/systemverilog-xue-xi-bi-ji-qi/"/>
    <id>https://www.daipeihong.top/2022/10/20/systemverilog-xue-xi-bi-ji-qi/</id>
    <published>2022-10-20T11:53:00.000Z</published>
    <updated>2022-10-22T05:29:04.240Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h1><h2 id="实例1-子类没有定义new函数，会调用父类new函数"><a href="#实例1-子类没有定义new函数，会调用父类new函数" class="headerlink" title="实例1 子类没有定义new函数，会调用父类new函数"></a>实例1 子类没有定义new函数，会调用父类new函数</h2><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210202009690.png"><br><strong>仿真结果</strong>：</p><blockquote><p>p.i = 2;<br>lp.i = 2;</p></blockquote><h2 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h2><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210202022227.png"><br><strong>仿真结果</strong>：</p><blockquote><p>lp.i = 3;</p></blockquote><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210202023256.png"></p><h2 id="实例3-如果子类定义function-new，仍会默认调用父类的new函数"><a href="#实例3-如果子类定义function-new，仍会默认调用父类的new函数" class="headerlink" title="实例3 如果子类定义function new，仍会默认调用父类的new函数"></a>实例3 如果子类定义function new，仍会默认调用父类的new函数</h2><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210202056452.png"><br><strong>仿真结果</strong>：</p><blockquote><p>p.i = 2;<br>lp.i = 2;</p></blockquote><h2 id="实例4"><a href="#实例4" class="headerlink" title="实例4"></a>实例4</h2><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210202121976.png"><br>子类和父类出现同名函数function，如果子类没有使用supper.(functionname)，不会调用父类的此函数。如果子类里使用supper.(functionname)，即调用父类的此函数。</p><h2 id="实例5"><a href="#实例5" class="headerlink" title="实例5"></a>实例5</h2><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/20221020213918.png"></p><ol><li>子类带参数，父类不带参数，仍会调用父类new函数。</li><li>只要父类new没有参数，就可以默认调用</li><li>子类必须调动父类的new函数，否则编译无法通过。</li><li>如果父类new函数没有参数，直接调用；如果父类new函数有参数，子类里面需要严格用supper.new</li></ol><h2 id="实例6"><a href="#实例6" class="headerlink" title="实例6"></a>实例6</h2><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210202329703.png"></p><p><strong>仿真结果</strong></p><blockquote><p>p.i = 2;<br>lp.i = 2;<br>after shift p.i = 8;<br>after shift lp.i = 12;</p></blockquote><p><strong>设置断点分析</strong>：<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210202349849.png"></p><p><strong>注意</strong>：</p><ol><li>子类和父类出现同名的函数或者同名的函数或者任务（同名方法），子类想要继承，需要方法名一致参数一致，调用一定写supper</li><li>子类的方法名称可以与父类同名，但子类的变量最好不要跟父类的变量同名</li></ol><h2 id="实例7-子类的句柄能够赋值给父类的句柄，父类的句柄不能赋值给子类的句柄"><a href="#实例7-子类的句柄能够赋值给父类的句柄，父类的句柄不能赋值给子类的句柄" class="headerlink" title="实例7 子类的句柄能够赋值给父类的句柄，父类的句柄不能赋值给子类的句柄"></a>实例7 子类的句柄能够赋值给父类的句柄，父类的句柄不能赋值给子类的句柄</h2>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210212108619.png" width="500" height="530">                    <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210212108436.png" width="500" height="300">        <ol><li>子类的句柄能够赋值给父类的句柄（ ==能够访问区域缩小==），父类的句柄不能赋值给子类的句柄</li><li>lp.i只能指向子类中的i，无法指向父类的i（子类的变量跟父类的变量同名，i被覆盖）；tmp.i可以指向父类的i</li><li>lp能访问子类的i、k、m，无法访问父类的i；tmp能访问父类的i、m，但找不到子类的i、k</li></ol><h1 id="包的使用"><a href="#包的使用" class="headerlink" title="包的使用"></a>包的使用</h1><h2 id="包的概念"><a href="#包的概念" class="headerlink" title="包的概念"></a>包的概念</h2><p>为了使得可以在多个模块（硬件）或者奕（默件)间共子用厂化乂大型,SV添加了包(package) 。包的概念参考于VHDL，用户自定义的类型譬如==类、方法、变量、结构体、枚举类==（==偏软件类，Module、inteface偏硬件就不能定义在包里面==）等都可以在package…endpackage中定义。</p><h2 id="包的使用方法"><a href="#包的使用方法" class="headerlink" title="包的使用方法"></a>包的使用方法</h2><ol><li><p>module、interface、class等可以使用包中定义或者声明的内容。</p></li><li><p>导出：可以通过域的==索引符::号==直接引用。</p>      <meta charset="utf-8">     <title>HTML</title>               <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210212212179.png" width="500" height="300">     </li><li><p>可以==指定索引==一些需要的包中定义的类型到指定的容器中(module/class/…) 。</p>      <meta charset="utf-8">     <title>HTML</title>               <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210212213098.png" width="500" height="300">     </li><li><p>通过通配符$*$来将包中==所有类别导入==到指定容器中。</p></li></ol><h2 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h2>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210212210008.png" width="500" height="1200">        <h1 id="问答题"><a href="#问答题" class="headerlink" title="问答题"></a>问答题</h1><p><strong>1.在packet和linkedpacket有关类的继承的例子中(如图)，tb中的句柄p是否可以访问父类的成员i?lp是否可以访问父类的成员i?句柄tmp是否可以访问子类的成员i?</strong></p><p><strong>代码：</strong></p><pre class=" language-systemverilog"><code class="language-systemverilog">/*Problem1在packet和linkedpacket有关类的继承的例子中(如图)，tb中的句柄p是否可以访问父类的成员i?lp是否可以访问父类的成员i?句柄tmp是否可以访问子类的成员i?*/class packet;    integer i = 1;    integer m = 2;    function new(int val);        i = val + 1;    endfunction    function shift();        i = i << 1;    endfunction    endclass    class linkedpacket extends packet;    integer i = 3;    integer k = 5;    function new (val);        super.new(val);        if (val >= 2)            i = val;    endfunction    function shift();        super.shift();        i = i << 2;    endfunctionendclassmodule tb;    initial begin        packet p = new(3);        linkedpacket lp = new(1);        packet tmp;        tmp = lp;        //tb中的句柄p是否可以访问父类的成员i?    $display("p.i = %0d",p.i);    //lp是否可以访问父类的成员i?     $display("lp.i = %0d",lp.i);//lp.i只能指向子类中的i，无法指向父类的i（子类的变量跟父类的变量同名，i被覆盖）    $display("lp.m = %0d",lp.m);//但lp可以访问父类的其他成员    //句柄tmp是否可以访问子类的成员i?    $display("tmp.i = %0d",tmp.i);    //$display("tmp.k = %0d",tmp.k); //ERROR：Could not find member 'k' in class 'packet', at "class_test.sv", 7.        endendmodule</code></pre><p><strong>仿真结果：</strong></p><blockquote><p>p.i = 4      tb中的句柄p是否可以访问父类的成员i<br>lp.i = 3     lp.i只能指向子类中的i，无法指向父类的i（子类的变量跟父类的变量同名，i被覆盖）<br>lp.m = 2  但lp可以访问父类的其他成员<br>tmp.i = 2  tmp能访问父类的i、m，但找不到子类的i、k</p></blockquote>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210221243924.png" width="500" height="300">        <p><strong>2.试着在对应的位置填入代码，即如何导入pkg_a中的类型packet_a，从pkg_b中导入packet_b，以及从pkg_b中导入静态变量shared?</strong></p><p><strong>代码：</strong></p><pre class=" language-systemverilog"><code class="language-systemverilog">package pkt_a;    class packet_a;        int pkg_a;    endclass    typedef struct{        int data;        int command;        }struct_a;        int va = 1;        int shared = 10;endpackagepackage pkt_b;    class packet_b;        int pkg_b;    endclass    typedef struct{        int data;        int command;        }struct_b;        int vb = 2;        int shared = 20;endpackage                module tb;    class packet_tb;    endclass    typedef struct{        int data;        int command;    }struct_tb;        class packet_a;        int tb_a;    endclass    class packet_b;        int tb_b;    endclass    //how to import type from packages can be seen as follows    //精确导出    import pkt_a::va;    import pkt_b::vb;    //import pkt_a::shared;//从pkt_a取出shared    import pkg_b::shared;//从pkt_b取出shared        ////全部导出    //import pkt_a::*;    //import pkt_b::*;        initial begin         packet_a pa = new();        packet_b pb = new();        packet_tb ptb = new();        $display("pkg_a::va = %0d,pkg_b:: = %0d",va ,vb);        $display("shared = %0d", shared);        //$display("shared = %0d", pkt_b::shared);    end    endmodule</code></pre><p><strong>仿真结果：</strong></p><blockquote><p>pkg_a::va = 1,pkg_b:: = 2<br>shared = 20</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;类的继承&quot;&gt;&lt;a href=&quot;#类的继承&quot; class=&quot;headerlink&quot; title=&quot;类的继承&quot;&gt;&lt;/a&gt;类的继承&lt;/h1&gt;&lt;h2 id=&quot;实例1-子类没有定义new函数，会调用父类new函数&quot;&gt;&lt;a href=&quot;#实例1-子类没有定义new函数，会调用</summary>
      
    
    
    
    <category term="数字IC" scheme="https://www.daipeihong.top/categories/%E6%95%B0%E5%AD%97IC/"/>
    
    
    <category term="SystemVerilog验证" scheme="https://www.daipeihong.top/tags/SystemVerilog%E9%AA%8C%E8%AF%81/"/>
    
    <category term="类(class)" scheme="https://www.daipeihong.top/tags/%E7%B1%BB-class/"/>
    
    <category term="包(package)" scheme="https://www.daipeihong.top/tags/%E5%8C%85-package/"/>
    
  </entry>
  
  <entry>
    <title>SystemVerilog学习笔记(六)</title>
    <link href="https://www.daipeihong.top/2022/10/19/systemverilog-xue-xi-bi-ji-liu/"/>
    <id>https://www.daipeihong.top/2022/10/19/systemverilog-xue-xi-bi-ji-liu/</id>
    <published>2022-10-19T08:31:00.000Z</published>
    <updated>2022-10-23T08:41:28.055Z</updated>
    
    <content type="html"><![CDATA[<p><strong>类</strong>是一种可以包含数据和方法(function,task)的类型。<br>例如一个数据包，可能被定义为一个类，类中可以包含指令、地址、队列ID、时间戳和数据等成员。</p><p>类的三要素：<strong>封装、继承、多态</strong></p><p><strong>OOP（面向对象编程）术语</strong><br><strong>类(class) :  包含成员变量和成员方法。<br>对象(object)</strong>:类在例化后的实例。<br><strong>句柄(handle)</strong> :指向对象的指针。<br><strong>原型(prototype)</strong> :程序的声明部分，包含程序名、返回类型和参数列表。</p><h1 id="（一）类、模块、结构体比较"><a href="#（一）类、模块、结构体比较" class="headerlink" title="（一）类、模块、结构体比较"></a>（一）类、模块、结构体比较</h1>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210190953671.png" width="450" height="550">        <p>c1、c2称为句柄（类似于c中的指针），句柄是否例化通过是否有new的动作判断。new是在仿真时让仿真器创建一个相应实例（如果没有定义new函数，系统也会自动添加一个function new）。调用new函数后，开辟空间存放存放变量。new函数没有返回值，无需表明返回值类型，甚至无需声明void。当创建了一个实际对象时，new函数的返回值为对象的头部句柄（指针）</p>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210190954540.png" width="350" height="500">        <p>仿真目的是仿真真实的硬件，没有run任何时间单位前，整个硬件的结构就确定下来了。在仿真前，模块是有值的，而对象的创建是在仿真以后才会执行：<img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210190955582.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210190955905.png"></p><p>仿真run 0(很小的时间单位)后：<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210190956769.png"><br>同样地在进行仿真前，结构体也会有值（initial中的结构体静态变量同样如此），可进行如下验证：<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210190957043.png"><br>在仿真开始前：<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210190958060.png"></p><p>对new函数函数赋初值(new函数可以传参数)<br>对packet_c创建100个实例如下：<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191046905.png"><br><strong>c1最终指向最后一个实例，前面99个实例无法找回。</strong></p><p><strong>总结：</strong></p><ol><li>SV并不像C++语言一样要求复杂的存储空间开辟和销毁的手段，而是采用了像Java—样空间自动开辟和回收的手段。</li><li>因此SV的类在定义时，只需要定义构建函数(constructor)而不需要定义析构函数(destructor) 。</li><li>类在定义时，需要定义构建函数，如果未定义，则系统会自动帮助定义一个空的构建函数（没有形式参数，函数体亦为空)。</li></ol><h1 id="（二）句柄的拷贝"><a href="#（二）句柄的拷贝" class="headerlink" title="（二）句柄的拷贝"></a>（二）句柄的拷贝</h1>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191328440.jpg" width="550" height="850">        <p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191335916.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191335243.png"></p><p>两个句柄一个对象，几个new几个对象。（赋值的是句柄，不是对象!）<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191336888.png"></p><h1 id="（三）静态变量-amp-动态变量"><a href="#（三）静态变量-amp-动态变量" class="headerlink" title="（三）静态变量&amp;动态变量"></a>（三）静态变量&amp;动态变量</h1><p><strong>静态变量</strong>：仿真开始前已经分配空间<br><strong>动态变量</strong>：仿真开始时才分配空间<br>默认类里面所有成员(成员变量、成员方法或者其他)均是动态的，如果想要使用静态的，可用static<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191341299.png"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191343949.png"></p><p>此时句柄悬空，能否找到data？</p>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191424199.png" width="550" height="850">        <p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191424614.png"><br>编译器在编译时分析，句柄指向data是一个静态变量，仿真时data不会存放到任何实例化对象里面（c1.data、c2.data，任何一个data变量的存放空间不会在任何一个实例化的对象里面，如果存放在实例化对象里面，则空间各自独立。真正的空间在编译过程中开辟，可以姑且理解为放在类的下面）因此，编译器在编译时告诉我们说c1句柄指向的是packet这个类，data是一个静态变量。接下来仿真过程中找data时，不管c1有无指向对象，真正要找的变量放在类的域里面。</p><p><strong>总结：</strong></p><ol><li>类的成员(变量/方法)默认都是动态(automatic)生命周期，即每一个对象的变量和方法都会为其开辟新的空间。</li><li>如果多个对象为了共享一个成员(变量/方法)，那么可以为其添加关键字static。</li><li>多个对象因此可以共享同一个成员变量或者方法。</li><li>访问该成员时，无需进行对象的例化。</li><li>成员方法也可以声明为静态。</li><li>静态方法无法访问非静态成员(变量/方法)，否则会发生编译错误。</li></ol><h1 id="（四）this"><a href="#（四）this" class="headerlink" title="（四）this"></a>（四）this</h1><ol><li>this是用来明确索引当前所在对象的成员(变量/参数/方法。</li><li>this只可以用来在类的非静态成员、约束和覆盖组中使用。</li><li>this的使用可以明确所指向变量的作用域。</li></ol><pre class=" language-systemverilog"><code class="language-systemverilog">class Demo ;    integer x;    function new (integer x) ;        this.x =x;    endfunction    endclass</code></pre><p>this<br>赋值拷贝<br>链表</p><h1 id="（五）浅拷贝与深拷贝"><a href="#（五）浅拷贝与深拷贝" class="headerlink" title="（五）浅拷贝与深拷贝"></a>（五）浅拷贝与深拷贝</h1><p><strong>浅拷贝</strong>：只能拷贝成员里面的变量<br><strong>深拷贝</strong>：递进式拷贝，拷贝句柄及其指定对象。深拷贝与浅拷贝空间独立。</p>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191548706.png" width="500" height="260">        <h1 id="（六）数据的隐藏和封装"><a href="#（六）数据的隐藏和封装" class="headerlink" title="（六）数据的隐藏和封装"></a>（六）数据的隐藏和封装</h1><ol><li>类的成员(变量/方法)默认情况下，即是公共属性的。这表示对于类自身和外部均可以访问该成员。</li><li>对于成员的限定，如果使用local，则只有该类可以访问此成员，而子类或者外部均无法访问。</li><li>对于成员的限定，如果使用protected，则表示该类和其子类均可以访问此成员，而外部无法访问。</li></ol><pre class=" language-systemverilog"><code class="language-systemverilog">class Packet;    local integer i ;    function integer compare (Packet other) ;        compare = (this.i =other.i) ;    endfunctionendclass</code></pre><ol start="4"><li>对于商业开发，类的提供方会限制一些类成员的外部访问权限，继而隐藏类成员的更多细节。这种方式也使得类的外部访问接口更为精简，减轻了类的维护工作量，也使得类在修改时便于与旧版本保持兼容。数据隐藏的方式使得类的测试和维护都变得更为简单。</li></ol><p><strong>问答题</strong><br><strong>1.类和结构体的联系和差别有哪些?类和模块(module)的联系和差别有哪些?</strong><br>    <strong>类与结构体:</strong><br>    同：都可以包含指令、地址、队列ID、时间戳和数据等成员。<br>    异：(1)类需要调用new函数进行例化，才会开辟空间存放存放变量。而结构体在仿真前就开辟空间存放变量；(2)类可以包含数据和方法(function,task)的类型。<br>    <strong>类与模块：</strong><br>    同：都可以包含数据和方法(function,task)的类型。<br>    异：(1)类中的成员变量和方法默认是动态的，而模块默认是静态的；(2)在仿真前，模块是有值的，而类中对象的创建是在仿真以后才会执行</p><p><strong>3.如果有同名的模块，那么在编译过程中应该怎么解决“同名”问题?</strong><br>    可以用 this来明确索引当前所在对象的成员(变量/参数)方法。this只可以用来在类的非静态成员、约束和覆盖组中使用。</p><pre class=" language-systemverilog"><code class="language-systemverilog">class Demo ;    integer x;    function new (integer x) ;        this.x =x;    endfunction    endclass</code></pre><p>可参考：<a href="https://zhuanlan.zhihu.com/p/480524030">结构体、模块和类的联系和区别？ 类的学习小结 - 知乎 (zhihu.com)</a></p>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191616982.png" width="550" height="1000">        ]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;类&lt;/strong&gt;是一种可以包含数据和方法(function,task)的类型。&lt;br&gt;例如一个数据包，可能被定义为一个类，类中可以包含指令、地址、队列ID、时间戳和数据等成员。&lt;/p&gt;
&lt;p&gt;类的三要素：&lt;strong&gt;封装、继承、多态&lt;/strong&gt;</summary>
      
    
    
    
    <category term="数字IC" scheme="https://www.daipeihong.top/categories/%E6%95%B0%E5%AD%97IC/"/>
    
    
    <category term="数字前端" scheme="https://www.daipeihong.top/tags/%E6%95%B0%E5%AD%97%E5%89%8D%E7%AB%AF/"/>
    
    <category term="SystemVerilog验证" scheme="https://www.daipeihong.top/tags/SystemVerilog%E9%AA%8C%E8%AF%81/"/>
    
    <category term="类" scheme="https://www.daipeihong.top/tags/%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>sv第六周思维导图</title>
    <link href="https://www.daipeihong.top/2022/10/19/sv-di-liu-zhou-si-wei-dao-tu/"/>
    <id>https://www.daipeihong.top/2022/10/19/sv-di-liu-zhou-si-wei-dao-tu/</id>
    <published>2022-10-19T08:31:00.000Z</published>
    <updated>2022-10-19T08:31:47.523Z</updated>
    
    <content type="html"><![CDATA[<p><strong>类</strong>是一种可以包含数据和方法(function,task)的类型。<br>例如一个数据包，可能被定义为一个类，类中可以包含指令、地址、队列ID、时间戳和数据等成员。</p><p>类的三要素：<strong>封装、继承、多态</strong></p><p><strong>OOP（面向对象编程）术语</strong><br><strong>类(class) :  包含成员变量和成员方法。<br>对象(object)</strong>:类在例化后的实例。<br><strong>句柄(handle)</strong> :指向对象的指针。<br><strong>原型(prototype)</strong> :程序的声明部分，包含程序名、返回类型和参数列表。</p><h1 id="（一）类、模块、结构体比较"><a href="#（一）类、模块、结构体比较" class="headerlink" title="（一）类、模块、结构体比较"></a>（一）类、模块、结构体比较</h1>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210190953671.png" width="450" height="550">        <p>c1、c2称为句柄（类似于c中的指针），句柄是否例化通过是否有new的动作判断。new是在仿真时让仿真器创建一个相应实例（如果没有定义new函数，系统也会自动添加一个function new）。调用new函数后，开辟空间存放存放变量。new函数没有返回值，无需表明返回值类型，甚至无需声明void。当创建了一个实际对象时，new函数的返回值为对象的头部句柄（指针）</p>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210190954540.png" width="350" height="500">        <p>仿真目的是仿真真实的硬件，没有run任何时间单位前，整个硬件的结构就确定下来了。在仿真前，模块是有值的，而对象的创建是在仿真以后才会执行：<img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210190955582.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210190955905.png"></p><p>仿真run 0(很小的时间单位)后：<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210190956769.png"><br>同样地在进行仿真前，结构体也会有值（initial中的结构体静态变量同样如此），可进行如下验证：<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210190957043.png"><br>在仿真开始前：<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210190958060.png"></p><p>对new函数函数赋初值(new函数可以传参数)<br>对packet_c创建100个实例如下：<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191046905.png"><br><strong>c1最终指向最后一个实例，前面99个实例无法找回。</strong></p><p><strong>总结：</strong></p><ol><li>SV并不像C++语言一样要求复杂的存储空间开辟和销毁的手段，而是采用了像Java—样空间自动开辟和回收的手段。</li><li>因此SV的类在定义时，只需要定义构建函数(constructor)而不需要定义析构函数(destructor) 。</li><li>类在定义时，需要定义构建函数，如果未定义，则系统会自动帮助定义一个空的构建函数（没有形式参数，函数体亦为空)。</li></ol><h1 id="（二）句柄的拷贝"><a href="#（二）句柄的拷贝" class="headerlink" title="（二）句柄的拷贝"></a>（二）句柄的拷贝</h1>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191328440.jpg" width="550" height="850">        <p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191335916.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191335243.png"></p><p>两个句柄一个对象，几个new几个对象。（赋值的是句柄，不是对象!）<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191336888.png"></p><h1 id="（三）静态变量-amp-动态变量"><a href="#（三）静态变量-amp-动态变量" class="headerlink" title="（三）静态变量&amp;动态变量"></a>（三）静态变量&amp;动态变量</h1><p><strong>静态变量</strong>：仿真开始前已经分配空间<br><strong>动态变量</strong>：仿真开始时才分配空间<br>默认类里面所有成员(成员变量、成员方法或者其他)均是动态的，如果想要使用静态的，可用static<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191341299.png"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191343949.png"></p><p>此时句柄悬空，能否找到data？</p>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191424199.png" width="550" height="850">        <p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191424614.png"><br>编译器在编译时分析，句柄指向data是一个静态变量，仿真时data不会存放到任何实例化对象里面（c1.data、c2.data，任何一个data变量的存放空间不会在任何一个实例化的对象里面，如果存放在实例化对象里面，则空间各自独立。真正的空间在编译过程中开辟，可以姑且理解为放在类的下面）因此，编译器在编译时告诉我们说c1句柄指向的是packet这个类，data是一个静态变量。接下来仿真过程中找data时，不管c1有无指向对象，真正要找的变量放在类的域里面。</p><p><strong>总结：</strong></p><ol><li>类的成员(变量/方法)默认都是动态(automatic)生命周期，即每一个对象的变量和方法都会为其开辟新的空间。</li><li>如果多个对象为了共享一个成员(变量/方法)，那么可以为其添加关键字static。</li><li>多个对象因此可以共享同一个成员变量或者方法。</li><li>访问该成员时，无需进行对象的例化。</li><li>成员方法也可以声明为静态。</li><li>静态方法无法访问非静态成员(变量/方法)，否则会发生编译错误。</li></ol><h1 id="（四）this"><a href="#（四）this" class="headerlink" title="（四）this"></a>（四）this</h1><ol><li>this是用来明确索引当前所在对象的成员(变量/参数/方法。</li><li>this只可以用来在类的非静态成员、约束和覆盖组中使用。</li><li>this的使用可以明确所指向变量的作用域。</li></ol><pre class=" language-systemverilog"><code class="language-systemverilog">class Demo ;    integer x;    function new (integer x) ;        this.x =x;    endfunction    endclass</code></pre><p>this<br>赋值拷贝<br>链表</p><h1 id="（五）浅拷贝与深拷贝"><a href="#（五）浅拷贝与深拷贝" class="headerlink" title="（五）浅拷贝与深拷贝"></a>（五）浅拷贝与深拷贝</h1><p><strong>浅拷贝</strong>：只能拷贝成员里面的变量<br><strong>深拷贝</strong>：递进式拷贝，拷贝句柄及其指定对象。深拷贝与浅拷贝空间独立。</p>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191548706.png" width="500" height="260">        <h1 id="（六）数据的隐藏和封装"><a href="#（六）数据的隐藏和封装" class="headerlink" title="（六）数据的隐藏和封装"></a>（六）数据的隐藏和封装</h1><ol><li>类的成员(变量/方法)默认情况下，即是公共属性的。这表示对于类自身和外部均可以访问该成员。</li><li>对于成员的限定，如果使用local，则只有该类可以访问此成员，而子类或者外部均无法访问。</li><li>对于成员的限定，如果使用protected，则表示该类和其子类均可以访问此成员，而外部无法访问。</li></ol><pre class=" language-systemverilog"><code class="language-systemverilog">class Packet;    local integer i ;    function integer compare (Packet other) ;        compare = (this.i =other.i) ;    endfunctionendclass</code></pre><ol start="4"><li>对于商业开发，类的提供方会限制一些类成员的外部访问权限，继而隐藏类成员的更多细节。这种方式也使得类的外部访问接口更为精简，减轻了类的维护工作量，也使得类在修改时便于与旧版本保持兼容。数据隐藏的方式使得类的测试和维护都变得更为简单。</li></ol><p><strong>问答题</strong><br><strong>1.类和结构体的联系和差别有哪些?类和模块(module)的联系和差别有哪些?</strong><br>    <strong>类与结构体:</strong><br>    同：都可以包含指令、地址、队列ID、时间戳和数据等成员。<br>    异：(1)类需要调用new函数进行例化，才会开辟空间存放存放变量。而结构体在仿真前就开辟空间存放变量；(2)类可以包含数据和方法(function,task)的类型。<br>    <strong>类与模块：</strong><br>    同：都可以包含数据和方法(function,task)的类型。<br>    异：(1)类中的成员变量和方法默认是动态的，而模块默认是静态的；(2)在仿真前，模块是有值的，而类中对象的创建是在仿真以后才会执行</p><p><strong>3.如果有同名的模块，那么在编译过程中应该怎么解决“同名”问题?</strong><br>    可以用 this来明确索引当前所在对象的成员(变量/参数)方法。this只可以用来在类的非静态成员、约束和覆盖组中使用。</p><pre class=" language-systemverilog"><code class="language-systemverilog">class Demo ;    integer x;    function new (integer x) ;        this.x =x;    endfunction    endclass</code></pre><p>可参考：<a href="https://zhuanlan.zhihu.com/p/480524030">结构体、模块和类的联系和区别？ 类的学习小结 - 知乎 (zhihu.com)</a></p>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191616982.png" width="550" height="1000">        ]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;类&lt;/strong&gt;是一种可以包含数据和方法(function,task)的类型。&lt;br&gt;例如一个数据包，可能被定义为一个类，类中可以包含指令、地址、队列ID、时间戳和数据等成员。&lt;/p&gt;
&lt;p&gt;类的三要素：&lt;strong&gt;封装、继承、多态&lt;/strong&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>SystemVerilog课程笔记(五)</title>
    <link href="https://www.daipeihong.top/2022/10/17/systemverilog-ke-cheng-bi-ji-wu/"/>
    <id>https://www.daipeihong.top/2022/10/17/systemverilog-ke-cheng-bi-ji-wu/</id>
    <published>2022-10-17T08:05:00.000Z</published>
    <updated>2022-10-23T08:06:25.693Z</updated>
    
    <content type="html"><![CDATA[<h1 id="stimulator只发送数据，构建generator产生数据"><a href="#stimulator只发送数据，构建generator产生数据" class="headerlink" title="stimulator只发送数据，构建generator产生数据"></a>stimulator只发送数据，构建generator产生数据</h1><h1 id="一个process接收数据发送到不同的端口"><a href="#一个process接收数据发送到不同的端口" class="headerlink" title="一个process接收数据发送到不同的端口"></a>一个process接收数据发送到不同的端口</h1><p><strong>增加要求</strong>：如果两个chnl没有冲突，可以同时发送<br><strong>具体为：</strong><br>来自于不同的source chnl就可以并行发送<br>source chnl、destination chnl不一样可以并行发送<br><strong>代码：</strong></p><pre class=" language-systemverilog"><code class="language-systemverilog">typedef struct{  bit [3:0] src;  bit [3:0] dst;  bit [7:0] data [];}rt_packet_t;//**********************************  rt_stimulator  ***********************************//interface rt_interface;    logic clock;    logic reset_n;    logic [15:0] din;    logic [15:0] frame_n;    logic [15:0] valid_n;    logic [15:0] dout;    logic [15:0] valido_n;    logic [15:0] busy_n;    logic [15:0] frameo_n;endinterface    module rt_stimulator(  rt_interface intf);//for debug purpose from waveform    typedef enum {DRV_RESET,DRV_IDLE,DRV_ADDR,DRV_PAD,DRV_DATA} drv_state_t;    drv_state_t dbg_state;//定义状态检测变量dbg_state    byte unsigned dbg_din_chnl0_data;    rt_packet_t pkts[$];    int src_chnl_status[int];  //关联数组，后面int：src_chnl的number；前面int：dest_chnl的Number ？？    function void put_pkt(input rt_packet_t p);        pkts.push_back(p);    endfunction    initial begin : drive_reset_proc        drive_reset();    end    task drive_reset();        @(negedge intf.reset_n);        dbg_state <= DRV_RESET;        intf.din <= 0;        intf.frame_n <= '1;        intf.valid_n <= '1;    endtask    initial begin : drive_chnl_proc        @(negedge intf.reset_n);        repeat(10) @(posedge intf.clock);        forever begin             automatic rt_packet_t p;//声明一个动态的            wait(pkts.size() > 0);            p = pkts.pop_front();            fork//后台触发线程，触发线程在后台运行，继续执行剩下内容                begin                wait_src_chnl_avail(p);                drive_chnl(p.src, p.dst, p.data);                set_src_chnl_avail(p);                end            join_none        end    end        task automatic wait_src_chnl_avail(rt_packet_t p);//判断src chnl是否被占用，是否需要等待    if(!src_chnl_status.exists(p.src))//动态数组为空        src_chnl_status[p.src] = p.dst;//表示当前正在使用src_chnl,对应dest就是p.dst    else if(src_chnl_status[p.src] >= 0)//如果给dest的0,1,2这样的chnl在发送数据，需要等待        wait(src_chnl_status[p.src] == -1);//直到    endtask        function automatic set_src_chnl_avail(rt_packet_t p);        src_chnl_status[p.src] = -1;//如果chnl发送完后，把src_chnl置回来    endfunction    task automatic drive_chnl(bit [3:0] saddr, bit[3:0] daddr, byte unsigned data[]);        $display("@%0t:[DRV] src_chnl[%0d] & dest_chnl[%0d] data trans started",$time,saddr,daddr);// drive address phase         for(int i=0; i<4; i++)begin        @(posedge intf.clock);        dbg_state <=DRV_ADDR;        intf.din[saddr] <= daddr[i];        intf.valid_n[saddr] <= $urandom_range(0,1);        intf.frame_n[saddr] <= 1'b0;    end// drive pad phase   for (int i=0; i<5; i++)begin    @(posedge intf.clock);    dbg_state <= DRV_PAD;    intf.din[saddr] <= 1'b1;    intf.valid_n[saddr] <= 1'b1;    intf.frame_n[saddr] <= 1'b0;  end// drive data phase  foreach(data[id])begin    for(int i=0;i<8; i++)begin    @(posedge intf.clock);    dbg_state <= DRV_DATA;    dbg_din_chnl0_data <= data[id];    intf.din[saddr] <= data[id][i];    intf.valid_n[saddr] <=1'b0;    intf.frame_n[saddr] <= (id == data.size()-1 && i == 7) ? 1'b1 : 1'b0;    end  end// drive idle phase  @(posedge intf.clock);  dbg_state <= DRV_IDLE;  dbg_din_chnl0_data <= 0;  intf.din[saddr] <= 1'b0;  intf.valid_n[saddr] <= 1'b1;  intf.frame_n[saddr] <= 1'b1;  $display("@%0t:[DRV] src_chnl[%0d] &dest_chnl[%0d ]data trans finished",$time,saddr,daddr);endtaskendmodule//**********************************  rt_generator  ************************************//module rt_generator;  rt_packet_t pkts[$];//定义队列pkts  function void put_pkt(input rt_packet_t p);    pkts.push_back(p);//在pkts队列尾插入p  endfunction  task get_pkt(output rt_packet_t p);    wait(pkts.size() >0 )      p = pkts.pop_front();//pkts.size()>0时执行，提取队列首元素，输出队列首元素  endtask  //generate a random packet  function void gen_pkt(int src = -1, int dst = -1);  endfunctionendmodulemodule rt_test_top;endmodule//********************************** tb  ************************************//module tb;    bit clk,rstn;    logic [15:0] din, frame_n, valid_n;    logic [15:0] dout, valido_n, busy_n, frameo_n;    // generate clock    initial         forever #5ns clk <= !clk;    // genarate reset    initial begin        #2ns  rstn <= 1;        #10ns rstn <= 0;        #10ns rstn <= 1;    end    router dut(//例化router为dut        .reset_n(rstn)        ,.clock(clk)        ,.frame_n(intf.frame_n)        ,.valid_n(intf.valid_n)        ,.din(intf.din)        ,.dout(intf.dout)        ,.busy_n(intf.busy_n)        ,.valido_n(intf.valido_n)        ,.frameo_n(intf.frameo_n));    rt_interface intf(); //例化rt_interface为intf    assign intf.reset_n = rstn;    assign intf.clock = clk;        rt_stimulator stim(intf);//例化rt_stimulator为stim    rt_generator gen(); //例化rt_generator为gen //generate and transmit packet 产生数据    initial begin : generate_proc        rt_packet_t p;        gen.put_pkt('{0,3,'{8'h33,8'h77}});        gen.put_pkt('{0,5,'{8'h55,8'h66}});        gen.put_pkt('{3,6,'{8'h77,8'h88,8'h22}});        gen.put_pkt('{4,7,'{8'haa,8'hcc,8'h33}});    end        initial begin : transmit_proc        rt_packet_t p;    forever  begin       gen.get_pkt(p);//generator输出p，p为generator里pkts的首元素      stim.put_pkt(p);//把数据p输入stim里的pkts队列尾   end  end  endmodule</code></pre><p><strong>代码结果</strong><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210201409514.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210201543806.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;stimulator只发送数据，构建generator产生数据&quot;&gt;&lt;a href=&quot;#stimulator只发送数据，构建generator产生数据&quot; class=&quot;headerlink&quot; title=&quot;stimulator只发送数据，构建generator产生数</summary>
      
    
    
    
    <category term="数字IC" scheme="https://www.daipeihong.top/categories/%E6%95%B0%E5%AD%97IC/"/>
    
    
    <category term="数字前端" scheme="https://www.daipeihong.top/tags/%E6%95%B0%E5%AD%97%E5%89%8D%E7%AB%AF/"/>
    
    <category term="SystemVerilog验证" scheme="https://www.daipeihong.top/tags/SystemVerilog%E9%AA%8C%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>车规芯片(三）常用ECC算法简述</title>
    <link href="https://www.daipeihong.top/2022/10/13/che-gui-xin-pian-san-chang-yong-ecc-suan-fa-jian-shu/"/>
    <id>https://www.daipeihong.top/2022/10/13/che-gui-xin-pian-san-chang-yong-ecc-suan-fa-jian-shu/</id>
    <published>2022-10-13T01:23:00.000Z</published>
    <updated>2022-10-23T07:41:16.384Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ECC工作原理"><a href="#ECC工作原理" class="headerlink" title="ECC工作原理"></a>ECC工作原理</h1><p><a href="https://blog.csdn.net/qq_39560607/article/details/81714141?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166571376316782425174007%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166571376316782425174007&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-81714141-null-null.142%5Ev56%5Econtrol,201%5Ev3%5Econtrol_2&amp;utm_term=ecc%E7%BA%A0%E9%94%99&amp;spm=1018.2226.3001.4187">ECC检验与纠错_Christal_RJ的博客-CSDN博客</a><br>ECC有三种常用的算法，包括汉明码(hamming code)、RS码(Reed Solomon code)和BCH码。其中汉明码是FSMC模块的硬件ECC所采用的校验方式。</p><h1 id="ECC常见算法"><a href="#ECC常见算法" class="headerlink" title="ECC常见算法"></a>ECC常见算法</h1><h2 id="汉明码"><a href="#汉明码" class="headerlink" title="汉明码"></a>汉明码</h2><h3 id="以1-Byte的数据包为例"><a href="#以1-Byte的数据包为例" class="headerlink" title="以1 Byte的数据包为例"></a>以1 Byte的数据包为例</h3><p>为计算ECC值，数据包中的比特数据要先进行分割，如1/2组(Halfs)、1/4组(Fourths)、1/8(Bits)组等，直到其精度达到单个比特为止，以8 bit即1 Byte的数据包为例进行说明，</p>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210132031028.png" width="500" height="300" title="8比特Data汉明校验元计算">        每$2^n-1$比特数据计算得到n比特ECC值，而该汉明算法需要一对ECC值(偶校验值ECCe和奇校验值ECCo，如上图所示，^表示异或)，因此共需要2n比特。计算之后，原数据包和ECC数值被写入。稍后，原数据包读取出，此时ECC值将重新计算。如果新计算的ECC不同于先前编入的ECC，那么表明数据在读写过程中出错。```ad-exampletitle: 示例type=例：原始数据为01010101，计算并存入的ECC值是ECCe=000、ECCo=000。若其中有1个单一的比特出现错误，出错后的数据是01010001。计算新ECC值如下：            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210132129859.png" width="500" height="300">        ```<p><strong>检验是否发生错误</strong><br>通过计算Error进行判断：<br>    Error[2:0]=ECCe <strong>⊕</strong> ECCo <strong>⊕</strong> ECCe’ <strong>⊕</strong> ECCo’<br>Error=111表示发生一位错误，Error=000表示没有发生错误，而 Error不是上述两个值时，表示发生2位及以上错误，出现的可能性非常低。</p>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210132131177.png" width="100" height="150">        <p><strong>检测错误发生位置</strong><br>通过计算Error_Loc进行判断：<br>    Error_Loc[2:0]=ECCo<strong>⊕</strong>ECCo’ = 000<strong>⊕</strong>010 = 010<br>Error_Loc=010，表示Data的第二位（data[3]）发生错误，对应取反即可。<br>按照此思路，8比特Data汉明校验元生成电路如下图所示：</p>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210132142743.jpg" width="400" height="300" title="8比特Data汉明校验元生成电路">        <p>8比特Data汉明校验元生成电路由14个异或门组成</p><h3 id="以4-Byte的数据包为例"><a href="#以4-Byte的数据包为例" class="headerlink" title="以4 Byte的数据包为例"></a>以4 Byte的数据包为例</h3><p>将汉明校验的计算推广到4个字节作为一个分组块，现在字节和比特排列如下图所示：</p>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210140854286.png" width="500" height="200">        <p>现在计算偶校验值ECCe和奇校验值ECCo如下：</p>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210140900859.jpg" width="510" height="100">        <p><strong>行校验码</strong>：<br>    行偶校验码：<br>        Byte-Even half = B1<strong>⊕</strong>B0<br>        Byte-Even bits  = B2<strong>⊕</strong>B0<br>    行奇校验码：<br>        Byte-Odd half = B3<strong>⊕</strong>B2<br>        Byte-Odd bits  = B3<strong>⊕</strong>B1<br>    其中，Bi = Di[7]<strong>⊕</strong>Di[6]<strong>⊕</strong>Di[5]<strong>⊕</strong>Di[4]<strong>⊕</strong>Di[3]<strong>⊕</strong>Di[2]<strong>⊕</strong>Di[1]<strong>⊕</strong>Di[0]</p><p><strong>列校验码</strong>：<br>    列偶校验码：<br>        Bit-Even half      = D[3]<strong>⊕</strong>D[2]<strong>⊕</strong>D[1]<strong>⊕</strong>D[0]<br>        Bit-Even fourth = D[5]<strong>⊕</strong>D[4]<strong>⊕</strong>D[1]<strong>⊕</strong>D[0]<br>        Bit-Even bits       = D[6]<strong>⊕</strong>D[4]<strong>⊕</strong>D[2]<strong>⊕</strong>D[0]<br>    列奇校验码：<br>        Bit-Odd half      = D[7]<strong>⊕</strong>D[6]<strong>⊕</strong>D[5]<strong>⊕</strong>D[4]<br>        Bit-Odd fourth = D[7]<strong>⊕</strong>D[6]<strong>⊕</strong>D[3]<strong>⊕</strong>D[2]<br>        Bit-Odd bits       = D[7]<strong>⊕</strong>D[5]<strong>⊕</strong>D[3]<strong>⊕</strong>D[1]<br>    其中，D[i]=D3[i]<strong>⊕</strong>D2[i]<strong>⊕</strong>D1[i]<strong>⊕</strong>DO[i]（每个字节对应位置都加入计算）<br>    <br>    <br>        <meta charset="utf-8"><br>        <title>HTML</title><br>    <br>        <br>            <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210140916084.png" width="750" height="900"><br>        </p>![]()例：假设4个字节数据Byte3~Byte1分别是01010101,11001100,10001000,00100010，计算得到的ECCe=00000, ECCo=00000，若此时 Byte1发生错误变成10000000(第3位从1翻转成0)，计算得到新的ECCe=10100，ECCo'=01011，因此通过计算Error=11111，表示发生一位错误，计算Error_Loc=01011,表示该位错误发生在01字节即 Byte1的第011位即第3位<h2 id="BCH码"><a href="#BCH码" class="headerlink" title="BCH码"></a>BCH码</h2><p>BCH码是循环码中的一个重要子类，它具有纠正多个错误的能力,广泛应用于移动通信和卫星通信中。BCH码有着严密的代数结构，是目前研究得比较透彻的一种码。关于BCH码编码的原理详解可参考：<a href="https://zhuanlan.zhihu.com/p/95909150">【举例子详细分析】BCH码(BCH code)</a></p><h2 id="RS码"><a href="#RS码" class="headerlink" title="RS码"></a>RS码</h2><p>里德-所罗门(Reed-Solomon，RS）码是BCH码的一个重要分类，RS码是一种非二进制的BCH码，具有较强的纠错能力。</p><h2 id="LDPC码"><a href="#LDPC码" class="headerlink" title="LDPC码"></a>LDPC码</h2><p>LDPC码即低密度奇偶校验码（Low Density Parity Check Code，LDPC），它由Robert G.Gallager博士于1963年提出的一类具有稀疏校验矩阵的线性分组码，不仅有逼近Shannon限的良好性能，而且译码复杂度较低，结构灵活，是近年信道编码领域的研究热点。<br>&nbsp;&nbsp;LDPC码是一种分组码，其校验矩阵只含有很少量非零元素（稀疏矩阵）。&nbsp;&nbsp;</p><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p>[1]陈武. Nand Flash纠错码的设计研究[D].浙江大学,2011.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ECC工作原理&quot;&gt;&lt;a href=&quot;#ECC工作原理&quot; class=&quot;headerlink&quot; title=&quot;ECC工作原理&quot;&gt;&lt;/a&gt;ECC工作原理&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_39560607/article</summary>
      
    
    
    
    <category term="数字IC" scheme="https://www.daipeihong.top/categories/%E6%95%B0%E5%AD%97IC/"/>
    
    
    <category term="车规芯片" scheme="https://www.daipeihong.top/tags/%E8%BD%A6%E8%A7%84%E8%8A%AF%E7%89%87/"/>
    
    <category term="汉明码" scheme="https://www.daipeihong.top/tags/%E6%B1%89%E6%98%8E%E7%A0%81/"/>
    
    <category term="RS码" scheme="https://www.daipeihong.top/tags/RS%E7%A0%81/"/>
    
    <category term="BCH码" scheme="https://www.daipeihong.top/tags/BCH%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>车规芯片(二)  ECC概述</title>
    <link href="https://www.daipeihong.top/2022/10/10/che-gui-xin-pian-er-ecc-gai-shu/"/>
    <id>https://www.daipeihong.top/2022/10/10/che-gui-xin-pian-er-ecc-gai-shu/</id>
    <published>2022-10-10T07:51:00.000Z</published>
    <updated>2022-10-23T07:41:23.495Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>ECC 是“<strong>Error Correcting Code</strong>”的简写，中文名称是“<strong>错误检查和纠正</strong>”，是一种能够实现“错误检查和纠正”的技术。<br>在数字电路中，最小的数据单位就是叫“比特（bit）”，也叫数据“位”，“比特”也是内存中的最小单位，它是通过“1”和“0”表示数据高、低电平信号的。空间中的无线电磁干扰、电路噪声会导致内存与CPU在进行数据交互的时候发生<strong>比特翻转</strong>(“0”变为“1”,“1”变为“0”)。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210101914584.png"><br>若某一位存储出了错误，就会使其中存储的相应数据发生改变而导致应用程序发生错误。大多数内存错误可通过<strong>重启</strong>解决，重启后内存里的数据被重新写入一遍。对于某些服务器来说，宕机一次带来的损失是巨大的，因此服务器往往会使用稳定性更高的<strong>ECC内存</strong>，这种内存回以主动发现数据传输过程中出现的错误，并将错误纠正。<br>对数据的校验常用的有<strong>奇偶校验</strong>、<strong>CRC校验</strong>等，而在NAND&nbsp;Flash处理中，一般使用一种比较专用的校验——<strong>ECC</strong>。ECC能纠正单比特错误和检测双比特错误，而且计算速度很快，但对1比特以上的错误无法纠正，对2比特以上的错误不保证能检测。</p><h1 id="最简单的措施"><a href="#最简单的措施" class="headerlink" title="最简单的措施"></a>最简单的措施</h1><p>为避免内存出错的情况，最简单的方法是在传输过程中，一组数据传输三遍。如果某组数据发生错误，通过对比其余两组数据，以其中相同的那两个为准，可定位错误的位置并纠正(只针对三组数据同一位置只有一个错误的情况，同时发生两个错误且同时位于同一位置的概率很低)。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210101459072.gif"><br>如果三组数据同一位置都发生了比特翻转，在纠错的过程中就会把错误的数据当成正确的数据，导致数据出错。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210101507147.gif"><br>但同时发生两个错误且同时位于同一位置的概率很低，这种方法最大的缺点在于浪费带宽，所有户数中只有1/3是有效的。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210101625760.png"><br>为了减少纠错码的占比，又能纠正错误，奇偶校验法被提出。</p><h1 id="奇偶校验法（parity-check）"><a href="#奇偶校验法（parity-check）" class="headerlink" title="奇偶校验法（parity check）"></a>奇偶校验法（parity check）</h1><p>二级制数只有0和1，在数据开头增加一位“纠错码”，然后数出原始数据中1的个数。比如一个字节中存储了某一数值，数其中“1”的个数：若“1”为偶数个，纠错码定义为0。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210101652124.png"><br>若“1”为奇数个，纠错码定义为1，把总数据的1的个数填补成偶数。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210101652603.png"><br>所以接收方接收到数据后，如果数据中“1”的个数是偶数个，则数据没有错误。如果是奇数个，则数据发生了错误，因此需要重新传输新数据。当纠错码自己发生了比特翻转，仍能够检测出数据发生了错误。这是因为<strong>奇偶校验不是用一个数据去保护其他数据，而是通过1个数据政变整组数据的奇偶性，纠错码本身就存在于这组数据中。</strong><br>但奇偶校验存在不足：当内存查到某个数据位有错误时，却并不一定能确定在哪一个位，也就不一定能修正错误，所以带有奇偶校验的内存的主要功能仅仅是“发现错误”，并不能纠正部分简单的错误。而且，如果同时有两个位发生比特翻转，“1”的总个数还是偶数，这种情况便检测不出数据是否发生错误。针对奇偶校验码的缺陷，<a href="https://baike.baidu.com/item/%E7%90%86%E6%9F%A5%E5%BE%B7%C2%B7%E5%8D%AB%E6%96%AF%E9%87%8C%C2%B7%E6%B1%89%E6%98%8E/9114683">理查德·卫斯里·汉明</a>在其基础上发明了汉明码。</p><h1 id="汉明码"><a href="#汉明码" class="headerlink" title="汉明码"></a>汉明码</h1><h2 id="汉明码的思想"><a href="#汉明码的思想" class="headerlink" title="汉明码的思想"></a>汉明码的思想</h2><p>这种纠错的基本思想是如何多次使用奇偶校验来<strong>二分</strong>查找出错误所在。</p><h2 id="汉明码基本原理"><a href="#汉明码基本原理" class="headerlink" title="汉明码基本原理"></a>汉明码基本原理</h2><p>汉明码能用很少的纠错码对大量的数据进行错误的查找和纠正，以16bit数据为例：<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210101926363.png" alt="16bit数据|200"><br>其中，4位数据为纠错码，11位数据为有效数据(第0位为全局的奇偶校验位)，这就是所说的（15,11）汉明码。</p><p><strong>1号纠错码</strong>用来对<strong>2、4列</strong>的数据进行奇偶校验：<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210101943671.png" alt="1号纠错码|200"><br><strong>2号纠错码</strong>用来对<strong>3、4列</strong>的数据进行奇偶校验：<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210101946937.png" alt="2号纠错码|200"><br><strong>4号纠错码</strong>用来对<strong>2、4行</strong>的数据进行奇偶校验：<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210101949763.png" alt="4号纠错码|200"><br><strong>8号纠错码</strong>用来对<strong>3、4行</strong>的数据进行奇偶校验：<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210101951310.png" alt="8号纠错码|200"></p><p>汉明码基本纠错原理如下所示：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iframe</span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>50%<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100%<span class="token punctuation">"</span></span><span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210102009260.mp4<span class="token punctuation">"</span></span><span class="token attr-name">allowfullscreen</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>iframe</span><span class="token punctuation">></span></span></code></pre><p>对于第0位数据，它是不在四位纠错码的纠错范围内的，它的错误与否不会影响奇偶校验的结果。同样，让第0位数据不存储原始数据，作为对全局的奇偶校验码。这样的好处是能够规避掉0号位无法保护的问题，又能检验出全局是否存在数据错误(只存在一个错误的前提下)。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210102014166.png" alt="第0位数据|200"></p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>数据中有一个bit发生翻转，找出错误位置<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210102020115.png" alt="例子|200"><br>答案为：<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210102021404.png" alt="答案|200"></p><h2 id="多个数据发生错误的情况"><a href="#多个数据发生错误的情况" class="headerlink" title="多个数据发生错误的情况"></a>多个数据发生错误的情况</h2><p>假设16bit数据中有两个bit发生翻转,<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210102027912.png" alt="2bit翻转|500"><br>可通过汉明码基本原理找到错误的bit位为第10位<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210102030354.png" alt="错误bit位|200"><br>但是，分析第0位又得知，全部共有偶数个“1”，说明全局没有数据错误。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210102032795.png" alt="|200"><br>二者结论相矛盾，说明发生了两个错误。虽然没有办法定位错误数据的位置，但知道发生了2个数据错误的情况，可重新传输数据。<br>当存在3个数据错误时，汉明码无法解决。但是同时出现3个错误的向能性非常低，我们要考虑的应该是降低错误的发生概率，避免不要出现3个错误的情况。<strong>纠错码存在的意义是用尽可能少的数据去解决不回避免的错误。</strong></p><h2 id="汉明码的位置"><a href="#汉明码的位置" class="headerlink" title="汉明码的位置"></a>汉明码的位置</h2><p>汉明码本质上和二分法原理接近，所以校验位正好是在数据的一半。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210121426624.png"><br>如果传输更多数据，只需要在每个2的第n次方上放置一位纠错码。而<strong>每多一位校验码，数据块大小就能翻倍</strong>，校验码占比就更小，换言之，信息率越高。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210121445923.gif"><br>当然，数据越多时，出现两个或者更多错误的可能性也越大，汉明码便无法处理，所以实际操作时需要使用一个合适的数据块大小。随着纠错码的发展，这样的问题可以采用更先进的代码解决。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210121432072.png"></p><h1 id="汉明码的硬件实现"><a href="#汉明码的硬件实现" class="headerlink" title="汉明码的硬件实现"></a>汉明码的硬件实现</h1><p>汉明码的广泛应用不只是因为其能以较少的纠错码去检验较多数据位，还因为汉明码的硬件实现简单。<br>将上述16bit数据的位置角标改为对应进制数，可以发现：</p><hr><p>1号纠错码的检验区域中（1号区域），所有位置角标的第1位数都是1，区域外其余角标第1位数均为0；<br>2号纠错码的检验区域中（2号区域），所有位置角标的第2位数都是1，区域外其余角标第2位数均为0；<br>4号纠错码的检验区域中（3号区域），所有位置角标的第3位数都是1，区域外其余角标第3位数均为0；<br>8号纠错码的检验区域中（4号区域），所有位置角标的第4位数都是1，区域外其余角标第4位数均为0；</p><hr><p>把所有包含1的位置数字全部提取出来，从上到下排列，可以发现，i（i = 1,2,3,4）号区域中的“1”在排列数字第 i 号位上为1，而其他区域的数据在这一位上刚好是0。这一列数即告诉了我们一号区域里有2个1，第2列数告诉了我们2号区域有4个1，第3列数告诉了我们3号区域有4个1，第4列数告诉我们4号区域也有4个1。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210102101266.png" alt="|500"><br>将每一列数的“0”和“1”六个数依次进行异或运算，如果1和0的个数是偶数，异或运算结果为0。由于四个区域的1的个数都是偶数。所以最终的结果就是0000。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210102114175.png" alt="XOR运算|500"><br>而这时候如果有任意一位0比特翻转成了1，这个数的角标就会直接穿插在6个数中间，相当于用0000去和它异或，结果会直接变成错误的数据位。我们一下就能找到是哪个数据发生了错误。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210102118936.png" alt="|400"></p><p>如果某个1变成0，这6个数会少一个，其实和增加一位是一样的，根据异或的性质，结果仍是错误的数据位。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210102120788.png" alt="|400"><br>所以，汉明码的纠错不需要一步一步地演算推理，只需要提取出所有1的位置，把它们的位置全部按照按顺序做一次异或运算，就可以直接定位错误的位置并更正。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210102126979.png" alt="汉明码纠错步骤"></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://www.bilibili.com/video/BV1GF411V7sC/?spm_id_from=333.999.0.0">【硬件科普】ECC内存是如何发现错误并纠正的？_哔哩哔哩_bilibili</a><br><a href="https://www.bilibili.com/video/BV1WK411N7kz/?spm_id_from=333.999.0.0">【官方双语】汉明码Pa■t1，如何克服噪■_哔哩哔哩_bilibili</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;ECC 是“&lt;strong&gt;Error Correcting Code&lt;/strong&gt;”的简写，中文名称是“&lt;strong&gt;错误检查和纠正</summary>
      
    
    
    
    <category term="数字IC" scheme="https://www.daipeihong.top/categories/%E6%95%B0%E5%AD%97IC/"/>
    
    
    <category term="车规芯片" scheme="https://www.daipeihong.top/tags/%E8%BD%A6%E8%A7%84%E8%8A%AF%E7%89%87/"/>
    
    <category term="ECC算法" scheme="https://www.daipeihong.top/tags/ECC%E7%AE%97%E6%B3%95/"/>
    
    <category term="汉明码" scheme="https://www.daipeihong.top/tags/%E6%B1%89%E6%98%8E%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>SystemVerilog学习笔记(五)</title>
    <link href="https://www.daipeihong.top/2022/10/07/systemverilog-xue-xi-bi-ji-wu/"/>
    <id>https://www.daipeihong.top/2022/10/07/systemverilog-xue-xi-bi-ji-wu/</id>
    <published>2022-10-07T12:53:00.000Z</published>
    <updated>2022-10-23T07:55:03.196Z</updated>
    
    <content type="html"><![CDATA[<h1 id="组合-x2F-非组合型"><a href="#组合-x2F-非组合型" class="headerlink" title="组合/非组合型"></a>组合/非组合型</h1><h2 id="非组合型-unpacked"><a href="#非组合型-unpacked" class="headerlink" title="非组合型(unpacked)"></a>非组合型(unpacked)</h2><p>数组中的成员之间存储数据都是互相独立的。如<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210081324489.png"><br>SV保留了非组合型的数组声明方式，并且扩展了允许的类型，包括event,logic,bit,byte, int, longint, shortreal和real类型。<br>数组的索引</p><pre class=" language-systemverilog"><code class="language-systemverilog">int a1 [7:0][1023:0];//unpacked arrayint a2 [1:8][1:1024]; //unpacked arraya2 = a1; //copy an entire arraya2[3] = a1[0] ; // copy a slice of an array , a2[3]=a2[3] [1024] </code></pre><p>数组的声明的两种方式</p><pre class=" language-systemverilog"><code class="language-systemverilog">logic [31:0] data [1024];logic [31:0]data [0: 1023];//可看做一维数组，数组每个单元为32位logic类型。同样也可看作一个二维数组，每个元素是一位</code></pre><h2 id="组合型-packed"><a href="#组合型-packed" class="headerlink" title="组合型(packed)"></a>组合型(packed)</h2><p>组合型(packed)除了可以运用的数组声明，也可以用来定义结构体的存储方式:</p><pre class=" language-systemverilog"><code class="language-systemverilog">typedef struct packed {logic [ 7:0]crc;1ogic [63:0]data ;//此处两个数字为连续存放}data _word;data word [7:0]darray; // 1-D packed array of//packed structures</code></pre><p>组合型数组和其数组片段也可以灵活选择，用来拷贝和赋值等组</p><pre class=" language-systemverilog"><code class="language-systemverilog">logic [3:0][7:0]data; //2-D packed arraywire [31:0] out = data;//whole arraywire sign = data[3][7]; //bit-selectwire [3:0] nib = data [01][3:0]; //part-selectbyte high byte;assign high byte = data[31] ; //8-bit slicelogic [15:0] word;assign word = data[1:0]; // 2slices</code></pre><p>四值逻辑数组存放空间较二值逻辑数组所需空间翻倍</p><h2 id="差别"><a href="#差别" class="headerlink" title="差别"></a>差别</h2><p>组合型数组的维度声明在数组名左边，高位同样在左，低维在右</p><h2 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h2><p>组合型(packed)数组初始化时，同向量初始化一致:<br>非组合型(unpacked)数组初始化时，则需要通过’{来对数组的每一个维度进行赋值。</p><pre class=" language-systemverilog"><code class="language-systemverilog">int d [0:1][0:3] = '{ ' { 7,3,0,5}, '{2,0,1,6} };//d[0][01 = 7//d[0][1] = 3//d[0][2] = 0//d[0][3] = 5//d[1][0] = 2 //d[1][1] = 0//d[1][2] = 1//d[1][3] = 6</code></pre><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p>非组合型数组在初始化时，也可以类似结构体初始化，通过′{}和default关键词即可以完成<br>非组合型数组的数据成员或者数组本身均可以为其赋值<br>赋值方法</p><h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2><h3 id="组合型与组合型"><a href="#组合型与组合型" class="headerlink" title="组合型与组合型"></a>组合型与组合型</h3><p>对于组合型数组，由于数组会被视为向量，因此当赋值左右两侧操作数的大小和维度不相同时，也可以做赋值。<br>如果当尺寸不相同时，则会通过截取或者扩展右侧操作数的方式来对左侧操作数赋值。</p><pre class=" language-systemverilog"><code class="language-systemverilog">bit [1:0][15:0]a; //32 bit 2-state vectorlogic [3:0][7:0] b; //32 bit 4-state vector    logic [15:0] c; //16 bit 4-state vectorlogic [39:0] d; //40 bit 4-state vectorb = a; //assign 32-bit array to 32-bit arrayc = a; //upper 16 bits will be truncated，高16位将被舍去d = a; //upper 8 bits wil1 be zero filled，高八位将被赋0</code></pre><h3 id="非组合型与非组合型"><a href="#非组合型与非组合型" class="headerlink" title="非组合型与非组合型"></a>非组合型与非组合型</h3><p>对于非组合型数组，在发生数组间拷贝时，则要求做左右两侧操作数的维度和大小必须严格一致。</p><pre class=" language-systemverilog"><code class="language-systemverilog">logic [31:0] a [2:0][9:0];logic [O: 31] b [1:3][1:10];a = b; //assign unpacked array to unpacked array</code></pre><h3 id="组合型与非组合型"><a href="#组合型与非组合型" class="headerlink" title="组合型与非组合型"></a>组合型与非组合型</h3><p>非组合型数组无法直接赋值给组合型数组，同样地，组合型数组也无法直接赋值给非组合型数组。</p><h2 id="数组的索引——foreach循环结构"><a href="#数组的索引——foreach循环结构" class="headerlink" title="数组的索引——foreach循环结构"></a>数组的索引——foreach循环结构</h2><p>SV添加foreach循环来对一维或者多维数组进行循环索引，<br>而不<br>需要指定该数组的维度大小。</p><pre class=" language-systemverilog"><code class="language-systemverilog">int sum [1:8][1:3];foreach ( sum[i,j])sum[i][j] = i +j; //initialize array</code></pre><p>foreach循环结构中的变量<strong>无需声明</strong>。<br>foreach循环结构中的变量是只读的，其<strong>作用域只在此循环结构中</strong>。</p><h1 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h1><h2 id="声明方式"><a href="#声明方式" class="headerlink" title="声明方式"></a>声明方式</h2><p>动态数组在声明时需要使用[]，这表示不会在编译时为其制定尺寸，而是在仿真运行时来确定。<br>动态数组一开始为空，而需要使用new[]来为其分配空间</p><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210081344286.png"></p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="声明方式-1"><a href="#声明方式-1" class="headerlink" title="声明方式"></a>声明方式</h2><p>通过[$]来声明队列，队列的索引值从0到$。</p><h2 id="使用实例-1"><a href="#使用实例-1" class="headerlink" title="使用实例"></a>使用实例</h2><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210081344016.png"></p><hr><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210081349124.png"></p><h1 id="关联数组"><a href="#关联数组" class="headerlink" title="关联数组"></a>关联数组</h1><p>SV引入了关联数组，可以用来存放散列的数据成员。散列的索引类型除了为整形以外还可以为字符串或者其它类型，而散列存储的数据成员也可以为任意类型。</p><h2 id="使用实例-2"><a href="#使用实例-2" class="headerlink" title="使用实例"></a>使用实例</h2><pre class=" language-systemverilog"><code class="language-systemverilog">module&nbsp;tb;  &nbsp;&nbsp;initial&nbsp;begin  &nbsp;&nbsp;bit&nbsp;[31:0]&nbsp;mem&nbsp;[int&nbsp;unsigned];  &nbsp;&nbsp;int&nbsp;unsigned&nbsp;data,&nbsp;addr;  &nbsp;&nbsp;repeat(5)begin  &nbsp;&nbsp;&nbsp;&nbsp;std::randomize(addr,data)&nbsp;with&nbsp;{addr[31:8]&nbsp;==&nbsp;0;&nbsp;addr[1:0]&nbsp;==&nbsp;0;&nbsp;data&nbsp;inside&nbsp;{[1:10]};&nbsp;};  &nbsp;&nbsp;&nbsp;&nbsp;$display("address&nbsp;:&nbsp;'h%0x,&nbsp;data&nbsp;:&nbsp;'h%0x",&nbsp;addr,&nbsp;data);  &nbsp;&nbsp;&nbsp;&nbsp;mem[addr]&nbsp;=&nbsp;data;  &nbsp;&nbsp;&nbsp;&nbsp;foreach(mem[idx])  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$display("mem&nbsp;adress&nbsp;:&nbsp;'h'%0x,&nbsp;data&nbsp;:&nbsp;'h%0x",&nbsp;idx,&nbsp;mem[idx]);  &nbsp;&nbsp;end  end  endmodule</code></pre><p>仿真结果：<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210081533507.png"><br>从结果可看出，index并不连续<br>对于结果的打印，同样可采用如下方法：</p><pre class=" language-systemverilog"><code class="language-systemverilog">&nbsp;&nbsp;&nbsp;&nbsp;if(mem.first(addr))begin  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$display("foreach_loop&nbsp;mem&nbsp;address&nbsp;:&nbsp;'h%0x&nbsp;data&nbsp;:&nbsp;'h%0x",addr,mem[addr]);  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(mem.next(addr)); //如果还能继续索引到地址值，继续循环 &nbsp;&nbsp;&nbsp;&nbsp;end</code></pre><p>仿真结果<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210081536016.png"><br>此外，在索引时，索引地址不连续，可增加判断索引地址是否存在</p><pre class=" language-systemverilog"><code class="language-systemverilog">&nbsp;&nbsp;if&nbsp;(mem.exists('h10))  &nbsp;&nbsp;&nbsp;&nbsp;$display("ACCESS&nbsp;mem&nbsp;address&nbsp;:&nbsp;'h%0x,&nbsp;data&nbsp;:&nbsp;'h%0x",&nbsp;'h10,&nbsp;mem['h10]);  &nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$display("ACCESS&nbsp;mem&nbsp;address&nbsp;:&nbsp;'h%0x&nbsp;is&nbsp;illegal&nbsp;adress",&nbsp;'h10);</code></pre><p>仿真结果：<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210081539044.png"></p><h1 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h1><h2 id="数组缩减"><a href="#数组缩减" class="headerlink" title="数组缩减"></a>数组缩减</h2><p>基本的数组缩减方法是把一个数组缩减成一个值。<br>最常用的缩减方法是sum，它对数组中的所有元素求和。</p><pre class=" language-systemverilog"><code class="language-systemverilog">byte b[$] = {2，3，4，5};int W;w = b.sum();  // 14=2+3+4+5w = b.product(); // 120 = 2 *3*4*5W = b.and();  // 0000 0000 = 2&3&4& 5</code></pre><p>其它的数组缩减方法还有product(积), and(与), or(或)和xor(异或)。</p><h2 id="数组定位"><a href="#数组定位" class="headerlink" title="数组定位"></a>数组定位</h2><p>对于非合并数组，可以使用数组定位方法，其返回值将是一个队<br>列而非一个数据成员。</p><pre class=" language-systemverilog"><code class="language-systemverilog">int f[6] = '{1,6,2,6,8,6};  // Fixed-size arrayint d[] = '{2,4,6,8,10};  // Dynamic arrayint q[$] = {1,3,5,7}，  // Queue ;tq[$] ;  // Temporary queue for resulttq = q.min();  // {1}tq = d.max();  // {10}tq = f.unique(); // {1,6,2,8} </code></pre><p>使用foreach也可以实现数组的搜索,不过使用find…with则在查找满足条件的数据成员时，更为方便。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210081547317.png"></p><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><p>可以通过排序方法改变数组中元素的顺序，可以对它们进行正向、逆向或者乱序的排列。</p><pre class=" language-systemverilog"><code class="language-systemverilog">int a [] =       {9,1,8,3,4,4};d. reverse();  //{4,4,3,8,1,9}d.sort();      //{1,3,4,4,8,9}d.rsort();     //{9,8,4,4,3,1}d.shuffle();   //{9,4,3,8,1,4}</code></pre><p><strong>问答题</strong></p><ul><li><strong>链表和SV中的哪些数组类型(定长数组、动态数组、队列、关联数组)相似，相似的特性有哪些?</strong><br>链表数据在实际存储时，所在的内存地址并不连续，数据随机分布在内存中的各个位置，这种存储结构成为练市存储。链式存储生成的表成为链表。但为了能够保持数据元素之间的顺序关系，每个数据元素在存储的同时，都要配备一个指针，指向它的直接后继元素，每一个数据元素都指向下一个数据元素，这些由指针相互连接的数据，就具有了线性的关联。</li></ul><p>删除链表的元素只需要把前节点的指针域，越过要删除的节点直接指向下一个节点，然后释放被删除节点的空间。若不释放，被删节点成为野指针，造成内存泄露。<br>添加链表的元素时需要先确定要添加的位置，然后把前节点的指针域指向自身，再将自身的指针域指向下一个节点即可。</p><p>链表与数组的区别(C语言)：<br> <strong>应用场景方面</strong>：数组必须事先定义长度(元素个数)，并分配固定大小的空间，不能适应数据动态增减的情况，不能适应数据动态增减的情况。相反，链表可以动态地进行内存分配，可以适应数据动态增减的情况，且可以方便地插入、删除数据项。<br><strong>内存方面</strong>：数组从栈中分配空间，所有关于内存的申请开辟或者析构释放都由系统完成，方便快速，但是自由度小。链表从堆中分配空间，用多少，就开辟多少内存，自由度大，内存的申请管理较麻烦。<br><strong>操作效率方面</strong>：在插入或者删除数组中的元素时，其后的所有元素都要被移动。而在链表中插入或者删除某节点时，只需修改指针即可，不需要移动节点。 因此插入删除元素，链表的效率由于数组。但在访问效率方面，由于数组的内存是连续的，则可以直接使用下标访问数组电的某个元素。链表的内存是不连续的，要访问链表中的某个节点，必须从头节点开始查找。因此，链表的访问效率不如数组。</p><p>回到SystemVerilog，<strong>链表在增删元素操作上与队列相似</strong>，可以在数据中任何地方添加或者删除元素。(但值得注意的是，队列同时又具有数组的优点，可以通过索引实现对任一元素的访问，这一点优于链表。) <strong>链表在动态分配内存上同动态数组类似</strong>链表能够动态地进行内存分配，这一点同动态数组类似。使用动态数组可以在仿真时分配空间或调整宽度。动态数组在声明时使用空的下标[]，数组的宽度不在编译时给出，而在程序运行时再指定，调用new[]操作符来分配空间，同时在方括号中传递数组宽度。<br><strong>SystemVerilog虽然提供了链表数据结构，但是应该避免使用它，因为SystemVerilog提供的队列更加高效易用。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;组合-x2F-非组合型&quot;&gt;&lt;a href=&quot;#组合-x2F-非组合型&quot; class=&quot;headerlink&quot; title=&quot;组合/非组合型&quot;&gt;&lt;/a&gt;组合/非组合型&lt;/h1&gt;&lt;h2 id=&quot;非组合型-unpacked&quot;&gt;&lt;a href=&quot;#非组合型-unpacke</summary>
      
    
    
    
    <category term="数字IC" scheme="https://www.daipeihong.top/categories/%E6%95%B0%E5%AD%97IC/"/>
    
    
    <category term="数字前端" scheme="https://www.daipeihong.top/tags/%E6%95%B0%E5%AD%97%E5%89%8D%E7%AB%AF/"/>
    
    <category term="SystemVerilog验证" scheme="https://www.daipeihong.top/tags/SystemVerilog%E9%AA%8C%E8%AF%81/"/>
    
    <category term="数组队列" scheme="https://www.daipeihong.top/tags/%E6%95%B0%E7%BB%84%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>SystemVerilog课程笔记(四)</title>
    <link href="https://www.daipeihong.top/2022/10/04/systemverilog-ke-cheng-bi-ji-si/"/>
    <id>https://www.daipeihong.top/2022/10/04/systemverilog-ke-cheng-bi-ji-si/</id>
    <published>2022-10-04T14:12:00.000Z</published>
    <updated>2022-10-23T08:05:09.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="将initial过程快改造为task"><a href="#将initial过程快改造为task" class="headerlink" title="将initial过程快改造为task"></a>将initial过程快改造为task</h1><h1 id="向chnl5发送数据"><a href="#向chnl5发送数据" class="headerlink" title="向chnl5发送数据"></a>向chnl5发送数据</h1><h1 id="自定义输出数据端口"><a href="#自定义输出数据端口" class="headerlink" title="自定义输出数据端口"></a>自定义输出数据端口</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;将initial过程快改造为task&quot;&gt;&lt;a href=&quot;#将initial过程快改造为task&quot; class=&quot;headerlink&quot; title=&quot;将initial过程快改造为task&quot;&gt;&lt;/a&gt;将initial过程快改造为task&lt;/h1&gt;&lt;h1 id=&quot;向</summary>
      
    
    
    
    <category term="数字IC" scheme="https://www.daipeihong.top/categories/%E6%95%B0%E5%AD%97IC/"/>
    
    
    <category term="数字前端" scheme="https://www.daipeihong.top/tags/%E6%95%B0%E5%AD%97%E5%89%8D%E7%AB%AF/"/>
    
    <category term="SystemVerilog验证" scheme="https://www.daipeihong.top/tags/SystemVerilog%E9%AA%8C%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>SystemVerilog课程笔记(三)</title>
    <link href="https://www.daipeihong.top/2022/10/04/systemverilog-ke-cheng-bi-ji-san/"/>
    <id>https://www.daipeihong.top/2022/10/04/systemverilog-ke-cheng-bi-ji-san/</id>
    <published>2022-10-04T14:05:00.000Z</published>
    <updated>2022-10-23T08:04:25.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DUT——router功能概述"><a href="#DUT——router功能概述" class="headerlink" title="DUT——router功能概述"></a>DUT——router功能概述</h1><h2 id="管脚图"><a href="#管脚图" class="headerlink" title="管脚图"></a>管脚图</h2><p>以router（路由器）为例<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210041439616.png"></p><h2 id="输入输出信号"><a href="#输入输出信号" class="headerlink" title="输入输出信号"></a>输入输出信号</h2><p><strong>左边</strong>是输入：16位的din（数据输入）、16位的frame_n（数据帧有效，低电平有效）、16位的valid_n（有效信号，低电平有效）、reset_n（低电平复位）和clock（时钟）<br><strong>右边</strong>是输出：16位的dout（数据输出）、16位的dout（数据输出）、16位的frameo_n（数据帧输出有效）、16位的valido_n（输出有效信号，低电平有效）</p><h2 id="模块功能"><a href="#模块功能" class="headerlink" title="模块功能"></a>模块功能</h2><p>16个输入的通道，选一个通道作为输入通道，同样的，16个输出的通道，也是选一个通道作为输出通道，数据是一bit一bit地传输。<br>例如，选择din[7]为数据的输入通道，所以frame_n[7]和valid_n[7]就是控制信号；选择dout[3]为数据的输出通道，所以frameo_n[3]和valido_n[3]就是控制信号。因此数据会从7号输入通道输入，然后从3号通道输出，路由器的功能就是这么简单。</p><h2 id="输入信号协议"><a href="#输入信号协议" class="headerlink" title="输入信号协议"></a>输入信号协议</h2><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210041525871.png"><br> <strong>din信号</strong><br>1.din[i]中的i表示从哪路输入，<strong>din中的第一段4bit的数据表示输出地址（低位开始）</strong>，从哪路输出<br>2.地址传输完毕后拉高进入隔离段<br>3.隔离段结束后开始传输数据（低位开始）<br><strong>frame_n信号</strong><br>1.下降沿指示packet的第一位数据<br>2.上升沿指示packet的最后一位数据<br><strong>valid_n信号</strong><br>1.其在din的地址输入时间段可为任意值x<br>2.在隔离段pad拉高<br>3.其拉低时表示数据有效，因此在payload段若其拉高，则din数据无效<br>4.数据输入完毕后拉高</p><h2 id="输出信号协议"><a href="#输出信号协议" class="headerlink" title="输出信号协议"></a>输出信号协议</h2><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210041531905.png"><br>输出信号时序图如上，比较简单，当valido_n和frameo_n均为低时数据有效，除了packet最后一位输出数据时frameo_n为高&nbsp;。</p><h2 id="复位信号协议"><a href="#复位信号协议" class="headerlink" title="复位信号协议"></a>复位信号协议</h2><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210041534779.png"><br>以上为其复位协议时序图，有以下几点需要注意：<br>1.复位时，reset_n为低电平,frame_n和valid_n为高电平<br>2.有效复位<strong>至少保持1个clk</strong><br>3.复位后<strong>至少等待15个时钟</strong>周期后才可以发送数据</p><h1 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h1><pre class=" language-systemverilog"><code class="language-systemverilog">//***********************module tb*******************////***********************module tb*******************//module tb;bit clk,rstn;logic [15:0] din, frame_n, valid_n;logic [15:0] dout, valido_n, busy_n, frameo_n;// generate clockinitial     forever #5ns clk <= !clk;// genarate reset  initial begin    #2ns rstn <= 1;    #10ns rstn <= 0;    #10ns rstn <= 1;  end// exemplification//Dutrouter dut(             .reset_n(rstn),  .clock(clk),  .*  //The port name is the same as the variable name);//Stimulatorrt_stimulator stim(  .reset_n(rstn),  .clock(clk),  .*);endmodule//***********************module rt_stimulator*******************////数据从0传到3端口module rt_stimulator(  input clock  ,input reset_n  ,output logic [15:0] din  ,output logic [15:0] frame_n  ,output logic [15:0] valid_n  ,input [15:0] dout  ,input [15:0] valido_n  ,input [15:0] busy_n  ,input [15:0] frameo_n);//for debug purpose from waveform  typedef enum {DRV_RESET,DRV_IDLE,DRV_ADDR,DRV_PAD,DRV_DATA} drv_state_t;  drv_state_t dbg_state;  //定义检测状态的变量  byte unsigned dbg_din_chnl0_data;  //reset阶段，复位时，reset_n为低电平,frame_n和valid_n为高电平initial begin : drive_reset_proc  @(negedge reset_n);  din <= 0;  frame_n <= 1;  valid_n <= 1;end// drive chaannel 0 - chanel 15 (din[15:0])//定义数据输出地址及数据bit [3:0] addr;byte unsigned data[];initial begin : drive_chnl0_proc  @(negedge reset_n);  repeat(10) @(posedge clock);  addr = 3;//从第3位输出  data = '{8'h33,8'h77};//数据，8'h33,8'h77// drive address phase 输入地址位阶段for(int i=0;i<4;i++)begin  //4 clock  @(posedge clock);  dbg_state <=DRV_ADDR;  din[0] <= addr[i];  valid_n[0] <= 1'b0;  //valid_n[0] <= $urandom_range(0,1);//valid_n在din的地址输入时间段可为任意值x  frame_n[0] <= 1'b0;//frame_n需要为低end// drive pad phase //隔离阶段  for (int i=0;i<5;i++)begin  //5 clock    @(posedge clock);    dbg_state <=DRV_PAD;    din[0] <= 1'b1;    valid_n[0] <= 1'b1;//valid_n需为高电平    frame_n[0] <= 1'b0; //frame_n需为低电平  end// drive data phase 传输数据阶段  foreach(data[id])begin    for(int i=0;i<8;i++)begin     @(posedge clock);      dbg_state <=DRV_DATA;      dbg_din_chnl0_data <= data[id];      din[0] <= data[id][i];      valid_n[0] <=1'b0;      frame_n <= (id == data.size()-1 && i == 7) ? 1'b1 : 1'b0;//packet最后一位输出数据时frameo_n为高    end  end// drive idle phase 闲置（没有数据传输）阶段  @(posedge clock);  dbg_state <=DRV_IDLE;  dbg_din_chnl0_data <= 0;  din[0] <= 1'b0;  valid_n[0] <= 1'b1;  frame_n <= 1'b1;endendmodule</code></pre><h1 id="仿真结果"><a href="#仿真结果" class="headerlink" title="仿真结果"></a>仿真结果</h1><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210042153244.png"></p><p>另，关于vim编辑器<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210042205029.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;DUT——router功能概述&quot;&gt;&lt;a href=&quot;#DUT——router功能概述&quot; class=&quot;headerlink&quot; title=&quot;DUT——router功能概述&quot;&gt;&lt;/a&gt;DUT——router功能概述&lt;/h1&gt;&lt;h2 id=&quot;管脚图&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="数字IC" scheme="https://www.daipeihong.top/categories/%E6%95%B0%E5%AD%97IC/"/>
    
    
    <category term="数字前端" scheme="https://www.daipeihong.top/tags/%E6%95%B0%E5%AD%97%E5%89%8D%E7%AB%AF/"/>
    
    <category term="SystemVerilog验证" scheme="https://www.daipeihong.top/tags/SystemVerilog%E9%AA%8C%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>色彩美学(一)_色彩理论基础</title>
    <link href="https://www.daipeihong.top/2022/10/03/se-cai-mei-xue-yi-se-cai-li-lun-ji-chu/"/>
    <id>https://www.daipeihong.top/2022/10/03/se-cai-mei-xue-yi-se-cai-li-lun-ji-chu/</id>
    <published>2022-10-03T08:39:00.000Z</published>
    <updated>2022-10-03T08:42:57.559Z</updated>
    
    <content type="html"><![CDATA[<h1 id="色彩基础知识"><a href="#色彩基础知识" class="headerlink" title="色彩基础知识"></a>色彩基础知识</h1><h2 id="主色"><a href="#主色" class="headerlink" title="主色"></a>主色</h2><p>主色顾名思义即主要色彩，一幅作品的主色代表者作品的主题，往往最直接影响作品给人的感官感受。主色可以通过一下方式区分：<br><strong>1.整个画面中，面积大，且纯度高的色彩，这个就是主色。</strong><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210031259383.png"><br>图中红色就是主色，若换成蓝色，传达的就是商务严肃感，而不是略带危险刺激的感受了。</p><p><strong>2.整个画面中，相比面积大，但纯度低或者明度低的色彩，虽然面积稍小，但画面中你一眼就看到的色彩，就是主色。</strong><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210031300552.png"><br>画面中灰绿色面积虽然大，但因为黄色的巴士纯度更高，更夺人眼球，所以整幅作品中，黄色是主色。</p><p><strong>3.主色也存在双主色的情况。两种色彩面积是等量的，可以给人留下深刻的印象。双主色的搭配，往往显得更具有个性。</strong><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210031300689.png"><br>图中蓝灰色和红色的面积是等量的，是双主色搭配，去掉任何一种颜色画面效果都会打折扣。</p><h2 id="辅色"><a href="#辅色" class="headerlink" title="辅色"></a>辅色</h2><p>辅助色的目的是配合主色使主题形象更加完整，那么如何配合主色进行搭配呢?<br>1.<strong>同类色</strong>：辅助色选择主色的同类色，可达成画面统一和谐。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210031304192.png"><br>主色是中间的红色，辅助色是橙色，橙色的运用使红色更为突出，典型的同类色辅助色，也可以叫做背景色辅助色，整个画面显得极为和谐。</p><p>2.<strong>对比色</strong>：选择主色对比色，画面刺激、活泼，也很稳定。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210031307670.png"></p><h2 id="点缀色"><a href="#点缀色" class="headerlink" title="点缀色"></a>点缀色</h2><p>颜色面积最小，出现次数多，与别的颜色反差大，具有引导视线作用，影响主色作用小，只是提醒人们注意。<br><strong>点缀色特点</strong><br><strong>(1)颜色跳跃</strong><br><strong>(2)引起阅读性</strong><br><strong>(3)与其他颜色反差较大</strong><br><img src="https://pic1.zhimg.com/80/v2-5d2205f462305db5b18255d46f8a1044_720w.webp"></p><p>这幅作品中的点缀色是多个颜色，颜色跳跃，形成自有的风格，同时引导大家阅读下方的文字。</p><h2 id="色轮"><a href="#色轮" class="headerlink" title="色轮"></a>色轮</h2><p>红+黄色＝橙，黄+蓝＝绿，蓝+红＝紫，如果我们将这些颜色混合在一起，我们可以得到更多颜色，如黄绿色和橙红色，总之，它们形成了所谓的色轮。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210031315701.png"></p><h1 id="色彩三要素"><a href="#色彩三要素" class="headerlink" title="色彩三要素"></a>色彩三要素</h1><h2 id="色相-Hue"><a href="#色相-Hue" class="headerlink" title="色相(Hue)"></a>色相(Hue)</h2><p>是指<strong>色彩的相貌</strong>，色相被用来区分颜色，根据光的不同波长，色彩具有红色、黄色或绿色等性质，这被称之为色相。</p><h2 id="明度-Value"><a href="#明度-Value" class="headerlink" title="明度(Value)"></a>明度(Value)</h2><p>是色彩<strong>从亮到暗的明暗程度</strong>，黑色的绝对明度被定义为 0 （理想黑）,而白色的绝对明度被定义为 100 （理想白），其他系列灰色则介于两者之间。</p><h2 id="纯度-Saturation"><a href="#纯度-Saturation" class="headerlink" title="纯度(Saturation)"></a>纯度(Saturation)</h2><p>纯度通常是指色彩的<strong>鲜艳度</strong>。从科学的角度看，一种颜色的鲜艳度取决于这一色相发射光的单一程度。色彩的纯度强弱，是指色相感觉明确或含糊、鲜艳或混浊的程度。<br><img src="https://mmbiz.qpic.cn/mmbiz_png/G1micJgRNZtbYDOViadyuC0hwdkSDFKWJbciaCyWlspL3ucXzpibfQJv6lndHzajKr4FYaqicBW3IXgibYaR9Ogl99FQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"></p><h1 id="色彩空间"><a href="#色彩空间" class="headerlink" title="色彩空间"></a>色彩空间</h1><h2 id="HSB"><a href="#HSB" class="headerlink" title="HSB"></a>HSB</h2><p>在 HSB 模式中，H（Hues）表示色相，S（Saturation）表示饱和度，B（Brightness）表示亮度。</p><h2 id="RGB"><a href="#RGB" class="headerlink" title="RGB"></a>RGB</h2><p>三原色红、绿、蓝叠加最终为白色（加色模式）。常用于光源光情况下，例如显示屏幕。</p><h2 id="CMYK"><a href="#CMYK" class="headerlink" title="CMYK"></a>CMYK</h2><p>三基色洋红、黄、青叠加最终为黑色（减色模式）。常用于反射光情况下，例如印刷。</p><h2 id="LAB"><a href="#LAB" class="headerlink" title="LAB"></a>LAB</h2><p>LAB 色彩模型是由亮度（L）和有关色彩的 A，B 三个要素组成。L 表示亮度（Luminosity），A 表示从洋红色至绿色的范围，B表示从黄色至蓝色的范围。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/G1micJgRNZtbYDOViadyuC0hwdkSDFKWJb0qnt8icKpDa7O9b3tXV7KpicFImobmcp0C8HibzBUIKA9miaGoDuOvKicbg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"></p><h1 id="色彩象征"><a href="#色彩象征" class="headerlink" title="色彩象征"></a>色彩象征</h1><p><strong>1）灰⾊</strong>：正式、重⼒、成熟</p><p><strong>2）棕⾊</strong>：保守、亲切、稳定</p><p><strong>3）粉⾊</strong>：⼥性、天真、⻘春</p><p><strong>4）⻩⾊</strong>：注意、提醒、快乐</p><p><strong>5）紫⾊</strong>：奢华、浪漫、创意<br>是一种充满神秘的颜色，在自然界中较少见到，所以被引申为象征高贵的色彩。在UI设计中的应用场景为紫+粉常用于女性化的产品调性。</p><p><strong>6）⽩⾊</strong>：新鲜、清洁、健康<br>白色常常被认为是无色”即不是色彩。在UI设计中的应用场景，常用于背景色，缓和各种颜色的冲突，以衬托其他色彩，提高画面明度，提高文字可读性。</p><p><strong>7）⿊⾊</strong>：正式、权⼒、⽼练<br>是一种充满质感的颜色，它是所有色彩中最有力量的，能很快吸引用户的注意力。在UI中的应用场景，常和其他色彩百搭，比如黑色+金色，黑色+红色等等，以及现在UI设计中的暗黑模式。</p><p><strong>8）蓝⾊</strong>：信任、舒适、放松<br>纯净的蓝色通常让人联想到海洋和天空，让人的内心感到平和，有助于人的头脑变得冷静，减少工作中的烦躁和冲动。在UI设计中应用场景，常用于工具、商务、科技类等产品，B端设计也经常运用。</p><p><strong>9）绿⾊</strong>：⽣⻓、⾃然、成功<br>绿色是大自然中最常见的颜色，代表着健康、生命、青春、宁静、自然、和平、安全、舒适，是一种充满希望的颜色。在设计中的应用场景，健康、医疗、运动及少儿类产品使用较多，一般在软件中表示安全、成功。</p><p><strong>10）橙⾊</strong>：信⼼、能量、乐观<br>它烘托出的活跃气氛没有危险的感觉，反而是一种友好。<br>在UI设计中应用场景，电商、金融以及服务类的产品使用较多，比如淘宝。</p><p><strong>11）红⾊</strong>：危险、重要、激情<br>最醒目和强势的颜色，甚至能引起一些生理反应，例如心跳呼吸加快等。在UI设计中应用场景，红色常用于电商、金融、服务等行业。红色也最能烘托气氛，在中国传统节日里都使用热闹的红色来装饰，比如新年春节阶段。同时红色也代表了警示、告诫，所以在界面设计中常用红色的文字和按钮来警示用户慎重操作。</p><h1 id="Reference："><a href="#Reference：" class="headerlink" title="Reference："></a>Reference：</h1><p><a href="https://zhuanlan.zhihu.com/p/52546255">色彩搭配入门：从区分主色、辅助色、点缀色开始！ - 知乎 (zhihu.com)</a><br><a href="https://mp.weixin.qq.com/s/tcpOwSgd-BEgqkjiWptTvQ">你一定要知道的色彩知识 (qq.com)</a></p><p>0</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;色彩基础知识&quot;&gt;&lt;a href=&quot;#色彩基础知识&quot; class=&quot;headerlink&quot; title=&quot;色彩基础知识&quot;&gt;&lt;/a&gt;色彩基础知识&lt;/h1&gt;&lt;h2 id=&quot;主色&quot;&gt;&lt;a href=&quot;#主色&quot; class=&quot;headerlink&quot; title=&quot;主色&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="猎奇" scheme="https://www.daipeihong.top/categories/%E7%8C%8E%E5%A5%87/"/>
    
    
    <category term="颜色美学" scheme="https://www.daipeihong.top/tags/%E9%A2%9C%E8%89%B2%E7%BE%8E%E5%AD%A6/"/>
    
    <category term="色彩理论" scheme="https://www.daipeihong.top/tags/%E8%89%B2%E5%BD%A9%E7%90%86%E8%AE%BA/"/>
    
    <category term="色彩空间" scheme="https://www.daipeihong.top/tags/%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>香水入门</title>
    <link href="https://www.daipeihong.top/2022/10/02/xiang-shui-ru-men/"/>
    <id>https://www.daipeihong.top/2022/10/02/xiang-shui-ru-men/</id>
    <published>2022-10-02T11:52:00.000Z</published>
    <updated>2022-10-02T13:03:44.777Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-简介"><a href="#一-简介" class="headerlink" title="(一)简介"></a>(一)简介</h1><p>香水是由80～90%的变性酒精为溶剂，加上各种香料调制而成。</p><h1 id="二-浓度规格"><a href="#二-浓度规格" class="headerlink" title="(二)浓度规格"></a>(二)浓度规格</h1><p>香水按香精浓度划分了五个等级：从低到高依次为：清淡香水、古龙水、淡香水、淡香精、浓香精。<br><strong>1.清淡香水</strong><br>香精含量为1%~3%，留香较短<br><strong>2.古龙水(EAU&nbsp;DE&nbsp;COLOGNE)</strong><br>简称EDC，香精含量很低，为2%-5%，持续时间1-2h。<br> <strong>3.淡香水(EAU&nbsp;DE&nbsp;TOILETTE)</strong><br>简称EDT，toilette为法语，是指梳洗打扮，可以理解为打扮的时候使用的香水，香水里最常见的浓度。香精含量为5%-10%，持续时间3-4h<br> <strong>4.淡香精(EAU&nbsp;DE&nbsp;PARFUME)</strong><br>简称EDP，又称浓香水、浓香氛、淡香精。香精含量为10-15%，留香时间5h左右<br><strong>5.香精/浓香精(PARFUME&nbsp;/&nbsp;EXTRAIT)</strong><br>香料含量最高的香水，及其稀少，属于收藏级香水，香精的用料和品质都是最高的。香精含量为15-25%，持续时间5-7h<br><strong>Tips:</strong><br>在一般人的印象中，古龙是指男性使用的香水，实际上是因为以前男性常用的香水多为古龙浓度。</p><h1 id="三-层次结构"><a href="#三-层次结构" class="headerlink" title="(三)层次结构"></a>(三)层次结构</h1><h2 id="前调-top-：0～10min"><a href="#前调-top-：0～10min" class="headerlink" title="前调(top)：0～10min"></a>前调(top)：0～10min</h2><p>香水刚喷出来酒精挥发以后（30S）所闻到的气味。前调的香料极易挥发，一般维持时间很短，10Min到30Min不等，同时中调和后调也会一起挥发，一起组成对一款香水的“<strong>初印象</strong>”。</p><h2 id="中调-middle-：2-4h"><a href="#中调-middle-：2-4h" class="headerlink" title="中调(middle)：2~4h"></a>中调(middle)：2~4h</h2><p>中调是一款香水的主题、核心。前调挥发后，中调开始显现。中调是一款香水的核心组成，是主调，一般会持续好几个小时</p><h2 id="尾调-x2F-基调-base-：4h以后"><a href="#尾调-x2F-基调-base-：4h以后" class="headerlink" title="尾调/基调(base)：4h以后"></a>尾调/基调(base)：4h以后</h2><p>香水的基调，也是我们所说的余香，挥发得最慢，香水挥发至快闻不到了、留在皮肤上的气味就是后调，是最贴肤的气味。一般有人夸你身上的味道很淡很好闻的时候，他们闻到的基本上是这个味道，因为后调的香味是最舒适、最能接受的。</p><h1 id="三-香水派别"><a href="#三-香水派别" class="headerlink" title="(三)香水派别"></a>(三)香水派别</h1><h2 id="商业香"><a href="#商业香" class="headerlink" title="商业香"></a>商业香</h2><p>指的是最常见的时装或美妆品牌推出的香水，像Prada、Dior、Burberry、这类品牌。它侧重考虑的是消费者的喜好，做出来香水消费者喜不喜欢、会不会买账，能不能卖得出去这些问题。</p><h2 id="沙龙香"><a href="#沙龙香" class="headerlink" title="沙龙香"></a>沙龙香</h2><p>区别于商业香的创作源头来自于市场需求，沙龙香源自于调香师艺术表达的需求。沙龙香是古法艺术的回归，是对调香师灵感的绝对尊重。比较小众。</p><h1 id="四-香调分类"><a href="#四-香调分类" class="headerlink" title="(四)香调分类"></a>(四)香调分类</h1><h2 id="芬芳"><a href="#芬芳" class="headerlink" title="芬芳"></a>芬芳</h2><p><strong>花香调</strong>：是最常见的香调，也是最早使用在香水中的香调。男香中使用较少，但男香中加入少量花香，能体现出男性的沉稳和大气。<br><strong>柑橘调</strong>：采用一些柑橘类水果为香调的香料<br><strong>果香调</strong>：果香调香料是所有非柑橘类水果，很多果香调的香水会选用热带水果、桃子、梨、苹果、草莓等水果的香气渲染香水。但能表达这类香气的原料特点是留香时间短，挥发性较强，给人的感觉是干净、清爽、舒服、通透、清新。<br>一般很少有单纯的果香调香水，大多用在香水的前调上。</p><h2 id="清新"><a href="#清新" class="headerlink" title="清新"></a>清新</h2><p><strong>绿叶调</strong>：以草本和绿叶散发出来的绿草香为主旋律，这种香调常常让人想起绿意盎然的森林、草地，属于清爽干净的香气，一般男性或中性的香水中使用表现在前调和中调上，相反女香中则不太会专门做绿叶调的香水，常常以绿叶调的清爽自然辅助其他香调，令人感觉沁人心脾、放松自然。<br><strong>水生调</strong>：闻起来的感觉通常是清新怡人的，比如海风的气味、湿润的空气、雨后清风吹进屋子时湿润的味道，清晨绿叶上的露珠等等。<br>Tips：香水小白最好刚开始不要买水生调的香水，容易晕香。晕香的相关问题我放在最后了。<br><strong>甘苔调</strong>：也就是西普调，西普调香水既有草木之清新、花果之甜美，亦有苔藓之浓郁也有雨后森林里的清新之感。它甜美、复杂而又神秘，最动人之处，在于那一点点复杂的难以驾驭感，是一种女性气息十足的香调。</p><h2 id="古典"><a href="#古典" class="headerlink" title="古典"></a>古典</h2><p><strong>木质调</strong>：常常出现在香水的中调和基调，木质调常用的有雪松、广藿香、檀香木、香根草等原料，这类原料气味温暖、干燥，留香时间长，也会常常与其他香调配合使用来表达不同的诉求。<br><strong>皮革调</strong>：为主导与烟草、木香、烟熏搭配，以男香居多，展现出男性的洒脱不羁、勇敢、阳刚、感性的特质。<br>皮革调在市面上感觉很少，它的接受度比较低。</p><h2 id="浓郁"><a href="#浓郁" class="headerlink" title="浓郁"></a>浓郁</h2><p><strong>东方调</strong>：是使用东方树木或辛香料、树脂、麝香等动物性香料制造而成，香甜浓郁的香气最能体现女性的性感妩媚。东方调香水具有温暖、辛辣、性感、诱惑、异域风情的特点。<br><strong>馥奇香调</strong>：带有明显的黑香豆和苔香香气，且伴有青翠的草木香韵。这一类型香调常用于男士香水，香气厚重浓郁，温暖而性感，给人以阳刚的男人味。<br><strong>美食调</strong>：这是近年来才开始流行的香调，运用了焦糖、巧克力、香草、蜂蜜、爆米花、棉花糖及各种水果创作的香调，美食调的香水具有独特的温暖香气，可以唤醒我们童年的美好回忆。适合青春无敌的小女孩，也适合童心未泯的女性。</p><h1 id="五-常见术语"><a href="#五-常见术语" class="headerlink" title="(五)常见术语"></a>(五)常见术语</h1><p><strong>1.持久度/留香时间</strong>：指香水的香味能保留的最大时间，也就是三调的香味释放完的时间，它与香水中的香精含量成正比。通常高浓度的Parfum和EDP要比低浓度的EDT、EDC留香时间更久</p><p><strong>2.扩散性</strong>：指香水在周围空气中的扩散能力，扩散性强的香水，能让人很远就能闻到，扩散性弱的香水只能紧贴皮肤才能闻到。香水中酒精的作用是帮助香精挥发，因此香精浓度较低的EDT、EDC都有较好的扩散性，但由于挥发过快，持久度则相应比较差。</p><p><strong>3.街香</strong>：指特别流行，很多人都会使用的常见香水。街香之所以能成为街香，说明香水本身很成功，味道很讨喜，大多数人都能接受。</p><p><strong>4.Flanker</strong>：指的是同系列香水、支线香水。例如Gucci&nbsp;的Bloom系列</p><p><strong>5.线性香水</strong>：指的是没有明显的前中后三调的香水，它们从头到尾只有一个味道，可能的原因：<br>（1）香水所用的原料的挥发速度差不多<br>（2）香水用的原料单一，层次感弱<br>市面上线性香不是主流产品，比较适合不喜欢香气变化，只钟情于某一种香味的人。或者如果要出席一些比较严肃不适合香水味道变化的场合，可以考虑使用线性香。</p><p><strong>6.简装香水</strong>：供给专柜用于试喷的香水。一般只有简陋的纸盒或没有盒子，甚至有些盖子也没有，瓶身上一般会标注“tester&nbsp;not&nbsp;for&nbsp;sale”</p><p><strong>7.分装香水</strong>：是指将正品香水分装至小瓶中，以少量多样的原则，供人试香。让消费者能够以较低的价格体验更多的味道，同时方便随身携带。</p><p><strong>8.散装香水</strong>：是指香水以散装的形式按毫升销售，消费者可以自由决定要多少毫升，要什么香型，用什么样的香水瓶分装。很多街边会有的香水店都是销售散装香水。</p><p><strong>9.商业香</strong>：指的是最常见的时装或美妆品牌推出的香水，像Prada、Dior、Burberry、这类品牌。它侧重考虑的是消费者的喜好，做出来香水消费者喜不喜欢、会不会买账，能不能卖得出去这些问题。</p><p><strong>10.沙龙香</strong>：区别于商业香的创作源头来自于市场需求，沙龙香源自于调香师艺术表达的需求。沙龙香是古法艺术的回归，是对调香师灵感的绝对尊重。比较小众。<br>常见的几个沙龙品牌：Jo&nbsp;Malone、Atelier&nbsp;Cologne、Diptyque、Byredo、Le&nbsp;Labo等，Jo&nbsp;Malone算是沙龙香里最商业的，其他几个牌子感觉也逐渐被大家熟知。</p><p><strong>11.小众香</strong>：就是指少见的、冷门的品牌，是相对的。</p><p><strong>12.调和香</strong>：是指由几种香味按一定比例，混合调制的香味。市面上的香水都是调和香，需要用到几十种甚至上百种香料。</p><p><strong>13.名人香水</strong>：是指某个名人用他的名字成立的香水品牌，生产的香水也即名人香水。例如碧昂斯、贝克汉姆香水等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-简介&quot;&gt;&lt;a href=&quot;#一-简介&quot; class=&quot;headerlink&quot; title=&quot;(一)简介&quot;&gt;&lt;/a&gt;(一)简介&lt;/h1&gt;&lt;p&gt;香水是由80～90%的变性酒精为溶剂，加上各种香料调制而成。&lt;/p&gt;
&lt;h1 id=&quot;二-浓度规格&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="猎奇" scheme="https://www.daipeihong.top/categories/%E7%8C%8E%E5%A5%87/"/>
    
    
    <category term="香水" scheme="https://www.daipeihong.top/tags/%E9%A6%99%E6%B0%B4/"/>
    
  </entry>
  
  <entry>
    <title>JPEG压缩原理</title>
    <link href="https://www.daipeihong.top/2022/10/02/jpeg-ya-suo-yuan-li/"/>
    <id>https://www.daipeihong.top/2022/10/02/jpeg-ya-suo-yuan-li/</id>
    <published>2022-10-02T07:28:00.000Z</published>
    <updated>2022-10-23T07:47:55.097Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021529515.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021529542.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021529575.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021529611.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021529515.png&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://cloudpict</summary>
      
    
    
    
    <category term="猎奇" scheme="https://www.daipeihong.top/categories/%E7%8C%8E%E5%A5%87/"/>
    
    
    <category term="图像处理" scheme="https://www.daipeihong.top/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    <category term="JPEG压缩" scheme="https://www.daipeihong.top/tags/JPEG%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>2D-DCT变换（二）硬件实现</title>
    <link href="https://www.daipeihong.top/2022/10/02/2d-dct-bian-huan-er-ying-jian-shi-xian/"/>
    <id>https://www.daipeihong.top/2022/10/02/2d-dct-bian-huan-er-ying-jian-shi-xian/</id>
    <published>2022-10-02T07:22:00.000Z</published>
    <updated>2022-10-23T07:42:40.158Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021526576.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021526623.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021526667.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021526701.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021526727.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021526786.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021526839.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021526878.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021526906.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021526942.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021526975.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021526576.png&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://cloudpict</summary>
      
    
    
    
    <category term="数字IC" scheme="https://www.daipeihong.top/categories/%E6%95%B0%E5%AD%97IC/"/>
    
    
    <category term="图像处理" scheme="https://www.daipeihong.top/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    <category term="DCT变换" scheme="https://www.daipeihong.top/tags/DCT%E5%8F%98%E6%8D%A2/"/>
    
    <category term="verilog" scheme="https://www.daipeihong.top/tags/verilog/"/>
    
  </entry>
  
  <entry>
    <title>2D-DCT变换（一）公式推导</title>
    <link href="https://www.daipeihong.top/2022/10/02/2d-dct-bian-huan-yi-gong-shi-tui-dao/"/>
    <id>https://www.daipeihong.top/2022/10/02/2d-dct-bian-huan-yi-gong-shi-tui-dao/</id>
    <published>2022-10-02T07:21:00.000Z</published>
    <updated>2022-10-23T07:42:33.387Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021528034.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021528068.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021528034.png&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://cloudpict</summary>
      
    
    
    
    <category term="数字IC" scheme="https://www.daipeihong.top/categories/%E6%95%B0%E5%AD%97IC/"/>
    
    
    <category term="图像处理" scheme="https://www.daipeihong.top/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    <category term="DCT变换" scheme="https://www.daipeihong.top/tags/DCT%E5%8F%98%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>电力半导体第九章笔记</title>
    <link href="https://www.daipeihong.top/2022/10/02/dian-li-ban-dao-ti-di-jiu-zhang-bi-ji/"/>
    <id>https://www.daipeihong.top/2022/10/02/dian-li-ban-dao-ti-di-jiu-zhang-bi-ji/</id>
    <published>2022-10-02T03:05:00.000Z</published>
    <updated>2022-10-23T07:31:11.252Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021105981.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021105008.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021105066.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021105099.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021105128.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021105981.png&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://cloudpict</summary>
      
    
    
    
    <category term="半导体器件工艺" scheme="https://www.daipeihong.top/categories/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%99%A8%E4%BB%B6%E5%B7%A5%E8%89%BA/"/>
    
    
    <category term="电力半导体" scheme="https://www.daipeihong.top/tags/%E7%94%B5%E5%8A%9B%E5%8D%8A%E5%AF%BC%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>电力半导体第八章笔记</title>
    <link href="https://www.daipeihong.top/2022/10/02/dian-li-ban-dao-ti-di-ba-zhang-bi-ji/"/>
    <id>https://www.daipeihong.top/2022/10/02/dian-li-ban-dao-ti-di-ba-zhang-bi-ji/</id>
    <published>2022-10-02T03:04:00.000Z</published>
    <updated>2022-10-23T07:31:15.916Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021104927.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021104957.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021104997.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021104927.png&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://cloudpict</summary>
      
    
    
    
    <category term="半导体器件工艺" scheme="https://www.daipeihong.top/categories/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%99%A8%E4%BB%B6%E5%B7%A5%E8%89%BA/"/>
    
    
    <category term="电力半导体" scheme="https://www.daipeihong.top/tags/%E7%94%B5%E5%8A%9B%E5%8D%8A%E5%AF%BC%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>电力半导体第七章笔记</title>
    <link href="https://www.daipeihong.top/2022/10/02/dian-li-ban-dao-ti-di-qi-zhang-bi-ji/"/>
    <id>https://www.daipeihong.top/2022/10/02/dian-li-ban-dao-ti-di-qi-zhang-bi-ji/</id>
    <published>2022-10-02T03:03:00.000Z</published>
    <updated>2022-10-23T07:30:21.838Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021104846.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021104871.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021104933.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021104970.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021104846.png&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://cloudpict</summary>
      
    
    
    
    <category term="半导体器件工艺" scheme="https://www.daipeihong.top/categories/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%99%A8%E4%BB%B6%E5%B7%A5%E8%89%BA/"/>
    
    
    <category term="电力半导体" scheme="https://www.daipeihong.top/tags/%E7%94%B5%E5%8A%9B%E5%8D%8A%E5%AF%BC%E4%BD%93/"/>
    
  </entry>
  
</feed>
