<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Stephen&#39;s Blog</title>
  
  <subtitle>welcome to Stephen&#39;s Blog</subtitle>
  <link href="https://www.daipeihong.top/atom.xml" rel="self"/>
  
  <link href="https://www.daipeihong.top/"/>
  <updated>2022-11-17T07:51:17.629Z</updated>
  <id>https://www.daipeihong.top/</id>
  
  <author>
    <name>DaiPeihong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Verilog数字系统设计第(三)章总结</title>
    <link href="https://www.daipeihong.top/2022/11/17/verilog-shu-zi-xi-tong-she-ji-di-san-zhang-zong-jie/"/>
    <id>https://www.daipeihong.top/2022/11/17/verilog-shu-zi-xi-tong-she-ji-di-san-zhang-zong-jie/</id>
    <published>2022-11-17T07:26:00.000Z</published>
    <updated>2022-11-17T07:51:17.629Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-1-模块的结构"><a href="#3-1-模块的结构" class="headerlink" title="3.1 模块的结构"></a>3.1 模块的结构</h1><p>Verilog 的基本设计单元是“模块”( block)。一个模块是由两部分组成的：<u>一部分描述接口</u>，<u>另一部分描述逻辑功能，即定义输入是如何影响输出的。</u><br>Verilog 模块结构位于在 module和 endmodule声明语句之间。每个Verilog程序包括4个主要部分：<u>端口定义、I/O说明、内部信号声明、功能定义</u>。</p><h2 id="3-1-1-模块的端口定义"><a href="#3-1-1-模块的端口定义" class="headerlink" title="3.1.1 模块的端口定义"></a>3.1.1 模块的端口定义</h2><p>模块的端口声明了模块的输入输出口。其格式如下:</p><pre class=" language-verilog"><code class="language-verilog"><span class="token keyword">module</span>模块名<span class="token punctuation">(</span>口<span class="token number">1</span><span class="token punctuation">,</span>口<span class="token number">2</span><span class="token punctuation">,</span>口<span class="token number">3</span><span class="token punctuation">,</span>口<span class="token number">4</span><span class="token punctuation">,</span>…<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span></code></pre><p>在引用模块时其端口有两种方式连接:<br>一种是<strong>位置关联</strong></p><pre class=" language-verilog"><code class="language-verilog">模块名<span class="token punctuation">(</span>连接端口<span class="token number">1</span>信号名<span class="token punctuation">,</span>连接端口⒉信号名<span class="token punctuation">,</span>连接端口<span class="token number">3</span>信号名<span class="token punctuation">,</span>……<span class="token punctuation">)</span> <span class="token punctuation">;</span></code></pre><p>一种是<strong>名称关联</strong></p><pre class=" language-verilog"><code class="language-verilog">模块名<span class="token punctuation">(</span><span class="token punctuation">.</span>端口<span class="token number">1</span>名<span class="token punctuation">(</span>连接信号<span class="token number">1</span>名<span class="token punctuation">)</span><span class="token punctuation">,</span>端口<span class="token number">2</span>名<span class="token punctuation">(</span>连接信号<span class="token number">2</span>名<span class="token punctuation">)</span><span class="token punctuation">,</span>……<span class="token punctuation">)</span> <span class="token punctuation">;</span></code></pre><h2 id="3-1-2-模块内容"><a href="#3-1-2-模块内容" class="headerlink" title="3.1.2 模块内容"></a>3.1.2 模块内容</h2><p>模块的内容包括I/O说明、内部信号声明、功能定义。</p><ol><li><strong>I/O说明的格式</strong></li></ol><pre class=" language-verilog"><code class="language-verilog">输入口<span class="token punctuation">:</span><span class="token keyword">input</span><span class="token punctuation">[</span>信号位宽<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>端口名<span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">input</span><span class="token punctuation">[</span>信号位宽<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>端口名<span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">input</span><span class="token punctuation">[</span>信号位宽<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>端口名i<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//(共有i个输人口)</span>输出口<span class="token punctuation">:</span><span class="token keyword">output</span><span class="token punctuation">[</span>信号位宽<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>端口名<span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">output</span><span class="token punctuation">[</span>信号位宽<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>端口名<span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">output</span><span class="token punctuation">[</span>信号位宽<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>端口名j<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//(共有j个输出口)</span>输人<span class="token operator">/</span>输出口<span class="token punctuation">:</span><span class="token keyword">inout</span><span class="token punctuation">[</span>信号位宽<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>端口名<span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">inout</span><span class="token punctuation">[</span>信号位<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>端口名<span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">inout</span><span class="token punctuation">[</span>信号位宽<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>端口名k<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//(共有k个双向总线端口)</span></code></pre><ol start="2"><li><strong>内部信号声明</strong><br>wire和 reg类型变量的声明:</li></ol><pre class=" language-verilog"><code class="language-verilog"><span class="token keyword">reg</span>  <span class="token punctuation">[</span>width<span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">]</span>R变量<span class="token number">1</span><span class="token punctuation">,</span>R变量<span class="token number">2</span>……<span class="token punctuation">;</span><span class="token keyword">wire</span> <span class="token punctuation">[</span>width<span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">]</span>W变量l<span class="token punctuation">,</span>W变量<span class="token number">2</span>……<span class="token punctuation">;</span></code></pre><ol start="3"><li><strong>功能定义</strong><br>模块中最重要的部分是逻辑功能定义部分，有以下3种方法可在模块中产生逻辑。<br>(1)assign声明语句<br>如:</li></ol><pre class=" language-verilog"><code class="language-verilog"><span class="token keyword">assign</span> a<span class="token operator">=</span>b <span class="token operator">&amp;</span>c<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//两输入与门</span></code></pre><p>(2)实例元件<br>如:</p><pre class=" language-verilog"><code class="language-verilog"><span class="token keyword">and</span> <span class="token number">#2</span> <span class="token function">ul</span><span class="token punctuation">(</span> q，a，b <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//两输入与门</span></code></pre><p>(3))always块<br>如:</p><pre class=" language-verilog"><code class="language-verilog"><span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">posedge</span> clr<span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span>clr<span class="token punctuation">)</span>q<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>en<span class="token punctuation">)</span>q<span class="token operator">&lt;=</span> d<span class="token punctuation">;</span><span class="token keyword">end</span></code></pre><p>采用assign语句是描述组合逻辑最常用的方法之一，而 always块既可用于描述组合逻辑,也可描述时序逻辑。</p><p><strong>always语句的执行顺序：</strong></p><ul><li>在<u>“always”模块内，逻辑是按照指定的顺序执行的</u>。“always”块中的语句称为“顺序语句”，因为它们是顺序执行的。所以, “ always”块也称为“<strong>过程块</strong>”。</li><li>两个或更多的“always”模块都是同时执行的，而模块内部的语句是顺序执行的。</li></ul><p><strong>与C语言的不同：</strong></p><ul><li><u>在Verilog模块中所有过程块(如:initial 块,always块),连续赋值语句,实例引用都是并行的</u>。</li><li>它们表示的是一种通过变量名互相连接的关系。</li><li>在同一模块中，assign语句、实例元件、always块语句这三者出现的先后顺序没有关系。</li><li><u>只有连续赋值语句assign和实例引用语句可以独立于过程块而存在于模块的功能定义部分</u>。</li></ul><h1 id="3-2-数据类型及其常量和变量"><a href="#3-2-数据类型及其常量和变量" class="headerlink" title="3.2 数据类型及其常量和变量"></a>3.2 数据类型及其常量和变量</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;3-1-模块的结构&quot;&gt;&lt;a href=&quot;#3-1-模块的结构&quot; class=&quot;headerlink&quot; title=&quot;3.1 模块的结构&quot;&gt;&lt;/a&gt;3.1 模块的结构&lt;/h1&gt;&lt;p&gt;Verilog 的基本设计单元是“模块”( block)。一个模块是由两部分组成的：</summary>
      
    
    
    
    <category term="数字IC" scheme="https://www.daipeihong.top/categories/%E6%95%B0%E5%AD%97IC/"/>
    
    
    <category term="Verilog" scheme="https://www.daipeihong.top/tags/Verilog/"/>
    
  </entry>
  
  <entry>
    <title>SystemVerilog学习笔记(十)</title>
    <link href="https://www.daipeihong.top/2022/11/15/systemverilog-xue-xi-bi-ji-shi/"/>
    <id>https://www.daipeihong.top/2022/11/15/systemverilog-xue-xi-bi-ji-shi/</id>
    <published>2022-11-15T05:01:00.000Z</published>
    <updated>2022-11-15T13:39:50.620Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211152049091.png"></p><h1 id="1-覆盖率"><a href="#1-覆盖率" class="headerlink" title="1. 覆盖率"></a>1. 覆盖率</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>覆盖率是衡量验证完备性的一个通用词语，用来衡量设计中已经被测部分和未测部分的比例，通常被定义为已达到所需验证部分的百分比。</p><h2 id="1-2-分类"><a href="#1-2-分类" class="headerlink" title="1.2 分类"></a>1.2 分类</h2><h3 id="按照覆盖率生成方法"><a href="#按照覆盖率生成方法" class="headerlink" title="按照覆盖率生成方法"></a>按照覆盖率生成方法</h3><ul><li>隐性生成</li><li>显性生成</li></ul><h3 id="按照覆盖率溯源"><a href="#按照覆盖率溯源" class="headerlink" title="按照覆盖率溯源"></a>按照覆盖率溯源</h3><ul><li>从功能描述而来</li><li>从设计实现而来<br>功能覆盖率是显性的需要人为定义的覆盖率，而代码覆盖率则是隐性覆盖率这是因为仿真工具可以自动从RTL代码来生成。<br>将上述两个分类的方式进行组合，那么可以将代码覆盖率、断言覆盖率以及功能覆盖率分别置入到不同的象限。        <meta charset="utf-8">      <title>HTML</title>                  <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211151928901.png" width="350" height="300" title=" ">      但是需要注意，目前有一个象限仍然处于研究阶段，没有隐性的可以从功能描述生成某种覆盖率的方法，这也是为什么功能覆盖率依然需要人为定义的原因。</li></ul><h1 id="2-两种主要覆盖率"><a href="#2-两种主要覆盖率" class="headerlink" title="2. 两种主要覆盖率"></a>2. 两种主要覆盖率</h1><h2 id="2-1-代码覆盖率"><a href="#2-1-代码覆盖率" class="headerlink" title="2.1 代码覆盖率"></a>2.1 代码覆盖率</h2><ul><li>跳转覆盖率：用来衡量寄存器跳转的次数(0→1,1→0)</li><li>行覆盖率：用来衡量源代码哪些代码行被执行过，以此来指出哪些代码行没有被执行过</li><li>分支覆盖率：分支覆盖率是用来对条件语句( if/else,case,?:)，指出其执行的分支轨迹。</li><li>条件覆盖率：条件覆盖率是用来衡量一些布尔表达式中各个条件真伪判断的执行轨迹。</li><li>状态机覆盖率：每个状态的进入次数，状态之间的跳转次数，以及多个状态的跳转顺序都可以由仿真工具记录下来。</li></ul><h2 id="2-2-功能覆盖率"><a href="#2-2-功能覆盖率" class="headerlink" title="2.2 功能覆盖率"></a>2.2 功能覆盖率</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>我们无法通过代码覆盖率得知要求的功能是否被实现，需要显性地通过功能覆盖率与设计功能描述做映射，继而量化功能验证的进程。<br>创建功能覆盖率模型需要完成以下两个步骤:</p><ul><li>从功能描述文档提取拆分需要测试的功能点</li><li>将功能点量化为与设计实现对应的SV功能覆盖代码</li></ul><h3 id="覆盖组-covergroup"><a href="#覆盖组-covergroup" class="headerlink" title="覆盖组(covergroup)"></a>覆盖组(covergroup)</h3><ul><li>覆盖组与类相似，在一次定义以后便可以多次进行例化。</li><li>覆盖组含有覆盖点(coverpoint)、选项(option)、形式参数(argument)和可选触发(trigger event) </li><li>一个覆盖组包含了一个或者多个数据点，全都在同一时间采集。</li><li>覆盖组可以定义在类里，也可以定义在模块或者程序(program)中。</li></ul><pre class=" language-systemverilog"><code class="language-systemverilog">class xyz;    bit [3:0] m_;int m y;    bit m_z;    covergroup cov1 @m_z; ll embedded covergroup        coverpoint m_x;        coverpoint m_y;    endgroup    function new() ; cov1 = new ; endfunctionendclass</code></pre><ul><li>覆盖组可以采集任何可见的变量，比如程序或模块变量、接口信号或者设计中的任何信号</li><li>在类中的覆盖组也可以采集类的成员变量·覆盖组应该定义在适当的抽象层次上</li><li>对任何事务的采样都必须等到数据被待测设计接收到以后。</li><li>一个类也可以包含多个覆盖组，每个覆盖组可以根据需要将它们使能或者禁止</li></ul><pre class=" language-systemverilog"><code class="language-systemverilog">class MC;    logic [3:0] m_x;local logic m_z;bit m_e;    covergroup cv1 @(posedge clk); coverpoint m_x; endgroup     covergroup cv2 @m_e coverpoint m_z; endgroupendclass</code></pre><h3 id="覆盖点-coverpoint"><a href="#覆盖点-coverpoint" class="headerlink" title="覆盖点(coverpoint)"></a>覆盖点(coverpoint)</h3><h3 id="仓-bin"><a href="#仓-bin" class="headerlink" title="仓(bin)"></a>仓(bin)</h3><p>使用coverpoint 指定采样一个变量和表达式时，sv会创建很多的<strong>bin</strong>（仓）来记录每个数值被捕捉的次数。这些<strong>bin是衡量功能覆盖率的基本单位。</strong></p><h4 id="数值覆盖"><a href="#数值覆盖" class="headerlink" title="数值覆盖"></a>数值覆盖</h4><p>Covergroup的参数也可以被传递到bin的定义中</p><pre class=" language-systemverilog"><code class="language-systemverilog">covergroup cg (ref int ra,input int low, int high )@ (posedge clk) ;    coverpoint r {        bins good = { [low : high] };        bins bad[] = default;        }endgroup...int va, vb;cg c1 = new ( va, 0，50 ) ;cg c2 = new( vb,120,600 ) ;</code></pre><h4 id="值变化覆盖"><a href="#值变化覆盖" class="headerlink" title="值变化覆盖"></a>值变化覆盖</h4><p>除了可以覆盖数值，还可以覆盖数值的变化</p><pre class=" language-systemverilog"><code class="language-systemverilog">value1 =>value2value1 =>value3 =>value4 =>value5range_list1 =>range_list21,5 =>6,7trans__item [*repeat_range]</code></pre><p>除了使用=&gt;来表示相邻采样点的变化，也可以使用-&gt;来表示非相邻采样点的数值变化，在=&gt;序列后的下一个时序必须紧跟=&gt;序列的最后一个事件<br>3 [-&gt;3]<br>表示…=&gt;3…=&gt;3…=&gt;3<br>1=&gt;3 [-&gt;3]=&gt;5<br>表示1…=&gt;3…=&gt;3…=&gt;3 =&gt;5</p><p>与[-&gt; repeat range]类似的有[= repeatrange]也表示非连续的循环，只是与-&gt;有区别的在于，跟随-&gt;序列的下一次值变化可以发生在-&gt;结束后的任何时刻。<br>3 [= 2]<br>表示…=&gt;3…=&gt;3<br>1=&gt;3 [=2]=&gt;6<br>表示1…=&gt;3…=&gt;3…=&gt;6</p><h4 id="自动生成"><a href="#自动生成" class="headerlink" title="自动生成"></a>自动生成</h4><p>如果coverpoint没有指定任何bin，那么SV将会为其自动生成bin，遵循的原则是:</p><ul><li>如果变量是枚举类型，那么bin的数量是枚举类型的基数(所有枚举数值的合)</li><li>如果变量是整形(M位宽)，那么bin的类型将是2^M和auto_bin_max选项的较小值</li></ul><h4 id="通配应用"><a href="#通配应用" class="headerlink" title="通配应用"></a>通配应用</h4><ul><li>默认情况下，数值的变化可以针对四值类型变量进行覆盖，例如bin如果包含x或者z，则表示只有该变量对应位也为x或者z的时候，bin也才可以被采样到。</li><li>wildcard修饰符可以使得bin中包含x，z和?的数值都将用来表示0或者1，也就是通配符的意思</li></ul><pre class=" language-systemverilog"><code class="language-systemverilog">wildcard bins g12_15 = { 4 'b11??} ;g12_15可以用来表示12到15之间的值，即1100,1101,1110,1111</code></pre><h4 id="忽略类型和非法类型"><a href="#忽略类型和非法类型" class="headerlink" title="忽略类型和非法类型"></a>忽略类型和非法类型</h4><p>ignore_bins用来将其排除在有效统计的bin集合之外</p><pre class=" language-systemverilog"><code class="language-systemverilog">covergroup cg23;    coverpoint a {        ignore_bins ignore_vals = { 7,8} ;        ignore_bins ignore_trans = (1=>3=>5);        }endgroup</code></pre><p>illegal_bins用来指出采样到的数值为非法制，如果illegal_bins被采样到，那么仿真将报错</p><pre class=" language-systemverilog"><code class="language-systemverilog">covergroup cg3 ;    coverpoint b {    i1legal_bins bad_vals = { 1，2,3};    illegal_bins bad_trans = (4=>5=>6);    }endgroup</code></pre><h3 id="交叉覆盖率-cross"><a href="#交叉覆盖率-cross" class="headerlink" title="交叉覆盖率(cross)"></a>交叉覆盖率(cross)</h3><ul><li>covergroup可以在两个或者更多的coverpoint或者变量之间定义交叉覆盖率(cross coverage)</li><li>在对a和b产生交叉覆盖率之前，系统会先为它们隐性产生对应的coverpoint和bin，每个coverpoint都有16个自动产生的bin</li><li>两个coverpoint交叉以后将生成256个交叉的bin</li></ul><pre class=" language-systemverilog"><code class="language-systemverilog">bit [3:0] a, b;covergroup cov @(posedge clk) ;    axb : cross a, b;endgroup</code></pre><ul><li>除了系统会自动为交叉覆盖率生成bin以外，用户还可以自己定义交叉覆盖率的bin</li><li>binsof()的参数可以是coverpoint或者变量，表示对应的bin总和，可以利用binsof()对其结果做进—步的过滤</li></ul><pre class=" language-systemverilog"><code class="language-systemverilog">int i,j;    covergroup ct;        coverpoint i { bins i[]= { [O:1] } ; }        coverpoint j { bins j[] = { [0:1] } ; }        x1 : cross i,j;        x2 : cross i,j{        bins i_zero = binsof(i)intersect { o };        }endgroup</code></pre><h1 id="3-问答题"><a href="#3-问答题" class="headerlink" title="3. 问答题"></a>3. 问答题</h1><p><strong>请考虑对于目前的DUT (router)，要完成对它的功能测试，从接口时序、路由功能来看，需要考虑哪些功能和对应的测试场景?考虑路桑给出的接口插件文件(包含功能覆盖率定义和采样)，是否没有全部映射你给出的待测功能点?如果需要补全，你是否可以在给出的接口插件文件中，补全这部分功能覆盖率定义代码呢?请将补全的部分代码，粘贴到这里，并且在你的实验四的代码中，试运行去收集你关心的这部分功能覆盖率，在验收实验四的时候，给予必要的说明。</strong></p><p>答：需要考虑是否各个输入端口都能输入数据，各个输出端口是否都能接收到数据；以及不同输入端口并行发送数据、同一端口发送多个数据到不同输出端，同一输出端口接收来自不同输入端口发送的数据……</p><h1 id="可参考"><a href="#可参考" class="headerlink" title="可参考"></a>可参考</h1><p><a href="https://blog.csdn.net/m0_59670134/article/details/119606764?spm=1001.2101.3001.6650.3&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3-119606764-blog-123967971.pc_relevant_recovery_v2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3-119606764-blog-123967971.pc_relevant_recovery_v2&amp;utm_relevant_index=6">SV基础知识6—覆盖率收集_持续学习_ing的博客-CSDN博客_覆盖率收集</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211152049091.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;1-覆盖率&quot;&gt;&lt;a href=&quot;#1</summary>
      
    
    
    
    <category term="数字IC" scheme="https://www.daipeihong.top/categories/%E6%95%B0%E5%AD%97IC/"/>
    
    
    <category term="数字前端" scheme="https://www.daipeihong.top/tags/%E6%95%B0%E5%AD%97%E5%89%8D%E7%AB%AF/"/>
    
    <category term="SystemVerilog验证" scheme="https://www.daipeihong.top/tags/SystemVerilog%E9%AA%8C%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>10.31-11.13总结</title>
    <link href="https://www.daipeihong.top/2022/11/13/10.31-11.13-zong-jie/"/>
    <id>https://www.daipeihong.top/2022/11/13/10.31-11.13-zong-jie/</id>
    <published>2022-11-13T11:50:00.000Z</published>
    <updated>2022-11-17T11:51:02.019Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、任务"><a href="#一、任务" class="headerlink" title="一、任务"></a>一、任务</h3><p>用ECC对 leon 系统里的SRAM进行加固</p><hr><h3 id="二、思路"><a href="#二、思路" class="headerlink" title="二、思路"></a>二、思路</h3><p>leon系统主要模块有<br>(1)Leon2 处理器核；(2)指令 SRAM 模块；(3)数据 SRAM 模块；(4)初始化指令 SRAM 模块</p><p>选取星载计算机系统中的数据 SRAM，将ECC电路加到数据SRAM上</p>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211131327595.png" width="500" height="300" title=" ">        <hr><h3 id="三、模块示意图"><a href="#三、模块示意图" class="headerlink" title="三、模块示意图"></a>三、模块示意图</h3>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211131414230.png" width="500" height="350" title=" ">        <hr><h3 id="四、仿真结果"><a href="#四、仿真结果" class="headerlink" title="四、仿真结果"></a>四、仿真结果</h3>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211131534173.png" width="1000" height="200" title=" ">                    <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211131544733.png" width="1200" height="100" title=" ">        ]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、任务&quot;&gt;&lt;a href=&quot;#一、任务&quot; class=&quot;headerlink&quot; title=&quot;一、任务&quot;&gt;&lt;/a&gt;一、任务&lt;/h3&gt;&lt;p&gt;用ECC对 leon 系统里的SRAM进行加固&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;二、思路&quot;&gt;&lt;a href=&quot;#二、思路&quot;</summary>
      
    
    
    
    <category term="数字IC" scheme="https://www.daipeihong.top/categories/%E6%95%B0%E5%AD%97IC/"/>
    
    
    <category term="leon处理器" scheme="https://www.daipeihong.top/tags/leon%E5%A4%84%E7%90%86%E5%99%A8/"/>
    
    <category term="ECC" scheme="https://www.daipeihong.top/tags/ECC/"/>
    
  </entry>
  
  <entry>
    <title>SystemVerilog学习笔记(九)</title>
    <link href="https://www.daipeihong.top/2022/11/06/systemverilog-xue-xi-bi-ji-jiu/"/>
    <id>https://www.daipeihong.top/2022/11/06/systemverilog-xue-xi-bi-ji-jiu/</id>
    <published>2022-11-06T06:45:00.000Z</published>
    <updated>2022-11-07T10:13:50.684Z</updated>
    
    <content type="html"><![CDATA[<p>本文思维导图如下：<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211071641178.png"></p><h1 id="1-线程控制"><a href="#1-线程控制" class="headerlink" title="1. 线程控制"></a>1. 线程控制</h1><h2 id="1-1-并行线程"><a href="#1-1-并行线程" class="headerlink" title="1.1 并行线程"></a>1.1 并行线程</h2><p>Verilog中与顺序线程begin…end相对的是并行线程fork…join。</p><h3 id="1-1-1创建线程"><a href="#1-1-1创建线程" class="headerlink" title="1.1.1创建线程"></a>1.1.1创建线程</h3><p>SV引入了两种新新的创建线程的方法，<u>fork…join_none</u>和<u>fork…join_any</u>。</p><ul><li><span style="background:rgba(136, 49, 204, 0.2)">fork…join</span><br>fork…join需要所有并行的线程都结束以后才会继续执行。</li><li><span style="background:rgba(136, 49, 204, 0.2)">fork…join_any</span><br>fork…join_any则会等到任何一个线程结束以后就继续执行。</li><li><span style="background:rgba(136, 49, 204, 0.2)">fork…join_none</span><br>fork…join_none则不会等待其子线程而继续执行。        <meta charset="utf-8">      <title>HTML</title>                  <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211061457338.png" width="500" height="200" title=" ">      实例        <meta charset="utf-8">      <title>HTML</title>                  <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211061537443.png" width="500" height="500" title=" ">      </li></ul>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211061537770.png" width="500" height="480" title=" ">                    <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211061539318.png" width="500" height="650" title=" ">        <h3 id="1-1-2子程序等待-x2F-停止"><a href="#1-1-2子程序等待-x2F-停止" class="headerlink" title="1.1.2子程序等待/停止"></a>1.1.2子程序等待/停止</h3><p>需要注意的是，fork…join_any和fork. . .join_none继续执行后，其一些未完成的子程序仍将在后台运行。如果要等待这些子程序全部完成，或者停止这些子程序，可以使用<span style="background:rgba(3, 135, 102, 0.2)">wait fork</span>或者<span style="background:rgba(3, 135, 102, 0.2)">disable fork</span>。<br><strong>(1)wait fork</strong></p>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211061547271.png" width="500" height="720" title=" ">        **(2)disable fork**            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211061549290.png" width="500" height="720" title=" ">        ## 1.2 时序控制SV可以通过延迟控制或者事件等待来对过程块完成时序控制。### 1.2.1 延迟控制延迟控制即通过#来完成。&gt;#10 rega = regb;<h3 id="1-2-2-事件控制"><a href="#1-2-2-事件控制" class="headerlink" title="1.2.2 事件控制"></a>1.2.2 事件控制</h3><p>事件(event）控制即通过@来完成。</p><blockquote><p>@r rega = regb ;<br>@(posedge clock) rega = regb;</p></blockquote><h3 id="1-2-3-事件等待"><a href="#1-2-3-事件等待" class="headerlink" title="1.2.3 事件等待"></a>1.2.3 事件等待</h3><p>wait语句也可以与事件或者表达式结合来完成。</p><blockquote><p>real AOR[] ;<br>initial wait(AOR.size() &gt; 0) …. ;</p></blockquote><h1 id="2-进程间同步和通信"><a href="#2-进程间同步和通信" class="headerlink" title="2. 进程间同步和通信"></a>2. 进程间同步和通信</h1><p>测试平台中的所有线程都需要同步并交换数据。<br>一个线程等待另外一个，例如验证环境需要等待所有激励结束、比较结束才可以结束仿真。比如监测器需要将监测到的数据发送至比较器，比较器又需要从不同的缓存获取数据进行比较。</p><h2 id="2-1-事件"><a href="#2-1-事件" class="headerlink" title="2.1 事件"></a>2.1 事件</h2><ul><li>声明<br>可以通过event来声明一个命名event变量，并且去触发它。这个命名event可以用来控制进程的执行。</li><li>触发<br>可以通过-&gt;来触发事件。<br>其它等待该事件的进程可以通过@操作符或者wait()来检查event触发状态来完成。</li><li>等待<br>wait__order可以使得进程保持等待，直到在参数列表中的事件event按照顺序从左到右依次完成。如果参数列表中的事件被触发但是没有按照要求的顺序，那么会使得等待操作失败。<blockquote><p>wait_order ( a, b, c);</p><p>wait order( a, b, c ) else $display ( “Error: eventsout of order” );</p><p>bit success ;<br>wait order( a, b, c ) success = 1; else success = 0 ;</p></blockquote></li></ul>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211061714487.png" width="500" height="700" title=" ">        <h2 id="2-2-旗语"><a href="#2-2-旗语" class="headerlink" title="2.2 旗语"></a>2.2 旗语</h2><p>旗语从概念上讲，是一个容器。在创建旗语的时候，会为其分配固定的钥匙数量。使用旗语的进程必须先获得其钥匙，才可以继续执行。旗语的钥匙数量可以有多个，等待旗语钥匙的进程也可同时有多个。旗语通常用于互斥，对共享资源的访问控制，以及基本的同步<br><img src="https://img-blog.csdnimg.cn/8bbdaa8efccc4e36b6ece797b80c605a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASSBDIGUgcg==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h3 id="2-2-1用法"><a href="#2-2-1用法" class="headerlink" title="2.2.1用法"></a>2.2.1用法</h3><ul><li><p>创建旗语，并为其分配钥匙的方式如下:</p><blockquote><p>semaphore sm;<br>sm = new ();</p></blockquote></li><li><p>创建一个具有固定钥匙数量的旗语:</p><blockquote><p>new (N = 0)</p></blockquote></li><li><p>从旗语那里获取一个或多个钥匙(阻塞型) : </p><blockquote><p>get (N = 1)</p></blockquote></li><li><p>将一个或多个钥匙返回到旗语中:</p><blockquote><p>put (N = 1)</p></blockquote></li><li><p>尝试获取一个或多个钥匙而不会阻塞(非阻塞型) : </p><blockquote><p>try_get (N = 1)</p></blockquote></li></ul><h3 id="2-2-2基本操作"><a href="#2-2-2基本操作" class="headerlink" title="2.2.2基本操作"></a>2.2.2基本操作</h3><h4 id="senmaphore-new"><a href="#senmaphore-new" class="headerlink" title="senmaphore: :new()"></a>senmaphore: :new()</h4><p>new ())的原型如下:</p><blockquote><p>function new (int keyCount = 0) ;</p></blockquote><p>keyCount指定最初分配给旗语的钥匙数目。keyCount的默认值为0。当更多钥匙放入旗语时，钥匙数目可以超出初始时的keyCount数量，而不是删除。</p><h4 id="semaphore-put"><a href="#semaphore-put" class="headerlink" title="semaphore: :put()"></a>semaphore: :put()</h4><p>put ()方法用于将钥匙数量返回给旗语。<br>put ()的原型如下:</p><blockquote><p>function void put (int keyCount = 1) ;</p></blockquote><p>keycount指定返回到旗语的钥匙数量。默认值为1。调用semaphore.put ()函数时，指定数量的钥匙将返回到旗语。如果其它进程已经在等待旗语，则该进程应在有足够数量钥匙的情况下返回。</p><h4 id="semaphore-get"><a href="#semaphore-get" class="headerlink" title="semaphore: :get()"></a>semaphore: :get()</h4><p>get ()方法用于从旗语中获取指定数量的钥匙。get ()的原型如下:</p><blockquote><p>task get (int keycount = 1) ;</p></blockquote><p>keyCount指定从旗语获取所需的钥匙数，默认值为1。<u>如果指定数量的钥匙可用，则该方法返回并继续执行。如果指定数量的钥匙不足，进程将阻塞，直到钥匙数目充足。</u>旗语的等待队列是<span style="background:rgba(240, 200, 0, 0.2)">先进先出(FIFO)</span>，即先排队等待旗语的将优先得到钥匙。</p><h4 id="semaphore-try-get"><a href="#semaphore-try-get" class="headerlink" title="semaphore : :try_get()"></a>semaphore : :try_get()</h4><p>try get ()方法用于从信号量中获取指定数量的钥匙，但不会被阻塞。try_get ()的原型如下:</p><blockquote><p>function int try_get (int keyCount = 1) ;</p></blockquote><p>keyCount指定从旗语处获取所需的钥匙数目，默认值为1。<u>如果指定数量的钥匙可用，则该方法返回正数并继续执行。如果指定数量的钥匙不足，则该方法返回0。</u></p><h3 id="2-2-3实例"><a href="#2-2-3实例" class="headerlink" title="2.2.3实例"></a>2.2.3实例</h3><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211061715075.png"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211061715493.png"></p><h2 id="2-3-信箱"><a href="#2-3-信箱" class="headerlink" title="2.3 信箱"></a>2.3 信箱</h2><p>信箱mailbox可以使得进程之间的信息得以交换，数据可以由一个进程写入信箱，再由另外一个进程获得。<br><img src="https://img-blog.csdnimg.cn/c6469e7241f04c10affb418009c08e36.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASSBDIGUgcg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>信箱在创建时可以限制其容量，或者不限制。<u>当信箱容量写满时，后续再写入的动作会被挂起，直到信箱的数据从中读取，使得信箱有空间以后才可以继续写入。</u><br>不限制容量的信箱则不会挂起写入信箱的动作。</p><h3 id="2-3-1-内建方法"><a href="#2-3-1-内建方法" class="headerlink" title="2.3.1 内建方法"></a>2.3.1 内建方法</h3><h4 id="new"><a href="#new" class="headerlink" title="new()"></a>new()</h4><p>new()用于创建信箱。<u>可以在创建信箱的时候限定或者不限定其大小</u>。<u>默认情况下，如果不传入参数，bound默认值为0，表示不限定信箱大小，如果传入的数值大于0，那么表示信箱的最大容量</u>。bound应为正数，如果未负数的话，系统会提示警告和出现无法预期的行为。</p><blockquote><p>function new (int bound = 0) ;</p></blockquote><h4 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h4><p>put()会将信息按照FIFO的顺序写入到信箱中，如果信箱此时已满，则put()任务会挂起，直到信箱有新的空间可以容纳消息。</p><h4 id="try-put"><a href="#try-put" class="headerlink" title="try_put()"></a>try_put()</h4><p>try put()试着写入信箱但不会阻塞。try put()也会按照FIFO顺序写入信箱，不会发生阻塞。如果信箱已满，则写入失败，返回0;如果信箱未满，则写入成功，返回1。</p><h4 id="get-x2F-peek"><a href="#get-x2F-peek" class="headerlink" title="get()/peek()"></a>get()/peek()</h4><p>获取信息: get()同时会取出数据，peek()不会取出数据。get()会将信息从信箱中取出，如果信箱此时为空，则get()任务会挂起，直到信箱中有消息可以读取，任务才会返回。该方法会将读取到的消息从信箱中移除。</p><h4 id="try-get-x2F-try-peek"><a href="#try-get-x2F-try-peek" class="headerlink" title="try_get()/try_peek()"></a>try_get()/try_peek()</h4><p>试着从信箱取出数据但不会阻塞。try get()也会将信息从信箱中取出，只是该函数不会发生阻塞。如果信箱为空，则读取失败，返回0;如果信箱不为空，则读取成功，返回1。该方法也会将读取到的消息从信箱中移除。</p><h4 id="num"><a href="#num" class="headerlink" title="num()"></a>num()</h4><p>num()会返回信箱目前的消息数目。可以结合num()与get()或者put()，防止get()/put()方法在信箱为空或者为满的时候被阻塞。</p><h3 id="2-3-2-实例"><a href="#2-3-2-实例" class="headerlink" title="2.3.2 实例"></a>2.3.2 实例</h3><p>mailbox <span style="background:rgba(240, 200, 0, 0.2)">#(int)</span> mb;//声明mailbox句柄，并且指明该mailbox中<span style="background:rgba(240, 200, 0, 0.2)">只能存放int类型</span>的数据<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211070937007.png" alt="|800"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211070938538.png" alt="|800"></p><h2 id="2-4虚方法"><a href="#2-4虚方法" class="headerlink" title="2.4虚方法"></a>2.4虚方法</h2><p>给pringtB添加关键词virtual，P1扩大查找范围，扩大到子类对象里面。如果子类里面有同名的方法，若有，调用子类里面同名的方法（以子类的实现优先）。<br>子类不添加virtual无影响，父类添加即可。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211071005100.png" alt="|500"></p><h1 id="3-类型转换"><a href="#3-类型转换" class="headerlink" title="3. 类型转换"></a>3. 类型转换</h1><h2 id="3-1-静态转换"><a href="#3-1-静态转换" class="headerlink" title="3.1 静态转换"></a>3.1 静态转换</h2><p>静态转换操作符不对转换值进行检查。<br>转换时指定目标类型，并在要转换的表达式前加上单引号即可。Verilog对整数和实数类型，或者不同位宽的向量之间进行隐式转换。</p><blockquote><p>int i;<br>real r;<br>i = int ‘ (10.0 - 0.1); //cast is optional<br>r= real’(42);// cast is optional</p></blockquote><h2 id="3-2-动态转换"><a href="#3-2-动态转换" class="headerlink" title="3.2 动态转换"></a>3.2 动态转换</h2><p>我们总是可以将子类的句柄赋值给父类的句柄。但是在我们将父类的句柄赋值给子类的句柄时，编译将会报错。<br>$cast()系统函数<u>可以将父类句柄转换为子类句柄</u>，只要该父类句柄指向的是一个子类的对象。</p><blockquote><p>function int $cast( singular dest_var, singularsource_exp ) ;</p></blockquote><p>或者</p><blockquote><p>task $cast( singular dest_var, singular source_exp );</p></blockquote><h1 id="4-问答题"><a href="#4-问答题" class="headerlink" title="4. 问答题"></a>4. 问答题</h1><p><strong>1. 用bit key =0来实现的类似旗语(semaphore)的功能，来保护对共享资源的访问，是否有不安全的地方?示例代码如下(包含自然语言表征)。如果有不安全的地方，请用文字表述，并且对以下代码进行修改，并且进行测试、编译和仿真打印消息。</strong></p><blockquote><p>bit key = 1;//创建钥匙<br>task get_key();<br>wait(key &gt; 0);<br>key = 0;//获得钥匙<br>…//省略对于共享资源的处理<br>key = 1; /还回钥匙<br>endtask</p></blockquote><p><span style="background:rgba(240, 200, 0, 0.2)">答</span>：当多个task并行执行时，只要key=1，满足wait(key&gt;0)即可执行，无法实现资源同时只能被指定个数的进程访问的目的。</p><p><strong>2. SV的原生旗语semaphore在例化以后，并不能从其获取哪一个对象（字符串stringID)获取了钥匙，那么请你将semaphore封装到一个类中，重新定义get()/put(方法，并且通过最后的一个打印函数来得知当前获取钥匙的string ID是谁?示例代码大致如下，请完成提示需要完成的地方，对你的代码进行编译和仿真，展示你的代码和仿真的打印消息。</strong><br><span style="background:rgba(240, 200, 0, 0.2)">答</span>：sv代码如下</p><pre class=" language-systemverilog"><code class="language-systemverilog">module tb;class smart_key;    semaphore s;//创建旗语    string holder;    function new(N= 1);        s = new(N);//分配1把钥匙    endfunction        task get(int N= 1,string str);//请添加需要的参数，并且实现该方法        s.get();//拿到钥匙        holder = str;        #1ns;        //$display("%0t: %s get the key",$time,str);    endtask    task put(int N= 1,string str);//请添加需要的参数，并且实现该方法        s.put();//放回钥匙        #1ns;        //$display("%0t: %s put the key",$time,str);    endtask    function void print_key_holders();//请事先该方法，使其能够打印出当前获得钥匙的ID        $display("%0t: now %s hold the key",$time,holder);    endfunction        endclass: smart_key    initial begin    smart_key skey = new();        string string1 = "A";    string string2 = "B";    string string3 = "C";        fork         begin             skey.get(1,string1);            skey.print_key_holders();            skey.put(1,string1);        end        begin             skey.get(1,string2);            skey.print_key_holders();            skey.put(1,string2);        end        begin             skey.get(1,string3);            skey.print_key_holders();            skey.put(1,string3);        end    joinend    endmodule: tb</code></pre><p><strong>仿真结果：</strong></p><blockquote><p>1000: now A hold the key<br>2000: now B hold the key<br>3000: now C hold the key</p></blockquote><p><strong>3. 我们在使用信箱mailbox时，如何可以限定其容量为8，并且只能存放string类型呢?那么，是否类似的方法也可以限定一个存放字符串的队列其最大容量为8呢?</strong><br><span style="background:rgba(240, 200, 0, 0.2)">答</span>：声明方法如下</p><blockquote><p>mailbox #(int) mb;<br>mb = new(8);</p></blockquote><p>队列空间是动态的，不能限定其最大容量。</p><p><strong>写的不错，可以参考</strong>：<a href="https://blog.csdn.net/qq_41337361/article/details/122723681?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-122723681-blog-78677789.pc_relevant_aa2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-122723681-blog-78677789.pc_relevant_aa2&amp;utm_relevant_index=2">SV学习笔记—线程之间的通信（事件event、信箱mailbox、旗语semaphore）_Verification_White的博客-CSDN博客_sv event</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文思维导图如下：&lt;br&gt;&lt;img src=&quot;https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211071641178.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;1-线程控</summary>
      
    
    
    
    <category term="数字IC" scheme="https://www.daipeihong.top/categories/%E6%95%B0%E5%AD%97IC/"/>
    
    
    <category term="数字前端" scheme="https://www.daipeihong.top/tags/%E6%95%B0%E5%AD%97%E5%89%8D%E7%AB%AF/"/>
    
    <category term="SystemVerilog验证" scheme="https://www.daipeihong.top/tags/SystemVerilog%E9%AA%8C%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>SystemVerilog实验(一)</title>
    <link href="https://www.daipeihong.top/2022/11/05/systemverilog-shi-yan-yi/"/>
    <id>https://www.daipeihong.top/2022/11/05/systemverilog-shi-yan-yi/</id>
    <published>2022-11-05T14:08:00.000Z</published>
    <updated>2022-11-06T02:20:18.526Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、实验要求"><a href="#一、实验要求" class="headerlink" title="一、实验要求"></a>一、实验要求</h1><p><a href="https://shimo.im/docs/axk6MwD8D8IpFeqr/read">路科验证V0课程实验指导 (shimo.im)</a></p><h1 id="二、实验代码"><a href="#二、实验代码" class="headerlink" title="二、实验代码"></a>二、实验代码</h1><h2 id="router-io-sv"><a href="#router-io-sv" class="headerlink" title="router_io.sv"></a>router_io.sv</h2><pre class=" language-systemverilog"><code class="language-systemverilog">//定义接口，将复位信号(test.sv产生)送入DUT(router.v)interface router_io(input bit clock);    logic reset_n;    logic [15:0] din;    logic [15:0] frame_n;    logic [15:0] valid_n;    logic [15:0] dout;    logic [15:0] valido_n;    logic [15:0] busy_n;    logic [15:0] frameo_n;endinterface</code></pre><h2 id="test-sv"><a href="#test-sv" class="headerlink" title="test.sv"></a>test.sv</h2><pre class=" language-systemverilog"><code class="language-systemverilog">//产生复位信号,复位时，reset_n为低电平,frame_n和valid_n为高电平module test(router_io intf);    initial begin     #2 intf.reset_n = 1'b1;    #2 intf.reset_n = 1'b0;    #2 intf.reset_n <= 1'b1;//复位信号持续2  end  initial begin        reset();//调用reset产生复位信号    end        task reset();    //@(posedge intf.clk or negedge intf.reset_n);    @(negedge intf.reset_n);      intf.din <= 0;          intf.frame_n <= '1;          intf.valid_n <= '1;           repeat(15) @(intf.clock);//复位后至少等待15个时钟周期后发送数据    endtaskendmodule</code></pre><h2 id="router-test-top-sv"><a href="#router-test-top-sv" class="headerlink" title="router_test_top.sv"></a>router_test_top.sv</h2><pre class=" language-systemverilog"><code class="language-systemverilog">//产生时钟//例化另外三个文件`timescale 1ns/1psmodule router_test_top;        bit clk;  parameter cicle = 10;    initial begin        forever #(cicle/2) clk = !clk;//产生周期为10的时钟    end        router_io intf(                    .clock(clk)                    );//例化接口                        test tb(intf);//例化test，产生复位信号        router dut(                .clock   (intf.clock   ),                .reset_n (intf.reset_n ),                .din     (intf.din     ),                .frame_n (intf.frame_n ),                .valid_n (intf.valid_n ),                .dout    (intf.dout    ),                .valido_n(intf.valido_n),                .busy_n  (intf.busy_n  ),                .frameo_n(intf.frameo_n)                );//例化router为DUTendmodule</code></pre><h1 id="三、硬件层次"><a href="#三、硬件层次" class="headerlink" title="三、硬件层次"></a>三、硬件层次</h1><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211061008531.png"></p><h1 id="四、仿真结果"><a href="#四、仿真结果" class="headerlink" title="四、仿真结果"></a>四、仿真结果</h1><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211061003883.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、实验要求&quot;&gt;&lt;a href=&quot;#一、实验要求&quot; class=&quot;headerlink&quot; title=&quot;一、实验要求&quot;&gt;&lt;/a&gt;一、实验要求&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://shimo.im/docs/axk6MwD8D8IpFeqr/read&quot;&gt;</summary>
      
    
    
    
    <category term="数字IC" scheme="https://www.daipeihong.top/categories/%E6%95%B0%E5%AD%97IC/"/>
    
    
    <category term="数字前端" scheme="https://www.daipeihong.top/tags/%E6%95%B0%E5%AD%97%E5%89%8D%E7%AB%AF/"/>
    
    <category term="SystemVerilog验证" scheme="https://www.daipeihong.top/tags/SystemVerilog%E9%AA%8C%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>SystemVerilog课程进度总览（持续更新）</title>
    <link href="https://www.daipeihong.top/2022/11/05/systemverilog-ke-cheng-jin-du-zong-lan-chi-xu-geng-xin/"/>
    <id>https://www.daipeihong.top/2022/11/05/systemverilog-ke-cheng-jin-du-zong-lan-chi-xu-geng-xin/</id>
    <published>2022-11-05T12:48:00.000Z</published>
    <updated>2022-11-18T04:35:52.264Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://daipeihong.top/2022/10/04/systemverilog-ke-cheng-bi-ji-san/">一、初步初步使用module和initial实现初步激励</a><br>初步TestBench平台概览</p>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211052041415.png" width="500" height="300" title=" ">        <p><a href="http://daipeihong.top/2022/10/04/systemverilog-ke-cheng-bi-ji-si/">二、继续改进</a><br><span style="background:rgba(5, 117, 197, 0.2)">改进1</span>：将initial过程块改造为task、将前一次的两个initial begin end 语句封装进task任务中<br><span style="background:rgba(5, 117, 197, 0.2)">改进2</span>：任意source_channl向任意destination_channl发送数据</p><p>初步TestBench平台概览</p>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211052041415.png" width="500" height="300" title=" ">        <p><a href="http://daipeihong.top/2022/10/17/systemverilog-ke-cheng-bi-ji-wu/">三、构建generator</a><br><span style="background:rgba(5, 117, 197, 0.2)">改进1</span>：stimulator只发送数据，构建generator产生数据发送给stimulator<br><span style="background:rgba(5, 117, 197, 0.2)">改进2</span>：来自于不同的source chnl可以并行发送<br><span style="background:rgba(5, 117, 197, 0.2)">改进3</span>：增加接口(interface)<br><span style="background:rgba(5, 117, 197, 0.2)">改进4</span>：增加组件monitor，监测输入数据和输出数据 </p><p>初步TestBench平台概览</p>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211171916069.png" width="500" height="300" title=" ">        <p><a href="http://daipeihong.top/2022/10/24/systemverilog-ke-cheng-bi-ji-liu/">四、stimulator、generator、monitor改为类、增加checker组件</a><br><span style="background:rgba(5, 117, 197, 0.2)">改进1</span>：将数据传输从结构体改造为类<br><span style="background:rgba(5, 117, 197, 0.2)">改进2</span>：将drive_chnl任务的输入改为类<br><span style="background:rgba(5, 117, 197, 0.2)">改进3</span>：将stimulator、generator、monitor改为类<br><span style="background:rgba(5, 117, 197, 0.2)">改进4</span>：增加checker组件</p><p>TestBench平台概览</p>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211171924107.png" width="500" height="300" title=" ">        <p><a href="http://daipeihong.top/2022/10/29/systemverilog-ke-cheng-bi-ji-qi/">五、利用类的继承，将多种test包含进base test中</a><br><span style="background:rgba(5, 117, 197, 0.2)">改进1</span>：利用类的继承，将多种test包含进base test中<br><span style="background:rgba(5, 117, 197, 0.2)">改进2</span>：增加数据传输完成信号、checker的判断、test name<br><span style="background:rgba(5, 117, 197, 0.2)">改进3</span>：package封装与makefile的使用<br>TestBench平台概览</p>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211171924107.png" width="500" height="300" title=" ">        <p>TODO：</p><p>[[SystemVerilog课程笔记(八)]]</p><p>[[SystemVerilog课程笔记(九)]]</p><p>[[SystemVerilog课程笔记(十)]]</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://daipeihong.top/2022/10/04/systemverilog-ke-cheng-bi-ji-san/&quot;&gt;一、初步初步使用module和initial实现初步激励&lt;/a&gt;&lt;br&gt;初步TestBench平台概览&lt;/p&gt;

   </summary>
      
    
    
    
    <category term="数字IC" scheme="https://www.daipeihong.top/categories/%E6%95%B0%E5%AD%97IC/"/>
    
    
    <category term="数字前端" scheme="https://www.daipeihong.top/tags/%E6%95%B0%E5%AD%97%E5%89%8D%E7%AB%AF/"/>
    
    <category term="SystemVerilog验证" scheme="https://www.daipeihong.top/tags/SystemVerilog%E9%AA%8C%E8%AF%81/"/>
    
    <category term="总结" scheme="https://www.daipeihong.top/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>SystemVerilog学习笔记(八)</title>
    <link href="https://www.daipeihong.top/2022/11/01/systemverilog-xue-xi-bi-ji-ba/"/>
    <id>https://www.daipeihong.top/2022/11/01/systemverilog-xue-xi-bi-ji-ba/</id>
    <published>2022-11-01T03:53:00.000Z</published>
    <updated>2022-11-02T14:47:27.287Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211022245932.png"></p><h2 id="如何简单产生一个随机常数"><a href="#如何简单产生一个随机常数" class="headerlink" title="如何简单产生一个随机常数"></a>如何简单产生一个随机常数</h2><h3 id="randomize"><a href="#randomize" class="headerlink" title="$randomize"></a>$randomize</h3><h3 id="urandom"><a href="#urandom" class="headerlink" title="$urandom"></a>$urandom</h3><p>$urandom()，可以生成一个32位的无符号随机数。<br>$urandom_range(maxval, minval=0)，可以生成间与maxval与minval之间的数。</p><blockquote><p>val = $urandom_range(7,0)； //结果是[0,7]<br>val = $urandom_range(0,7);   //如果mixval比minval小，参数列表会自动反向<br>val = $urandom_range(7);       //如果minval没有指定，默认为0</p></blockquote><h2 id="系统而有机地组织随机变量"><a href="#系统而有机地组织随机变量" class="headerlink" title="系统而有机地组织随机变量"></a>系统而有机地组织随机变量</h2><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>以上独立地生成一些随机数，在面向DUT的随机激励发生过程中，为了符合协议、满足测试需求，还需要添加一些”约束”。这些”约束”会使得变量朝着希望他们变化的方向去随机。不但如此，这些约束也会对变量与变量之间的关系生效。</p><h3 id="约束的载体"><a href="#约束的载体" class="headerlink" title="约束的载体"></a>约束的载体</h3><p>因此，我们需要一个”载体”去容纳这些变量以及它们之间的约束。这个”载体”即是类，而类的成员变量均可声明为”随机”属性，用rand或者randc来表示。</p><h3 id="随机变量"><a href="#随机变量" class="headerlink" title="随机变量"></a>随机变量</h3><p>任何类中的<span style="background:#d3f8b6">整形(bit/byte/int)变量</span>都可以声明为rand/randc。<br><span style="background:#d3f8b6">定长数组、动态数组、关联数组和队列</span>都可以声明为rand/randc，可以对动态数组和队列的长度加以约束。<br><span style="background:#d3f8b6">指向对象的句柄成员</span>，也可以声明为rand(不能被声明为randc) ，随机时该句柄指向对象中的随机变量也会一并被随机。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211011751369.png"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211022220922.png"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211022221417.png"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211022222796.png"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211022222514.png"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211011754978.png"></p><h2 id="约束块"><a href="#约束块" class="headerlink" title="约束块"></a>约束块</h2><p>有用的激励不仅仅是随机值，<span style="background:rgba(240, 200, 0, 0.2)">变量之间也有着相互关系</span>。没有约束的随机变量会包含许多无效的和非法的值，这会使得有效激励的产生</p><h3 id="设置取值范围"><a href="#设置取值范围" class="headerlink" title="设置取值范围"></a>设置取值范围</h3><p>约束块支持整形通过set操作符来设置它们的可取值范围。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211011759261.png" alt="|500"></p><h3 id="权重"><a href="#权重" class="headerlink" title="权重"></a>权重</h3><p>除了成员集合设置，约束块也支持设置可取值的同时也为其设置随机时的权重。<br> <span style="background:rgba(240, 200, 0, 0.2)">:=</span>  操作符：表示每一个值的权重是相同的。<br> <span style="background:rgba(240, 200, 0, 0.2)"> :/ </span> 操作符：表示权重会平均分配到每一个值。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211011802842.png" alt="|500"></p><h3 id="唯一标识"><a href="#唯一标识" class="headerlink" title="唯一标识"></a>唯一标识</h3><p>unique可以用来约束一组变量，<span style="background:rgba(240, 200, 0, 0.2)">使得其在随机后变量之间不会有相同的数值。</span><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211011807987.png" alt="|500"></p><h3 id="条件约束"><a href="#条件约束" class="headerlink" title="条件约束"></a>条件约束</h3><p>使用if-else或者-&gt;操作符来表示条件约束。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211011808349.png" alt="|400"></p><h3 id="迭代约束"><a href="#迭代约束" class="headerlink" title="迭代约束"></a>迭代约束</h3><p>foreach可以用来迭代约束数组中的元素，这些数组可以是定长数组、动态数组、关联数组或者队列。<br>也可以使用数组的缩减方法做迭代约束。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211011824469.png" alt="|500"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211011825775.png" alt="|500"></p><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><h3 id="软约束"><a href="#软约束" class="headerlink" title="软约束"></a>软约束</h3><p>在没有soft描述时的约束，我们称之为硬约束，而带有soft描述的则是软约束。软约束用来指定变量的默认值和权重。如果用户在使用时，指定了外部约束对同一个变量做二次约束，或者用户定义了子类，也对同一个变量做二次约束时，那么<span style="background:rgba(240, 200, 0, 0.2)">硬约束可以”覆盖”软约束</span>，并且不会导致随机数产生的失败。</p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211012017431.png"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211012017414.png"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211012017120.png"></p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211012042971.png"></p><h3 id="内嵌约束（指向模糊）"><a href="#内嵌约束（指向模糊）" class="headerlink" title="内嵌约束（指向模糊）"></a>内嵌约束（指向模糊）</h3><p>此处x是加给f的约束，就近句柄f指向类c1，优先找这个类里面有无x<br>若要指向task参数中的x，使用 <span style="background:#fff88f">local::x</span><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211012052456.png" alt="|500"></p><h3 id="内嵌约束（指向明确）"><a href="#内嵌约束（指向明确）" class="headerlink" title="内嵌约束（指向明确）"></a>内嵌约束（指向明确）</h3><h3 id="local域指向"><a href="#local域指向" class="headerlink" title="local域指向"></a>local域指向</h3><p>之前在使用内嵌约束随机时，对于同名的变量处在不同的域中，可能会出现指向模糊的情况，之前我们已经给出了一种方法。接下来我们可以通过<span style="background:#fff88f">local::</span> 的域索引方式来明确随机变量的指向，即<u> <span style="background:#fff88f">local::</span> 指向的变量会在包含randomize()方法的对象中</u>。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211021543318.png" alt="|400"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211012109025.png" alt="|400"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211012106238.png" alt="|400"></p><h3 id="随机控制"><a href="#随机控制" class="headerlink" title="随机控制"></a>随机控制</h3><p>rand_mode可以用来使能或者禁止随机变量。<br>当随机数被禁止时，它会同为声明为随机变量的普通变量一样，不会参与到随机化过程当中。<br>从以下两个函数声明可以看到，可以就单个随机变量调用其rand_mode，或者对整个对象调用rand_mode来控制其中所有的随机变量。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211012124495.png" alt="|500"></p><h3 id="约束控制"><a href="#约束控制" class="headerlink" title="约束控制"></a>约束控制</h3><p>类似于随机控制，一些约束块或者某个类的约束块集合都可以单个控制或者集体控制。</p><blockquote><p>task object[.constraint_identifier] : :constraint_mode (bit on_off );funetion int object.constraint_identifier : : constraint_mode() ;</p></blockquote><p>可以通过约束控制函数来使能或者关闭某些约束块。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211012126652.png" alt="|500"></p><h3 id="内嵌变量控制"><a href="#内嵌变量控制" class="headerlink" title="内嵌变量控制"></a>内嵌变量控制</h3><p>在使用类的随机化函数randomize()时，如果伴有参数，那么只会随机化这些变量，而其余变量无论是否之前被声明为rand/randc，都将不会参与到随机化当中。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211012130326.png" alt="|500"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211012226039.png"></p><h1 id="问答题"><a href="#问答题" class="headerlink" title="问答题"></a>问答题</h1><p><strong>1.随机测试相比于定向测试，就你目前的认识，你认为有哪些优缺点?</strong><br>答：当一个项目的功能成倍增加时，编写足够多的定向测试几乎不可能。而且，定向测试很难满足检查功能完整性的要求，随机测试能够产生更加完整复杂的激励场景，去对设计进行测试。缺点：随机测试会使验证环境的复杂度提高，从环境组件上考虑不再只需要发送激励的组件，而且还包括监测器、比较<br>器等。</p><p><strong>2.产生一个随机数有哪些方法呢?请提交代码文本和仿真打印结果。</strong><br><strong>使用randomize</strong></p><pre class=" language-systemverilog"><code class="language-systemverilog">module randnum;  bit [3:0] a;  bit [3:0] b;    initial begin    $display("before randomized a = %0d b = %0d",a,b);    std::randomize (a,b);    $display("after  randomized a = %0d b = %0d",a,b);  endendmodule</code></pre><p>仿真结果：</p><blockquote><p>before randomized a =0 b=0<br>after    randomized a= 4 b = 14</p></blockquote><p><strong>使用系统函数$urandom</strong></p><pre class=" language-systemverilog"><code class="language-systemverilog">module randnum;  bit [3:0] a;  bit [3:0] b;   initial begin    $display("before randomized a = %0d b = %0d",a,b);     b = $urandom();     a = $urandom_range(0,10);    $display("after  randomized a = %0d b = %0d",a,b);  endendmodule</code></pre><p>仿真结果</p><blockquote><p>before randomized a = 0 b = 0<br>after    randomized a = 6 b = 6</p></blockquote><p><strong>3.如何用rand bit [15:0]向量产生一个随机实数?请提交代码文本和仿真打印结果。</strong></p><p><strong>4.如何用rand bit[7:0] arr[8]通过约束块(不用unique来约束)产生一个元素各不相同的数组?请提交代码文本和仿真打印结果。</strong></p><p><strong>5.请仿真以下代码并且解释仿真结果。</strong></p><pre class=" language-systemverilog"><code class="language-systemverilog">module tb;    class randnum;        rand bit[3:0] x, y;    endclassinitial begin    randnum rn = new();    int x = 5, y=7;    for(int loop = 0; loop < 10; loop++) begin    rn.randomize() with {x < y;};    $display("LOOP-%0d:: CONSTRAINT{x<y;}\n rn.x = %0d, rn.y = %0d", loop, rn.x, rn.y);    rn.randomize() with {x < this.y;};    $display("LOOP-%0d: CONSTRAINT {x<this.y;}\n rn.x = %0d, rn.y = %0d", loop, rn.x, rn.y);    rn.randomize() with {x < local::y;};    $display("LOOP-%0d:: CONSTRAINT{x<local::y;}\n rn.x = %0d, rn.y = %0d", loop, rn.x,rn.y);    endendendmodule</code></pre><p><strong>分析：</strong><br>y——指向rand bit[3:0] y中的y（就近原则，rn指向randnum这个类，此处y指向randnum这个要被随机化的类里面的y），所以每次随机后的x小于每次随机后的y即可。<br>this.y——同上<br>local::y——指向y=7（local::指向的变量y会在包含randomize()方法的对象rn中），所以每次随机后x小于7即可。</p><blockquote><p>仿真结果<br>LOOP-0:: CONSTRAINT{x&lt;y;}<br>rn.x = 4, rn.y = 6<br>LOOP-0: CONSTRAINT {x&lt;this.y;}<br>rn.x = 5, rn.y = 15<br>LOOP-0:: CONSTRAINT{x&lt;local::y;}<br>rn.x = 5, rn.y = 1</p><p>LOOP-1:: CONSTRAINT{x&lt;y;}<br>rn.x = 2, rn.y = 11<br>LOOP-1: CONSTRAINT {x&lt;this.y;}<br>rn.x = 0, rn.y = 4<br>LOOP-1:: CONSTRAINT{x&lt;local::y;}<br>rn.x = 4, rn.y = 7</p><p>LOOP-2:: CONSTRAINT{x&lt;y;}<br>rn.x = 8, rn.y = 13<br>LOOP-2: CONSTRAINT {x&lt;this.y;}<br>rn.x = 7, rn.y = 8<br>LOOP-2:: CONSTRAINT{x&lt;local::y;}<br>rn.x = 6, rn.y = 13</p><p>LOOP-3:: CONSTRAINT{x&lt;y;}<br>rn.x = 2, rn.y = 15<br>LOOP-3: CONSTRAINT {x&lt;this.y;}<br>rn.x = 4, rn.y = 6<br>LOOP-3:: CONSTRAINT{x&lt;local::y;}<br>rn.x = 0, rn.y = 15</p><p>LOOP-4:: CONSTRAINT{x&lt;y;}<br>rn.x = 11, rn.y = 15<br>LOOP-4: CONSTRAINT {x&lt;this.y;}<br>rn.x = 2, rn.y = 5<br>LOOP-4:: CONSTRAINT{x&lt;local::y;}<br>rn.x = 4, rn.y = 10</p><p>LOOP-5:: CONSTRAINT{x&lt;y;}<br>rn.x = 6, rn.y = 10<br>LOOP-5: CONSTRAINT {x&lt;this.y;}<br>rn.x = 7, rn.y = 10<br>LOOP-5:: CONSTRAINT{x&lt;local::y;}<br>rn.x = 3, rn.y = 3</p><p>LOOP-6:: CONSTRAINT{x&lt;y;}<br>rn.x = 0, rn.y = 12<br>LOOP-6: CONSTRAINT {x&lt;this.y;}<br>rn.x = 9, rn.y = 13<br>LOOP-6:: CONSTRAINT{x&lt;local::y;}<br>rn.x = 3, rn.y = 0</p><p>LOOP-7:: CONSTRAINT{x&lt;y;}<br>rn.x = 0, rn.y = 1<br>LOOP-7: CONSTRAINT {x&lt;this.y;}<br>rn.x = 4, rn.y = 6<br>LOOP-7:: CONSTRAINT{x&lt;local::y;}<br>rn.x = 5, rn.y = 13</p><p>LOOP-8:: CONSTRAINT{x&lt;y;}<br>rn.x = 0, rn.y = 12<br>LOOP-8: CONSTRAINT {x&lt;this.y;}<br>rn.x = 11, rn.y = 14<br>LOOP-8:: CONSTRAINT{x&lt;local::y;}<br>rn.x = 0, rn.y = 15</p><p>LOOP-9:: CONSTRAINT{x&lt;y;}<br>rn.x = 3, rn.y = 15<br>LOOP-9: CONSTRAINT {x&lt;this.y;}<br>rn.x = 1, rn.y = 14<br>LOOP-9:: CONSTRAINT{x&lt;local::y;}<br>rn.x = 0, rn.y = 8</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211022245932.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;如何简单产生一个随机常数&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="数字IC" scheme="https://www.daipeihong.top/categories/%E6%95%B0%E5%AD%97IC/"/>
    
    
    <category term="数字前端" scheme="https://www.daipeihong.top/tags/%E6%95%B0%E5%AD%97%E5%89%8D%E7%AB%AF/"/>
    
    <category term="SystemVerilog验证" scheme="https://www.daipeihong.top/tags/SystemVerilog%E9%AA%8C%E8%AF%81/"/>
    
    <category term="随机约束" scheme="https://www.daipeihong.top/tags/%E9%9A%8F%E6%9C%BA%E7%BA%A6%E6%9D%9F/"/>
    
  </entry>
  
  <entry>
    <title>文献调研——星载计算机单粒子效应故障注入仿真</title>
    <link href="https://www.daipeihong.top/2022/10/30/wen-xian-diao-yan-xing-zai-ji-suan-ji-dan-li-zi-xiao-ying-gu-zhang-zhu-ru-fang-zhen/"/>
    <id>https://www.daipeihong.top/2022/10/30/wen-xian-diao-yan-xing-zai-ji-suan-ji-dan-li-zi-xiao-ying-gu-zhang-zhu-ru-fang-zhen/</id>
    <published>2022-10-30T14:57:00.000Z</published>
    <updated>2022-11-02T15:01:29.388Z</updated>
    
    <content type="html"><![CDATA[<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><p>OBC——星载计算机（On-Board Computer，OBC）<br>SIP——系统级封装</p><h1 id="空间环境中的辐射效应"><a href="#空间环境中的辐射效应" class="headerlink" title="空间环境中的辐射效应"></a>空间环境中的辐射效应</h1><h2 id="总剂量效应"><a href="#总剂量效应" class="headerlink" title="总剂量效应"></a>总剂量效应</h2><h2 id="单粒子效应"><a href="#单粒子效应" class="headerlink" title="单粒子效应"></a>单粒子效应</h2><h1 id="抗辐照性能的评估方法"><a href="#抗辐照性能的评估方法" class="headerlink" title="抗辐照性能的评估方法"></a>抗辐照性能的评估方法</h1><h2 id="空间环境实验"><a href="#空间环境实验" class="headerlink" title="空间环境实验"></a>空间环境实验</h2><p>空间环境实验以及地面模拟等效实验都有几个很明显的缺点：首先是需要搭建实验评估环境，致使试验成本升高；其次是需要对待评估的模块进行流片试产，如果辐照评估出现问题就会重新调试生产，导致设计周期变长；最后是在实验中观察到单粒子效应后，对系统的错误定位也是目前的技术难点。</p><h2 id="地面模拟等效实验"><a href="#地面模拟等效实验" class="headerlink" title="地面模拟等效实验"></a>地面模拟等效实验</h2><p>随着SiP 封装技术在航天星载计算机设计领域的普及，需要对SiP 封装的芯片进行  辐射效应评估，由于地面实验的加速器粒子能量不够，导致在进行地面辐照试验时难以穿透SiP 封装腔体，所以不能有效的对系统进行评估。</p><h2 id="计算机数值模拟仿真"><a href="#计算机数值模拟仿真" class="headerlink" title="计算机数值模拟仿真"></a>计算机数值模拟仿真</h2><p>而使用计算机仿真技术对星载计算机系统进行抗辐照性能评估，使得设计人员能在设计初期对系统可靠性有准确把握。使用计算机仿真软件可以对空间粒子在器件上的作用机理进行模拟仿真，具有效率高、成本低和效果好等诸多优点。</p><h1 id="单粒子效应仿真方法"><a href="#单粒子效应仿真方法" class="headerlink" title="单粒子效应仿真方法"></a>单粒子效应仿真方法</h1><h2 id="器件级仿真"><a href="#器件级仿真" class="headerlink" title="器件级仿真"></a>器件级仿真</h2><p>器件级单粒子效应仿真是通过 TCAD 仿真工具对器件或者小型电路进行建模，通过求解三大方程得到精确的器件模型。最后来模拟空间环境对器件模型产生的辐照效应，以实现对单粒子效应进行分析，是目前业内单粒子效应机理研究方向的主要仿真方法。</p><h2 id="电路级仿真"><a href="#电路级仿真" class="headerlink" title="电路级仿真"></a>电路级仿真</h2><p>电路级单粒子效应仿真忽略了器件底层的物理细节，更加偏重晶体管层面的仿真，通过用SPICE 工具支持的语法描述单粒子脉冲，实现对电路的单粒子效应故障注入。是研究模拟电路以及小规模数字电路单粒子效应的主流仿真手段。</p><h2 id="逻辑门级仿真"><a href="#逻辑门级仿真" class="headerlink" title="逻辑门级仿真"></a>逻辑门级仿真</h2><p>逻辑门级仿真主要是通过预设网表中每个逻辑门的单位时间故障（Failure in Time，FIT），然后分析Verilog 门级网表结构，从而得到整个门级网表的FIT 和软错误率，这种仿真方法有着计算速度快，支持电路规模大的特点。</p><h2 id="RTL-级仿真"><a href="#RTL-级仿真" class="headerlink" title="RTL 级仿真"></a>RTL 级仿真</h2><p>RTL 级故障注入仿真对电路系统的 RTL 级模型进行仿真，由于仿真方法的模型层次较高因此仿真速度也最快。</p><h1 id="星载计算机系统"><a href="#星载计算机系统" class="headerlink" title="星载计算机系统"></a>星载计算机系统</h1><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210272021408.png" alt="|500"><br>通过SiP 封装技术，将系统各模块封装在两个腔体中，其中<font color="#ffc000">腔体1</font> <u>中包括了3 片SRAM 芯片以及两片Flash 芯片</u>，而<font color="#ffc000">腔体2</font> <u>中包括了2 片SRAM 芯片、一片Flash 芯片以及处理器芯片</u>。系统使用倒装技术，片间用金键合丝以及TSV 等技术实现系统互连。</p><ul><li>处理器模块是基于SPARC V8 指令集架构的开源LEON处理器进行开发设计，该模块<u>在系统中负责对外设的控制与通信，程序的读取与执行</u>，是系统的核心。</li><li><u>Flash 与部分SRAM 模块负责程序指令的存储</u>，</li><li><u>其余SRAM 模块负责保存系统的运行数据</u>。</li></ul><p>当系统上电后，处理器先读取保存在Flash 中的boot 初始化程序，对系统寄存器等模块初始化之后，将后续执行的程序，从Flash 转存至指令SRAM中，随后地址跳转到指令SRAM 进行程序的取指、译码、执行、访存、回写等操作。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210272105446.png" alt="|500"></p><p>SRAM的加固 ^a9ac5d</p><p>对存有初始化程序的 Flash，以及存有指令的 SRAM  进行了模块级的三模冗余（Triple Modular Redundancy，TMR）加固设计。<br>加固设计后的目标系统结构就变为下图<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210272109479.png" alt="|500"><br>在为星载计算机系统存入程序时，对<u>三块 Flash 和指令 SRAM 都存储相同的程序</u>，这样在收到外部读取请求信号时，存储器的输出端口中所有数据位都先会通过三输入表决器后再输出到数据总线，从而提高了系统在辐照环境下的工作稳定性。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210291457431.png"><br>采用ECC算法进行SRAM加固模块如下<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210300843699.png"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210300845185.png" alt="|600"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210300847213.png"> ^df961a</p><h1 id="星载计算机系统模型的搭建"><a href="#星载计算机系统模型的搭建" class="headerlink" title="星载计算机系统模型的搭建"></a>星载计算机系统模型的搭建</h1><h2 id="leon2处理器建模（管级网表的提取）"><a href="#leon2处理器建模（管级网表的提取）" class="headerlink" title="leon2处理器建模（管级网表的提取）"></a>leon2处理器建模（管级网表的提取）</h2><p>想要对OBC-SiP 系统进行单粒子效应仿真，首先就必须得到OBC-SiP 的系统模型。</p><p>Leon2 开源代码由可综合的超高速集成电路硬件描述语言（VHDL）代码构成，为了建立 Leon2  处理器的 SPICE 电路模型并进行单粒子效应仿真，需要将 Leon2 处理器寄存器传输 级（RTL）的 VHDL 代码转换为 SPICE 描述的晶体管级网表，<br>需要如下两个步骤：<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210271629166.png"></p><h3 id="DC综合"><a href="#DC综合" class="headerlink" title="DC综合"></a>DC综合</h3><ul><li><strong>转换</strong><br>综合工具首先会将 Leon2 处理器的 VHDL 的描述转换成一个与工艺独立的 RTL 级网表(网表中 RTL 模块通过连线互联)。</li><li><strong>映射</strong><br>然后根据具体指定的工艺库,将 RTL 级网表映射到工艺库上,成为一个门级网表。</li><li><strong>优化</strong><br>最后再根据设计者施加的诸如延时、面积方面的约束条件,对门级网表进行优化。<blockquote><p>[!info]+ DC综合<br>Synopsys 公司的DC（Design Compiler）是目前业内使用最广泛的电路综合工具，可以很方便地将硬件描述语言的可综合代码设计转换到基于标准单元库的门级网表。<br>DC 主要包括<span style="background:rgba(240, 200, 0, 0.2)">转换(translation)</span>、<span style="background:rgba(240, 200, 0, 0.2)">映射(mapping)</span>及<span style="background:rgba(240, 200, 0, 0.2)">优化(optimization)</span>三个步骤。<br>综合工具首先将电路设计代码设计读入内存，用“gtech.db”库中的基本单元将设计转换为基本电路，然后根据综合人员给定的约束设置，对电路性能、面积等参数进行计算并优化，然后将优化之后的电路映射到用户设定的工艺库上<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210261019502.png" alt="|500"></p></blockquote></li></ul><h3 id="管级网表转换"><a href="#管级网表转换" class="headerlink" title="管级网表转换"></a>管级网表转换</h3><p>Mentor 公司提供的<span style="background:rgba(240, 200, 0, 0.2)"> Calibre工具</span>在数字 IC 后端设计中具有广泛的应用。其中 <span style="background:rgba(240, 200, 0, 0.2)">v2lvs命令</span>可以将 DC 综合生成的门级网表转换为 SPICE 管级网表，为后续的处理器故障注入仿真提供基础文件。</p><blockquote><p>[!info]+ 管级网表转换<br>Mentor Graphics 公司的Calibre 工具在IC 后端设计中必不可少，其中Calibre 中的v2lvs 命令能够很方便的将Verilog 的门级网表转换成我们所需要的SPICE 管级网表<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210261023891.png" alt="|500"></p></blockquote><h2 id="存储器模块建模"><a href="#存储器模块建模" class="headerlink" title="存储器模块建模"></a>存储器模块建模</h2><h3 id="Flash模块建模"><a href="#Flash模块建模" class="headerlink" title="Flash模块建模"></a>Flash模块建模</h3><p>Flash 主要器件结构是浮栅晶体管等特殊器件，由于其工艺的特殊性，无法建立该模块的SPICE 晶体管级模型，因此只对Flash 模块进行行为级建模。</p><h3 id="SRAM-模块建模"><a href="#SRAM-模块建模" class="headerlink" title="SRAM 模块建模"></a>SRAM 模块建模</h3><p>SRAM 模块内部由多个子模块组成，可以大致分为：存储单元电路模块、逻辑接口电路模块、行译码电路模块、列译码器和灵敏放大器电路模块几个部分。存储器设计流程与上文中LEON2 处理器设计流程不同，并且灵敏放大器电路等模块和存储单元等模块使用工艺不同，无法按照“DC 综合-管级网表转换”这样的流程来进行建模。<u>采用 Memory Compiler 工具，直接生成其行为级模型和 SPICE 管级模型</u></p><h1 id="SiP-互连建模"><a href="#SiP-互连建模" class="headerlink" title="SiP 互连建模"></a>SiP 互连建模</h1><p>单根金丝可以用图示的简化模型进行电路等效<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210272114894.png" alt="|500"><br>在对系统各模块进行连接时，依据项目组提供资料，为键合金丝的等效模型选择合适的寄生参数，在SPICE 网表中将系统各模块的端口进行连接。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210272116911.png" alt="|500"></p><h2 id="星载计算机系统模型构建（-Leon2-处理器-外部电路）"><a href="#星载计算机系统模型构建（-Leon2-处理器-外部电路）" class="headerlink" title="星载计算机系统模型构建（ Leon2 处理器+外部电路）"></a>星载计算机系统模型构建（ Leon2 处理器+外部电路）</h2><p>完成了 OBC-SiP 系统中各模块电路的建模工作之后，就可以对整个目标系统进行模型搭建。依据LEON2 处理器中的可编程存储器控制器设计要求，以及各存储模块的读写时序，通过连线将各模块进行连接，最终得到整个OBC-SiP 目标系统模型。<br>根据获得的 Leon2 处理器 SPICE 管级网表模型，对其进行外部电路扩展，构成一个小型的星载计算机系统模型，在该模型中存在以下几个模块：①Leon2 处理器核；②指令 SRAM 模块；③数据 SRAM 模块；④初始化指令 SRAM 模块。</p><h1 id="单粒子效应故障注入技术"><a href="#单粒子效应故障注入技术" class="headerlink" title="单粒子效应故障注入技术"></a>单粒子效应故障注入技术</h1><p>对于故障注入技术，按照注入的电路层次不同，可以分为硬件故障注入，软件故障注入，RTL 级故障注入与 SPICE 网表故障注入等。</p><h2 id="软件层次故障注入技术"><a href="#软件层次故障注入技术" class="headerlink" title="软件层次故障注入技术"></a>软件层次故障注入技术</h2><p>软件故障注入技术是在软件层次来实现处理器的故障注入方法，在处理器程序编译或者运行时动态的修改执行程序，或者人为设置寄存器值来改变处理器的运行状态。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>成本低，故障注入位置灵活可控，具有相当高的自由性。</li><li>可通过脚本或者程序可以实现批量的故障注入操作，完成故障注入的全自动化设置。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>只能对计算机体系结构中可配置的寄存器进行故障注入设置，无法对不可配置部分进行故障注入，具有局限性，无法实现对整体芯片的抗辐射可靠性评估。</li><li>软件层次注入一般只对寄存器进行注入，无法精确模拟单粒子效应的实际注入情况，如注入组合逻辑模块等。</li><li>故障注入技术一般需要添加一段额外的处理器程序如故障注入控制程序，结果收集及分析模块等，因此需要确保额外的程序不会影响到原本处理器的正常工作且不会对故障注入结果造成干扰，这通常是难以精确控制的。</li></ul><h2 id="硬件层次故障注入技术"><a href="#硬件层次故障注入技术" class="headerlink" title="硬件层次故障注入技术"></a>硬件层次故障注入技术</h2><p>硬件层次的故障注入是在芯片流片后后进行是对实际的处理器芯片进行故障注入，通用的方法主要有引脚级注入法、重离子加速注入法、激光注入法以及电源电压注入法等，这是最接近于实际的故障环境。</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>采用对实际芯片进行故障注入的方式来分析芯片的抗单粒子效应能力，可以在实际的处理器芯片中触发瞬态故障，翻转故障等，这是最贴近于实际情况的故障注入方式。</p><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>需要昂贵的硬件设备，如离子加速器造价昂贵，且资源紧张*</li><li>硬件层次的故障注入极有可能会对芯片造成损伤，代价高昂，增加了设计成本。</li><li>该层次的故障注入对象为实体芯片，必须等芯片流片后才能进行故障注入，增加了芯片的设计与制造周期。</li><li>难以将故障注入技术实现全自动化，因为芯片级的故障注入需要相当数量的故障次数才能使故障注入分析结果具有统计意义，这需要耗费大量的时间。</li><li>难以精确定位引起芯片运行错误的故障注入点。</li></ul><h2 id="RTL-层次故障注入技术"><a href="#RTL-层次故障注入技术" class="headerlink" title="RTL 层次故障注入技术"></a>RTL 层次故障注入技术</h2><p>RTL 级故障注入技术是针对系统电路的行为级模型进行故障注入，其通常用硬件描述语言如 VHDL，verilog HDL 来实现。</p><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul><li>硬件描述语言具有对电路良好的建模与抽象功能，可以从不同的抽象级别来对处理器内部各个模块进行单粒子效应故障注入，如行为级故障注入仿真，逻辑门级故障注入仿真。</li><li>在 RTL级可以精确地对每个逻辑门或者接口信号进行数值仿真与分析，所以可以精确地控制故障注入的注入时间，注入位置等，更加有利于监控单粒子注入后处理器系统的故障行为。</li><li>在电路设计阶段就能进行故障注入与单粒子效应敏感性分析。根据分析结果就可以在设计阶段采取相应的加固措施来提高处理器的抗辐射能力，因此降低了抗辐射电路的设计成本与与设计周期，有效地加快了抗辐射芯片的研发速度。</li></ul><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><p>verilog HDL 等硬件描述语言进行建模的电路属于数字电路，只有 0 与 1 两种工作状态，对应于模拟电路中的高低电平两种状态。使用 RTL 级故障注入技术忽略了单粒子效应的底层物理细节，只是单纯的改变电路的工作状态。而高能粒子入射期间后引发的瞬态脉冲电流有可能位于高低电平之间的中间区域，RTL 级故障注入技术无法精确地对这种类型的粒子入射进行模拟入射。</p><h2 id="SPICE-层次网表故障注入技术"><a href="#SPICE-层次网表故障注入技术" class="headerlink" title="SPICE 层次网表故障注入技术"></a>SPICE 层次网表故障注入技术</h2><p>SPICE 级网表故障注入技术是针对电路的管级网表模型进行仿真的。从管级网表的特征来分析，因为管级网表体现了电路晶体管的物理特性和电学特性，涉及到具体电压值的改变，不是由简单的 0 或者 1 来表示，表示方式更加准确，因此在最底层晶体管级进行故障注入是最贴近于实际情况且最精确的故障注入技术。</p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><ul><li>首先需要对目标处理器系统进行高精度的 SPICE 建模，进而建立正确的管级模型。*</li><li>需要建立准确的故障注入源，一般情况下，管级网表的故障注入源由器件级单粒子效应仿真结果得到的电流响应数据为基础，通过数学模型的拟合，可以得到不同 LET 值的瞬态脉冲电流源模型作为故障注入源。</li></ul><h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><p>贴近底层晶体管，能够更加准确实际的描述单粒子效应故障入射的情况。</p><h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><p>在仿真过程了添加了许多物理和电学特性，这导致了 SPICE 管级网表进行仿真的速度过慢，一般只支持小型集成电路。</p><h1 id="SPICE-混合仿真"><a href="#SPICE-混合仿真" class="headerlink" title="SPICE 混合仿真"></a>SPICE 混合仿真</h1><p>既考虑了器件级的仿真精度，又兼顾了电路级、RTL 级的仿真规模与速度，解决了现有方法的部分不足。</p><h2 id="单粒子脉冲注入模型建模"><a href="#单粒子脉冲注入模型建模" class="headerlink" title="单粒子脉冲注入模型建模"></a>单粒子脉冲注入模型建模</h2><p>需要通过器件级单粒子效应仿真来分析单粒子瞬态电流数据，得到单粒子效应在不同LET 条件下，产生的瞬态电流脉冲注入模型。<br>首先通过器件级离子注入仿真粒子入射MOSFET 器件电流数据，对数据进行处理，转换为符合SPICE 语法的PWL 电流源模型，最终得到不同能量粒子轰击半导体器件产生的单粒子瞬态电流脉冲注入模型</p><h2 id="提取电路敏感节点"><a href="#提取电路敏感节点" class="headerlink" title="提取电路敏感节点"></a>提取电路敏感节点</h2><p>对待注入模块的 SPICE 网表进行处理，提取出该模块的敏感节点，得到敏感节点列表文件。</p><blockquote><p>[!info]+ 电路敏感节点<br>NMOS 收集迁移率更高的电子，因此在相同入射条件，相同时间内，NMOS 总能收集更多的载流子从而产生更大的单粒子瞬态电流，体现出更强的单粒子瞬态效应。本文定义电路敏感节点为SPICE 网表中每个NMOS 晶体管的漏极。<u>本文定义电路敏感节点为SPICE 网表中每个NMOS 晶体管的漏极。</u></p></blockquote><h2 id="敏感节点故障注入"><a href="#敏感节点故障注入" class="headerlink" title="敏感节点故障注入"></a>敏感节点故障注入</h2><p>得到待注入模块网表的敏感节点列表之后，就可以对该模块的敏感节点进行单粒子随机或定点故障注入。<br>该步骤用 Perl 脚本实现，自动生成故障注入文件。通过用户设定的<span style="background:rgba(240, 200, 0, 0.2)">单粒子 LET值</span>，<span style="background:rgba(240, 200, 0, 0.2)">注入时间范围</span>，<span style="background:rgba(240, 200, 0, 0.2)">注入时间步长（纳秒）</span>，<span style="background:rgba(240, 200, 0, 0.2)">注入模块名称</span>等参数，脚本会结合待注入模块的敏感节点列表和单粒子脉冲注入模型，对脉冲电流源进行参数处理，得到包含单粒子注入信息的故障注入文件。<br><u></u></p><h2 id="SPICE-混合仿真-1"><a href="#SPICE-混合仿真-1" class="headerlink" title="SPICE 混合仿真"></a>SPICE 混合仿真</h2><p>获得单粒子瞬态脉冲电流源模型以及对待注入模块的敏感节点提取并生成故障注入文件之后，就可以使用 SPICE 仿真工具对目标系统进行单粒子效应仿真。<br>然而对于规模较大的星载计算机系统，直接使用 SPICE 仿真器进行电路级单粒子仿真，需要的仿真时间以及运算资源都会非常大。<br>因此本文（柳炜鑫论文）在电路级基础上进行改进，提出基于SPICE 混合仿真的单粒子效应仿真方法。</p><p><span style="background:rgba(136, 49, 204, 0.2)">第一步</span>，讨论单粒子注入方案，对目标系统进行模块划分。明确单粒子注入位置（<u>如整数单元、总线控制器或者SRAM 等等</u>），根据注入需求，将系统划分成各种功能模块。  </p><p><span style="background:rgba(136, 49, 204, 0.2)">第二步</span>，分别搭建系统模块不同层级的模型。完成目标系统的模块划分后，为了减小仿真中SPICE 网表的规模，本文采用的方案是<u>对待注入模块需要得到SPICE管级模型，而对于不需要进行单粒子故障注入的模块则可以建立其行为级模型或 RTL模型</u>。  </p><p><span style="background:rgba(136, 49, 204, 0.2)">第三步</span>，<u>完成接口网络（Mixed Nets）的搭建。这个模块是用于在混合信号仿真中实现模拟和数字模块之间连接的信号网络，位于模拟模块和数字模块的边界。</u>在混合仿真中，根据需要仿真器需要根据信号的传输方向，将混合信号进行 D2A 转换，以将数字逻辑值转换为模拟电压量，反之亦然。该接口网络为理想网络，D2A 转换中的默认高低电压值分别是SPICE 网表中的VDD 和0V。A2D 转换中默认的电压阈值为VDD 的50％。可以根据需要使用d2a 和a2d 命令对这些值进行修改。</p><p><span style="background:rgba(136, 49, 204, 0.2)">第四步</span>，完成系统的连接。将各模块所搭建的不同层级模型，通过接口网络实现整个目标系统的连接。</p><p><span style="background:rgba(136, 49, 204, 0.2)">第五步</span>，进行混合仿真。得到了目标系统的混合模型，就可以使用 VCS-MX 和Finesim Pro 进行仿真工作。  </p><p><span style="background:rgba(136, 49, 204, 0.2)">第六步</span>，输出仿真结果。等待仿真结束后，依据仿真网表中节点电压测量语句，会将需要观测的节点电压值通过文本的形式进行输出，最终得到单粒子效应仿真的结果。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210272139793.png" alt="|500"></p><p><strong>以OBC-SiP 目标系统模型进行单粒子效应仿真为例</strong><br>首先完成模块划分，<u>本例将处理器和 SRAM 作为待注入模块，因此系统中处理器和 SRAM 使用 SPICE 管级模型，而 Flash 模块使用行为级模型。  </u><br>然后是完成接口网络搭建，对于使用VCS-MX和Finesim Pro进行VHDL / Verilog-SPICE 的流程中，该工具会自动插入A2D 和D2A 模块。<br>接下来使用接口网络完成系统的连接；完成系统混合模型之后，输入命令提交仿真。<br>等待仿真结束，就完成了一次对 OBC-SiP 目标系统的单粒子故障注入仿真，接下来就可以对仿真器输出的结果进行仿真比对以及系统错误统计。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210262147339.png" alt="|500"></p><h1 id="柳师兄论文调研"><a href="#柳师兄论文调研" class="headerlink" title="柳师兄论文调研"></a>柳师兄论文调研</h1><h1 id="荀师兄论文调研"><a href="#荀师兄论文调研" class="headerlink" title="荀师兄论文调研"></a>荀师兄论文调研</h1><p>通过 Perl 与 Shell 脚本实现了仿真中的数据测量、结果比对等工<br>作，并针对混合仿真<u>提出了一种混合电路模块快速划分方法</u>，有效地提升了仿真效率。<br><u>提出了 SiP 系统模块级单粒子效应敏感性的仿真方案</u>；<u>采用三阶矩阵乘法的程序指令，分别针对目标 SiP 系统中的整数处理单元、寄存器堆、缓存、AMBA 总线控制器、存储控制器、指令 SRAM 和数据 SRAM 进行仿真分析</u>，发现数据 SRAM 具有 5.57%的系统软错误率，远高于系统其余模块，需要在系统抗单粒子效应加固设计时重点考虑。<br>基于 SiP 系统模块级单粒子效应敏感性的仿真方案，提出了面积等效的分析方法，进一步实现了全电路的混合仿真。</p><h1 id="吕师兄论文调研"><a href="#吕师兄论文调研" class="headerlink" title="吕师兄论文调研"></a>吕师兄论文调研</h1><p>实现了一种<u>基于断点分析的多点故障注入技术</u>，该技术在传统的单点故障注入方法基础上进行改进而来，通过在单粒子效应系统级仿真过程中加入断点的方式，在上一级仿真结果的基础上加入下一级故障注入点，这样可以有效地多次注入故障注入点，同时保证了相邻故障注入点之间的结果非相干性。<br>通过在星载计算机系统中加载矩阵乘法程序并进行 SPICE 仿真，得到在运行该程序的基础上可以实现的最小故障注入间隔时间。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;名词解释&quot;&gt;&lt;a href=&quot;#名词解释&quot; class=&quot;headerlink&quot; title=&quot;名词解释&quot;&gt;&lt;/a&gt;名词解释&lt;/h1&gt;&lt;p&gt;OBC——星载计算机（On-Board Computer，OBC）&lt;br&gt;SIP——系统级封装&lt;/p&gt;
&lt;h1 id=&quot;空间</summary>
      
    
    
    
    <category term="数字IC" scheme="https://www.daipeihong.top/categories/%E6%95%B0%E5%AD%97IC/"/>
    
    
    <category term="星载计算机" scheme="https://www.daipeihong.top/tags/%E6%98%9F%E8%BD%BD%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="单粒子效应" scheme="https://www.daipeihong.top/tags/%E5%8D%95%E7%B2%92%E5%AD%90%E6%95%88%E5%BA%94/"/>
    
    <category term="leon2处理器" scheme="https://www.daipeihong.top/tags/leon2%E5%A4%84%E7%90%86%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>SystemVerilog课程笔记(七)</title>
    <link href="https://www.daipeihong.top/2022/10/29/systemverilog-ke-cheng-bi-ji-qi/"/>
    <id>https://www.daipeihong.top/2022/10/29/systemverilog-ke-cheng-bi-ji-qi/</id>
    <published>2022-10-29T00:55:00.000Z</published>
    <updated>2022-11-18T04:53:46.951Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-利用类的继承，将多种test包含进base-test中"><a href="#1-利用类的继承，将多种test包含进base-test中" class="headerlink" title="1. 利用类的继承，将多种test包含进base test中"></a>1. 利用类的继承，将多种test包含进base test中</h1><h2 id="1-1-改进"><a href="#1-1-改进" class="headerlink" title="1.1 改进"></a>1.1 改进</h2><p>(1)将stimulator、monitor、generator、checker的例化、连接、run放入rt_env类中；<br>(2)genarator_to_stimulator的数据传输语句块放入rt_env类中的task run；<br>(3)将generate_data_proc产生数据的语句块放入对应的单通道/双通道/多通道测试的类中；</p><pre class=" language-systemverilog"><code class="language-systemverilog">class rt_env;  //rt_env包含各个组件的例化、连接、run)    ...endclass    ...endclassclass rt_base_test;//rt_base_test包含rt_env，rt_env包含各个组件    rt_env env;    ...endclassclass rt_single_ch_test extends rt_base_test;//单个通道测试    ...endclassclass rt_two_ch_test extends rt_base_test;//两个通道测试    ...endclassclass rt_two_ch_same_chout_test extends rt_two_ch_test;    ...endclassclass rt_multi_ch_test extends rt_base_test;//多个通道测试    ...endclassclass rt_full_ch_test extends rt_multi_ch_test;    ...endclass</code></pre><p>各个class层次结构如下：</p>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211181107662.png" width="500" height="350" title=" ">        <h2 id="1-2-改进后的tb-sv"><a href="#1-2-改进后的tb-sv" class="headerlink" title="1.2 改进后的tb.sv"></a>1.2 改进后的tb.sv</h2><pre class=" language-systemverilog"><code class="language-systemverilog">class rt_packet;  bit [3:0] src;  bit [3:0] dst;  bit [7:0] data [];  function new();  endfunction  function void set_members(bit [3:0]src, bit [3:0]dst, bit[7:0]data []);    this.src = src;    this.dst = dst;    this.data = data;  endfunction  function string sprint();//打印packet信息的函数    sprint = {sprint , $sformatf("src = %0d\n",src)};    sprint = {sprint , $sformatf("dst = %0d\n",dst)};    sprint = {sprint , $sformatf("data_length = %0d\n",data.size())};    foreach(data[i])        sprint = {sprint , $sformatf("data[%0d] = 'h%0x\n", i, data[i])};  endfunction  function bit compare(rt_packet p);//输入exp_pkt        if(dst == p.dst && data == p.data)            compare = 1;        else             compare = 0;  endfunctionendclassinterface rt_interface();    logic clock;    logic reset_n;    logic [15:0] din;    logic [15:0] frame_n;    logic [15:0] valid_n;    logic [15:0] dout;    logic [15:0] valido_n;    logic [15:0] busy_n;    logic [15:0] frameo_n;endinterface//********************************** stimulator **********************************//class rt_stimulator;    virtual rt_interface intf;//class里的接口不能用端口的方式描述，需要添加virtual关键字，在类里面用接口的指针//for debug purpose from waveform//定义检测状态的变量  typedef enum {DRV_RESET,DRV_IDLE,DRV_ADDR,DRV_PAD,DRV_DATA} drv_state_t;  drv_state_t dbg_state;    byte unsigned dbg_din_chnl0_data;   int src_chnl_status[int];  //关联数组，后面int：src_chnl的number；前面int：dest_chnl的Number ？？    //generator传送p给stimulator  rt_packet pkts[$];//定义stimulator中的的队列pkts  function void put_pkt(input rt_packet p);    pkts.push_back(p);//将generator中传过来的p放入stimulator的pkts中(在pkts队列尾插入p)  endfunctiontask run();    fork        drive_reset(); //reset动作        get_packet_and_drive(); //drive_chnl动作    join_noneendtask    task drive_reset();//reset    forever begin        @(negedge intf.reset_n);        dbg_state <= DRV_RESET;        intf.din <= 0;        intf.frame_n <= '1;//等效16'hFFFF        intf.valid_n <= '1;    endendtask// 发送数据task get_packet_and_drive();//drive_chnl    //rt_packet_t p;  @(negedge intf.reset_n);  repeat(10) @(posedge intf.clock);//延迟10个时钟周期  forever begin    automatic rt_packet p;//声明一个动态的    wait(pkts.size()>0);    p = pkts.pop_front();//将p从队列pkts里面取出    fork//后台触发线程，触发线程在后台运行，继续执行剩下内容        begin            wait_src_chnl_avail(p);//判断src chnl是否被占用，是否需要等待            drive_chnl(p);//从P中拿到发送端口，目标端口，发送数据            set_src_chnl_avail(p);        end    join_none    endendtasktask  wait_src_chnl_avail(rt_packet p);//判断src chnl是否被占用，是否需要等待    if(!src_chnl_status.exists(p.src))//src_chnl_status关联数组里面不含p.src，(表示未占用任何dest_chnl,一开始不满足）        src_chnl_status[p.src] = p.dst;//表示当前正在使用src_chnl,对应dest_chnl就是p.dst（p.src端口在向p.dst端口发送数据）    else if(src_chnl_status[p.src] >= 0)//如果在给0,1,2...dest_chnl发送数据（被占用），需要等待,，否则不需要等待        wait(src_chnl_status[p.src] == -1);//直到src_chnl_status[p.src] == -1(自定义的dest_chnl端口数之外任意的数，表示未占用任何dest_chnl)endtaskfunction  set_src_chnl_avail(rt_packet p);    src_chnl_status[p.src] = -1;//如果chnl发送完后，把src_chnl置回来(自定义的dest_chnl端口数之外任意的数，表示未占用任何dest_chnl)endfunctiontask  drive_chnl(rt_packet p);  $display("@%0t:[DRV] src_chnl[%0d] & dest_chnl[%0d] data trans started with packet: \n%s",$time,p.src,p.dst,p.sprint());    // drive address phase 输入地址位阶段for(int i=0;i<4;i++)begin  //4 clock  @(posedge intf.clock);  dbg_state <=DRV_ADDR;  intf.din[p.src] <= p.dst[i];  intf.valid_n[p.src] <= $urandom_range(0,1);//valid_n在din的地址输入时间段可为任意值x  intf.frame_n[p.src] <= 1'b0;//frame_n需要为低end    // drive pad phase //隔离阶段  for (int i=0;i<5;i++)begin  //5 clock    @(posedge intf.clock);    dbg_state <=DRV_PAD;    intf.din[p.src] <= 1'b1;    intf.valid_n[p.src] <= 1'b1;//valid_n需为高电平    intf.frame_n[p.src] <= 1'b0; //frame_n需为低电平  end    // drive data phase 传输数据阶段  foreach(p.data[id])begin    for(int i=0;i<8;i++)begin     @(posedge intf.clock);      dbg_state <=DRV_DATA;      dbg_din_chnl0_data <= p.data[id];      intf.din[p.src] <= p.data[id][i];      intf.valid_n[p.src] <=1'b0;      intf.frame_n[p.src] <= (id == p.data.size()-1 && i == 7) ? 1'b1 : 1'b0;//packet最后一位输出数据时frameo_n为高    end  end// drive idle phase 闲置（没有数据传输）阶段  @(posedge intf.clock);  dbg_state <=DRV_IDLE;  dbg_din_chnl0_data <= 0;  intf.din[p.src] <= 1'b0;  intf.valid_n[p.src] <= 1'b1;  intf.frame_n[p.src] <= 1'b1;  $display("@%0t: [DRV]src_chnl[%0d],dest_chnl[%0d] data trans finished",$time,p.src,p.dst);endtaskendclass//********************************** generator **********************************//class rt_generator;//generator产生数据交给stimulator  rt_packet pkts[$];//定义队列  function void put_pkt(input rt_packet p);    pkts.push_back(p);//将p放入队列pkts里面（在pkts队列尾插入p）  endfunction    task get_pkt(output rt_packet p);    wait(pkts.size() >0 )//队列不为空      p = pkts.pop_front();//将p从队列pkts里面取出，提取队列首元素  endtask  //generate a random packet  function void gen_pkt(int src = -1, int dst = -1);  endfunction    task run();        //TODO  endtask    endclass//********************************** monitor **********************************//class rt_monitor;virtual rt_interface intf;    rt_packet in_pkts[16][$];    rt_packet out_pkts[16][$];    task run();    fork        mon_chnls();    join_noneendtask    task mon_chnls;    foreach(in_pkts[i]) begin        automatic int chid = i;        fork        mon_chnl_in(chid);//每个输入端口均调用mon_chnl_in任务，监测数据输入        mon_chnl_out(chid);//每个输出端口均调用mon_chnl_out任务，监测数据输入        join_none    endendtask    task  mon_chnl_in (bit[3:0]id);//监测数据输入的任务    rt_packet pkt;//定义结构体变量    forever begin    //clear content for the same struct variable。清除pkt    pkt = new();    pkt.src = id;//第id个输入端口    //monitor specific channel-in data and put it into the queue    // monitor address phase    @(negedge intf.frame_n[id]);//监测frame_n下降沿(frame_n由时钟驱动)    for(int i=0; i<4; i++)begin        @(negedge intf.clock);//frame_n下降沿后监测4个clk negedge        pkt.dst[i]= intf.din[id];        end        $display ("@%0t: [MON] src_chn1[%0d] & dest_chn1[%0d] data trans started",$time,pkt.src,pkt.dst);    //pass pad phase 不考虑pad阶段是否满足协议要求    repeat(5) @(negedge intf.clock);    do begin        pkt.data = new [pkt.data.size + 1](pkt.data);//创建动态数组并复制pkt.data        for ( int i=0; i<8; i++) begin            @(negedge intf.clock); //在8个clk negedge监测8bit数据            pkt.data[pkt.data.size-1][i] = intf.din[id];        end    end while(!intf.frame_n[id]);    in_pkts[id].push_back(pkt);//将monitor拿到的数据放入in_pkts    $display("@%0t:[MON] CH_IN src_chnl[%0d] &dest_chnl[%0d ] finished with packet: \n%s",$time,pkt.src,pkt.dst,pkt.sprint());    endendtasktask  mon_chnl_out(bit[ 3:0]id);//监测数据输出的任务    rt_packet pkt;    forever begin        //clear content for the same struct variable        pkt = new();        pkt.src = 0;        pkt.dst = id;        @(negedge intf.frameo_n[id]);        $display( "@%0t: [MON] CH_OUT dest_chn1[%0d] data trans started",$time,pkt.dst);        do begin        pkt.data = new [ pkt.data.size + 1](pkt.data);        for(int i=0;i<8; i++) begin            @(negedge intf.clock iff !intf.valido_n[id]);//clock与valido_n信号同时为低            pkt.data[pkt.data.size-1][i]= intf.dout [id];        end    end while(!intf.frameo_n[id]);    out_pkts[id].push_back(pkt);    $display("@%0t: [MON] CH_OUT dest_chn1[%0d] data finished woth packet : \n %s",$time,pkt.dst,pkt.sprint());    //monitor specific channel-out data and put it into the queue    endendtaskendclass//********************************** checker **********************************//class rt_checker;    int unsigned compare_count;    int unsigned error_count;        function new();//赋初值，可有可无，整形变量默认初始值为0        compare_count = 0;        error_count = 0;    endfunction        rt_packet exp_out_pkts[16][$];    rt_monitor mon;        task run();    foreach(exp_out_pkts[i])begin        automatic int chid = i;        fork            do_routing(chid);            do_compare(chid);        join_none        end    endtask        task do_routing(bit[3:0] id);//将monitor中采样到的输入数据放入期望的输出端队列中        rt_packet pkt;        forever begin            wait(mon.in_pkts[id].size > 0);            pkt = mon.in_pkts[id].pop_front();//从monitor中拿到in_pkts队列数据放入pkt            exp_out_pkts[pkt.dst].push_back(pkt);//将pkt数据放入对应期望的dest_chnl            end    endtask         task do_compare(bit[3:0] id);//比较采集的实际输出与期望输出        rt_packet exp_pkt, act_pkt;        forever begin            wait(mon.out_pkts[id].size > 0 && exp_out_pkts[id].size > 0);//实际采样数据与期望数据都有值            act_pkt = mon.out_pkts[id].pop_front();//实际数据为monitor采样的输出数据            exp_pkt = exp_out_pkts[id].pop_front();//期望数据为monitor采样到的输入数据            if(act_pkt.compare(exp_pkt))begin//如果exp_pkt与act_pkt比较成功，返回1                $display("[CHK] data compare success with packet : \n%s",act_pkt.sprint());            end            else begin                $display("[CHK] data compare failure with actual packet : \n%s \nexpected packet : \n%s", act_pkt.sprint(), exp_pkt.sprint());                error_count++;            end                compare_count++;        end    endtask         function void do_report();        $display("TOTAL COMPARING %0d times",compare_count);        if(!error_count)            $display("TEST PASSED!");        else begin            $display("TEST FAILED!");            $display("TOTAL ERROR %0d times", error_count);        end    endfunctionendclass//**********************************  **********************************//class rt_env;//rt_env包含各个组件    rt_stimulator stim;    rt_monitor mon;    rt_generator gen;    rt_checker chk;            function new(virtual rt_interface intf);        //build stage,例化        stim = new();        gen = new();        mon = new();        chk = new();        //connect sage，连接        stim.intf = intf;        mon.intf = intf;        chk.mon = mon;//check拿monitor句柄，即拿monitor中in_pkts与out_pkts队列    endfunction         task run();        rt_packet p;        //run stage，run        fork            stim.run();//class里面的函数不会自动调用，需要手动调用            gen.run();            mon.run();            chk.run();            begin:genarator_to_stimulator_proc//取出genarator中的数据给stimulator                 forever begin//此处不需要延迟0，执行task run的时候默认function new已执行                    gen.get_pkt(p);//get句柄                    stim.put_pkt(p);//put句柄                end            end        join_none                    endtask    endclassclass rt_base_test;//rt_base_test包含rt_env，rt_env包含各个组件    rt_env env;        function new(virtual rt_interface intf);        env = new(intf);    endfunction        task run();        fork            env.run();        join_none    endtaskendclass    class rt_single_ch_test extends rt_base_test;//单个通道测试        function new(virtual rt_interface intf);            env = new(intf);        endfunction                task run();            rt_packet p;            super.run();//调用父类的run，即执行env.run()，进行组件的例化等操作            p = new();//obj1(每次put_pkt都需要new一下)            p.set_members(0,3,'{8'h33,8'h77});//注意层次变化，在env层次下面            env.gen.put_pkt(p);            p = new();//obj2            p.set_members(0,5,'{8'h55,8'h66});            env.gen.put_pkt(p);        endtask            endclass    class rt_two_ch_test extends rt_base_test;        function new(virtual rt_interface intf);            env = new(intf);        endfunction    endclass        class rt_two_ch_same_chout_test extends rt_two_ch_test;            function new(virtual rt_interface intf);                env = new(intf);            endfunction        endclass    class rt_multi_ch_test extends rt_base_test;//多通道测试        function new(virtual rt_interface intf);            env = new(intf);        endfunction                task run();            rt_packet p;            super.run();            p = new();            p.set_members(0,3,'{8'h33,8'h77});            env.gen.put_pkt(p);            p = new();//每次put_pkt都需要new一下            p.set_members(0,5,'{8'h55,8'h66});            env.gen.put_pkt(p);            p = new();            p.set_members(3,6,'{8'h77,8'h88,8'h22});            env.gen.put_pkt(p);            p = new();            p.set_members(4,7,'{8'haa,8'hcc,8'h33});            env.gen.put_pkt(p);        endtask    endclass        class rt_full_ch_test extends rt_multi_ch_test;            function new(virtual rt_interface intf);                env = new(intf);            endfunction        endclass//**********************************  **********************************////********************************** tb **********************************//module tb;bit clk,rstn;logic [15:0] din, frame_n, valid_n;logic [15:0] dout, valido_n, busy_n, frameo_n;// 产生时钟，周期为10nsinitial     forever #5ns clk <= !clk;// 产生复位信号  initial begin    #2ns rstn <= 1;    #10ns rstn <= 0;    #10ns rstn <= 1;  end//例化router为DUTrouter dut(             .reset_n(rstn),  .clock(clk),  .frame_n(intf.frame_n),  .valid_n(intf.valid_n),  .din(intf.din),  .dout(intf.dout),  .busy_n(intf.busy_n),  .valido_n(intf.valido_n),  .frameo_n(intf.frameo_n));rt_interface intf();//例化接口    assign intf.reset_n = rstn;    assign intf.clock = clk;    rt_single_ch_test  single_ch_test;    rt_multi_ch_test   multi_ch_test;            initial begin : inst_init_proc            single_ch_test = new(intf);            //multi_ch_test  = new(intf);            single_ch_test.run();            //multi_ch_test.run();    end    endmodule </code></pre><h2 id="1-3-仿真结果"><a href="#1-3-仿真结果" class="headerlink" title="1.3 仿真结果"></a>1.3 仿真结果</h2><h3 id="1-3-1-单通道测试-0→3，0→5"><a href="#1-3-1-单通道测试-0→3，0→5" class="headerlink" title="1.3.1 单通道测试(0→3，0→5)"></a>1.3.1 单通道测试(0→3，0→5)</h3><p>单通道测试：</p><pre class=" language-systemverilog"><code class="language-systemverilog">single_ch_test = new(intf);//multi_ch_test  = new(intf);single_ch_test.run();//multi_ch_test.run();</code></pre><p>仿真结果：</p>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211172147174.png" width="600" height="120" title=" ">        <h3 id="1-3-2-多通道测试-0→3，0→5，3→6，4→7"><a href="#1-3-2-多通道测试-0→3，0→5，3→6，4→7" class="headerlink" title="1.3.2 多通道测试(0→3，0→5，3→6，4→7)"></a>1.3.2 多通道测试(0→3，0→5，3→6，4→7)</h3><p>多通道测试：</p><pre class=" language-systemverilog"><code class="language-systemverilog">//single_ch_test = new(intf);multi_ch_test  = new(intf);//single_ch_test.run();multi_ch_test.run();</code></pre><p>仿真结果：</p>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211172152813.png" width="600" height="200" title=" ">        <h1 id="2-增加数据传输完成信号、checker的判断、test-name"><a href="#2-增加数据传输完成信号、checker的判断、test-name" class="headerlink" title="2. 增加数据传输完成信号、checker的判断、test name"></a>2. 增加数据传输完成信号、checker的判断、test name</h1><h2 id="2-1-改进"><a href="#2-1-改进" class="headerlink" title="2.1 改进"></a>2.1 改进</h2><p><strong>(1)增加数据传输完成信号，数据传输完成后调用checker里的report进行报告</strong></p><pre class=" language-systemverilog"><code class="language-systemverilog">task report();    wait(gen_trans_done == 1);    #(test_drain_time_us * 1us);    env.report(name);//调用env里的chk.report()进行report    $finish();//terminates the current testendtask</code></pre><p><strong>(2)增加checker比较的判断，需判断exp_out_pkts与mon.out_pkts必须有数据</strong></p><pre class=" language-systemverilog"><code class="language-systemverilog">function void report();    $display("TOTAL COMPARING %0d times",compare_count);    if(!error_count && check_data_buffer())//判断无误且二者有数据        $display("TEST PASSED!");    else begin        $display("TEST FAILED!");        $display("TOTAL ERROR %0d times", error_count);    endendfunctionfunction bit check_data_buffer();    check_data_buffer = 1;    foreach(exp_out_pkts[id])begin         if(exp_out_pkts[id].size != 0)begin//exp_out_pkts必须有数据            check_data_buffer = 0;            $display("exp_out_pkts[%0d] buffer size is not 0(still with %0d data)",id,exp_out_pkts[id].size);        end        if(mon.out_pkts[id].size != 0)begin//mon.out_pkts必须有数据            check_data_buffer = 0;            $display("mon.out_pkts[%0d] buffer size is not 0(still with %0d data)",id,mon.out_pkts[id].size);        end    endendfunction</code></pre><p><strong>(3)增加test的name，并由checker里的report函数打印</strong></p><h2 id="2-2-改进后的tb-sv"><a href="#2-2-改进后的tb-sv" class="headerlink" title="2.2 改进后的tb.sv"></a>2.2 改进后的tb.sv</h2><pre class=" language-systemverilog"><code class="language-systemverilog">class rt_packet;  bit [3:0] src;  bit [3:0] dst;  bit [7:0] data [];  function new();  endfunction  function void set_members(bit [3:0]src, bit [3:0]dst, bit[7:0]data []);    this.src = src;    this.dst = dst;    this.data = data;  endfunction  function string sprint();//打印packet信息的函数    sprint = {sprint , $sformatf("src = %0d\n",src)};    sprint = {sprint , $sformatf("dst = %0d\n",dst)};    sprint = {sprint , $sformatf("data_length = %0d\n",data.size())};    foreach(data[i])        sprint = {sprint , $sformatf("data[%0d] = 'h%0x\n", i, data[i])};  endfunction  function bit compare(rt_packet p);//输入exp_pkt        if(dst == p.dst && data == p.data)            compare = 1;        else             compare = 0;  endfunctionendclassinterface rt_interface();    logic clock;    logic reset_n;    logic [15:0] din;    logic [15:0] frame_n;    logic [15:0] valid_n;    logic [15:0] dout;    logic [15:0] valido_n;    logic [15:0] busy_n;    logic [15:0] frameo_n;endinterface//********************************** stimulator **********************************//class rt_stimulator;    virtual rt_interface intf;//class里的接口不能用端口的方式描述，需要添加virtual关键字，在类里面用接口的指针//for debug purpose from waveform//定义检测状态的变量  typedef enum {DRV_RESET,DRV_IDLE,DRV_ADDR,DRV_PAD,DRV_DATA} drv_state_t;  drv_state_t dbg_state;    byte unsigned dbg_din_chnl0_data;   int src_chnl_status[int];  //关联数组，后面int：src_chnl的number；前面int：dest_chnl的Number ？？    //generator传送p给stimulator  rt_packet pkts[$];//定义stimulator中的的队列pkts  function void put_pkt(input rt_packet p);    pkts.push_back(p);//将generator中传过来的p放入stimulator的pkts中(在pkts队列尾插入p)  endfunctiontask run();    fork        drive_reset(); //reset动作        get_packet_and_drive(); //drive_chnl动作    join_noneendtask    task drive_reset();//reset    forever begin        @(negedge intf.reset_n);        dbg_state <= DRV_RESET;        intf.din <= 0;        intf.frame_n <= '1;//等效16'hFFFF        intf.valid_n <= '1;    endendtask// 发送数据task get_packet_and_drive();//drive_chnl    //rt_packet_t p;  @(negedge intf.reset_n);  repeat(10) @(posedge intf.clock);//延迟10个时钟周期  forever begin    automatic rt_packet p;//声明一个动态的    wait(pkts.size()>0);    p = pkts.pop_front();//将p从队列pkts里面取出    fork//后台触发线程，触发线程在后台运行，继续执行剩下内容        begin            wait_src_chnl_avail(p);//判断src chnl是否被占用，是否需要等待            drive_chnl(p);//从P中拿到发送端口，目标端口，发送数据            set_src_chnl_avail(p);        end    join_none    endendtasktask  wait_src_chnl_avail(rt_packet p);//判断src chnl是否被占用，是否需要等待    if(!src_chnl_status.exists(p.src))//src_chnl_status关联数组里面不含p.src，(表示未占用任何dest_chnl,一开始不满足）        src_chnl_status[p.src] = p.dst;//表示当前正在使用src_chnl,对应dest_chnl就是p.dst（p.src端口在向p.dst端口发送数据）    else if(src_chnl_status[p.src] >= 0)//如果在给0,1,2...dest_chnl发送数据（被占用），需要等待,，否则不需要等待        wait(src_chnl_status[p.src] == -1);//直到src_chnl_status[p.src] == -1(自定义的dest_chnl端口数之外任意的数，表示未占用任何dest_chnl)endtaskfunction  set_src_chnl_avail(rt_packet p);    src_chnl_status[p.src] = -1;//如果chnl发送完后，把src_chnl置回来(自定义的dest_chnl端口数之外任意的数，表示未占用任何dest_chnl)endfunctiontask  drive_chnl(rt_packet p);  $display("@%0t:[DRV] src_chnl[%0d] & dest_chnl[%0d] data trans started with packet: \n%s",$time,p.src,p.dst,p.sprint());    // drive address phase 输入地址位阶段for(int i=0;i<4;i++)begin  //4 clock  @(posedge intf.clock);  dbg_state <=DRV_ADDR;  intf.din[p.src] <= p.dst[i];  intf.valid_n[p.src] <= $urandom_range(0,1);//valid_n在din的地址输入时间段可为任意值x  intf.frame_n[p.src] <= 1'b0;//frame_n需要为低end    // drive pad phase //隔离阶段  for (int i=0;i<5;i++)begin  //5 clock    @(posedge intf.clock);    dbg_state <=DRV_PAD;    intf.din[p.src] <= 1'b1;    intf.valid_n[p.src] <= 1'b1;//valid_n需为高电平    intf.frame_n[p.src] <= 1'b0; //frame_n需为低电平  end    // drive data phase 传输数据阶段  foreach(p.data[id])begin    for(int i=0;i<8;i++)begin     @(posedge intf.clock);      dbg_state <=DRV_DATA;      dbg_din_chnl0_data <= p.data[id];      intf.din[p.src] <= p.data[id][i];      intf.valid_n[p.src] <=1'b0;      intf.frame_n[p.src] <= (id == p.data.size()-1 && i == 7) ? 1'b1 : 1'b0;//packet最后一位输出数据时frameo_n为高    end  end// drive idle phase 闲置（没有数据传输）阶段  @(posedge intf.clock);  dbg_state <=DRV_IDLE;  dbg_din_chnl0_data <= 0;  intf.din[p.src] <= 1'b0;  intf.valid_n[p.src] <= 1'b1;  intf.frame_n[p.src] <= 1'b1;  $display("@%0t: [DRV]src_chnl[%0d],dest_chnl[%0d] data trans finished",$time,p.src,p.dst);endtaskendclass//********************************** generator **********************************//class rt_generator;//generator产生数据交给stimulator  rt_packet pkts[$];//定义队列  function void put_pkt(input rt_packet p);    pkts.push_back(p);//将p放入队列pkts里面（在pkts队列尾插入p）  endfunction    task get_pkt(output rt_packet p);    wait(pkts.size() >0 )//队列不为空      p = pkts.pop_front();//将p从队列pkts里面取出，提取队列首元素  endtask  //generate a random packet  function void gen_pkt(int src = -1, int dst = -1);  endfunction    task run();        //TODO  endtask    endclass//********************************** monitor **********************************//class rt_monitor;virtual rt_interface intf;    rt_packet in_pkts[16][$];    rt_packet out_pkts[16][$];    task run();    fork        mon_chnls();    join_noneendtask    task mon_chnls;    foreach(in_pkts[i]) begin        automatic int chid = i;        fork        mon_chnl_in(chid);//每个输入端口均调用mon_chnl_in任务，监测数据输入        mon_chnl_out(chid);//每个输出端口均调用mon_chnl_out任务，监测数据输入        join_none    endendtask    task  mon_chnl_in (bit[3:0]id);//监测数据输入的任务    rt_packet pkt;//定义结构体变量    forever begin    //clear content for the same struct variable。清除pkt    pkt = new();    pkt.src = id;//第id个输入端口    //monitor specific channel-in data and put it into the queue    // monitor address phase    @(negedge intf.frame_n[id]);//监测frame_n下降沿(frame_n由时钟驱动)    for(int i=0; i<4; i++)begin        @(negedge intf.clock);//frame_n下降沿后监测4个clk negedge        pkt.dst[i]= intf.din[id];        end        $display ("@%0t: [MON] src_chn1[%0d] & dest_chn1[%0d] data trans started",$time,pkt.src,pkt.dst);    //pass pad phase 不考虑pad阶段是否满足协议要求    repeat(5) @(negedge intf.clock);    do begin        pkt.data = new [pkt.data.size + 1](pkt.data);//创建动态数组并复制pkt.data        for ( int i=0; i<8; i++) begin            @(negedge intf.clock); //在8个clk negedge监测8bit数据            pkt.data[pkt.data.size-1][i] = intf.din[id];        end    end while(!intf.frame_n[id]);    in_pkts[id].push_back(pkt);//将monitor拿到的数据放入in_pkts    $display("@%0t:[MON] CH_IN src_chnl[%0d] &dest_chnl[%0d ] finished with packet: \n%s",$time,pkt.src,pkt.dst,pkt.sprint());    endendtasktask  mon_chnl_out(bit[ 3:0]id);//监测数据输出的任务    rt_packet pkt;    forever begin        //clear content for the same struct variable        pkt = new();        pkt.src = 0;        pkt.dst = id;        @(negedge intf.frameo_n[id]);        $display( "@%0t: [MON] CH_OUT dest_chn1[%0d] data trans started",$time,pkt.dst);        do begin        pkt.data = new [ pkt.data.size + 1](pkt.data);        for(int i=0;i<8; i++) begin            @(negedge intf.clock iff !intf.valido_n[id]);//clock与valido_n信号同时为低            pkt.data[pkt.data.size-1][i]= intf.dout [id];        end    end while(!intf.frameo_n[id]);    out_pkts[id].push_back(pkt);    $display("@%0t: [MON] CH_OUT dest_chn1[%0d] data finished woth packet : \n %s",$time,pkt.dst,pkt.sprint());    //monitor specific channel-out data and put it into the queue    endendtaskendclass//********************************** checker **********************************//class rt_checker;    int unsigned compare_count;    int unsigned error_count;        function new();//赋初值，可有可无，整形变量默认初始值为0        compare_count = 0;        error_count = 0;    endfunction        rt_packet exp_out_pkts[16][$];    rt_monitor mon;        task run();    foreach(exp_out_pkts[i])begin        automatic int chid = i;        fork            do_routing(chid);            do_compare(chid);        join_none        end    endtask        task do_routing(bit[3:0] id);//将monitor中采样到的输入数据放入期望的输出端队列中        rt_packet pkt;        forever begin            wait(mon.in_pkts[id].size > 0);            pkt = mon.in_pkts[id].pop_front();//从monitor中拿到in_pkts队列数据放入pkt            exp_out_pkts[pkt.dst].push_back(pkt);//将pkt数据放入对应期望的dest_chnl            end    endtask         task do_compare(bit[3:0] id);//比较采集的实际输出与期望输出        rt_packet exp_pkt, act_pkt;        forever begin            wait(mon.out_pkts[id].size > 0 && exp_out_pkts[id].size > 0);//实际采样数据与期望数据都有值            act_pkt = mon.out_pkts[id].pop_front();//实际数据为monitor采样的输出数据            exp_pkt = exp_out_pkts[id].pop_front();//期望数据为monitor采样到的输入数据            if(act_pkt.compare(exp_pkt))begin//如果exp_pkt与act_pkt比较成功，返回1                $display("[CHK] data compare success with packet : \n%s",act_pkt.sprint());            end            else begin                $display("[CHK] data compare failure with actual packet : \n%s \nexpected packet : \n%s", act_pkt.sprint(), exp_pkt.sprint());                error_count++;            end                compare_count++;        end    endtask         function void report(string name);        $display("TOTAL COMPARING %0d times",compare_count);        if(!error_count && check_data_buffer())//判断无误且二者有数据            $display("TEST [%s] PASSED!",name);        else begin            $display("TEST [%s]FAILED!",name);            $display("TOTAL ERROR %0d times", error_count);        end    endfunction        function bit check_data_buffer();        check_data_buffer = 1;        foreach(exp_out_pkts[id])begin             if(exp_out_pkts[id].size != 0)begin//exp_out_pkts必须有数据                check_data_buffer = 0;                $display("exp_out_pkts[%0d] buffer size is not 0(still with %0d data)",id,exp_out_pkts[id].size);            end            if(mon.out_pkts[id].size != 0)begin//mon.out_pkts必须有数据                check_data_buffer = 0;                $display("mon.out_pkts[%0d] buffer size is not 0(still with %0d data)",id,mon.out_pkts[id].size);            end        end    endfunction    endclass//********************************** Optional tests **********************************//class rt_env;//rt_env包含各个组件    rt_stimulator stim;    rt_monitor mon;    rt_generator gen;    rt_checker chk;            function new(virtual rt_interface intf);        //build stage,例化        stim = new();        gen = new();        mon = new();        chk = new();        //connect stage，连接        stim.intf = intf;        mon.intf = intf;        chk.mon = mon;//check拿monitor句柄，即拿monitor中in_pkts与out_pkts队列    endfunction         task run();        rt_packet p;        //run stage，run        fork            stim.run();//class里面的函数不会自动调用，需要手动调用            gen.run();            mon.run();            chk.run();            begin:genarator_to_stimulator_proc//取出genarator中的数据给stimulator                 forever begin//此处不需要延迟0，执行task run的时候默认function new已执行                    gen.get_pkt(p);//get句柄                    stim.put_pkt(p);//put句柄                end            end        join_none    endtask        function void report(string name);        chk.report(name);    endfunction    endclassclass rt_base_test;//rt_base_test包含rt_env，rt_env包含各个组件    rt_env env;    bit gen_trans_done = 0;//表示数据传输未开始    int unsigned test_drain_time_us = 1;//数据传输完后等待报告的时间    string name;        function new(virtual rt_interface intf,string name = "rt_base_test");        env = new(intf);        this.name = name;    endfunction        task run();    $display("TEST %s started",name);        fork            env.run();            report();//调用report        join_none    endtask        task report();        wait(gen_trans_done == 1);        #(test_drain_time_us * 1us);        env.report(name);//调用env里的chk.report()进行report        $finish();//terminates the current test    endtask  function void set_trans_done(bit done = 1);//将set_trans_done信号置为1，表示数据传输已完成        gen_trans_done = done;    endfunctionendclass    class rt_single_ch_test extends rt_base_test;//单个通道测试        function new(virtual rt_interface intf,string name = "rt_single_ch_test");            super.new(intf,name);        endfunction                    task run();            rt_packet p;            super.run();//调用父类的run，即执行env.run()，进行组件的例化等操作            p = new();//obj1(每次put_pkt都需要new一下)            p.set_members(0,3,'{8'h33,8'h77});//注意层次变化，在env层次下面            env.gen.put_pkt(p);            p = new();//obj2            p.set_members(0,5,'{8'h55,8'h66});            env.gen.put_pkt(p);            set_trans_done();        endtask            endclass    class rt_two_ch_test extends rt_base_test;        function new(virtual rt_interface intf,string name = "rt_two_ch_test");            super.new(intf,name);        endfunction    endclass        class rt_two_ch_same_chout_test extends rt_two_ch_test;            function new(virtual rt_interface intf,string name = "rt_two_ch_same_chout_test");                super.new(intf,name);            endfunction        endclass    class rt_multi_ch_test extends rt_base_test;//多通道测试        function new(virtual rt_interface intf,string name = "rt_multi_ch_test");            super.new(intf,name);        endfunction                task run();            rt_packet p;            super.run();            p = new();            p.set_members(0,3,'{8'h33,8'h77});            env.gen.put_pkt(p);            p = new();//每次put_pkt都需要new一下            p.set_members(0,5,'{8'h55,8'h66});            env.gen.put_pkt(p);            p = new();            p.set_members(3,6,'{8'h77,8'h88,8'h22});            env.gen.put_pkt(p);            p = new();            p.set_members(4,7,'{8'haa,8'hcc,8'h33});            env.gen.put_pkt(p);            set_trans_done();        endtask    endclass        class rt_full_ch_test extends rt_multi_ch_test;            function new(virtual rt_interface intf,string name = "rt_full_ch_test");                super.new(intf,name);            endfunction        endclass//********************************** Optional tests **********************************////********************************** tb **********************************//module tb;bit clk,rstn;logic [15:0] din, frame_n, valid_n;logic [15:0] dout, valido_n, busy_n, frameo_n;// 产生时钟，周期为10nsinitial     forever #5ns clk <= !clk;// 产生复位信号  initial begin    #2ns rstn <= 1;    #10ns rstn <= 0;    #10ns rstn <= 1;  end//例化router为DUTrouter dut(             .reset_n(rstn),  .clock(clk),  .frame_n(intf.frame_n),  .valid_n(intf.valid_n),  .din(intf.din),  .dout(intf.dout),  .busy_n(intf.busy_n),  .valido_n(intf.valido_n),  .frameo_n(intf.frameo_n));rt_interface intf();//例化接口    assign intf.reset_n = rstn;    assign intf.clock = clk;    rt_single_ch_test  single_ch_test;    rt_multi_ch_test   multi_ch_test;            initial begin : inst_init_proc            single_ch_test = new(intf);            //multi_ch_test  = new(intf);            single_ch_test.run();            //multi_ch_test.run();    end    endmodule </code></pre><h2 id="2-3-仿真结果"><a href="#2-3-仿真结果" class="headerlink" title="2.3 仿真结果"></a>2.3 仿真结果</h2><p>同上</p><h1 id="3-package封装与makefile的使用"><a href="#3-package封装与makefile的使用" class="headerlink" title="3.  package封装与makefile的使用"></a>3.  package封装与makefile的使用</h1><h2 id="3-1-改进"><a href="#3-1-改进" class="headerlink" title="3.1 改进"></a>3.1 改进</h2><p><strong>(1)利用package将文件打包，并将package里的内容放入一个单独的文件里面</strong><br>VCS命令</p><blockquote><p>vcs -full64 -debug_access+all -sverilog -timescale=1ns/1ps <span style="background:rgba(5, 117, 197, 0.2)">router.v</span> <span style="background:rgba(136, 49, 204, 0.2)">rt_test_pkg.sv</span> <span style="background:#affad1">lab7tb.sv</span>  -top tb<br>//注意文件顺序，lab7tb.sv中的类是在rt_test_pkg.sv中创建的，rt_test_pkg.sv应在前面</p></blockquote>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211180958453.png" width="300" height="400" title=" ">        **(2)使用makefile**<p>使用脚本包含命令及其组合，makefile代码如下：</p><pre class=" language-systemverilog"><code class="language-systemverilog">##############################User variables#############################TB        =tbSEED      =1TESTNAME ?= rt_single_ch_testFILES     =router.v rt_test_pkg.sv lab7tb.sv##############################Environment variables#############################COMP  = vcs -full64 -sverilog -debug_acc+all -timescale=1ps/1ps -l comp.log $(FILES)RUN   = ./$(TB).simv -l run.log -sml +ntb_random_seed=$(SEED)+TESTNAME=$(TESTNAME)comp:    $(COMP) -top $(TB) -o $(TB).simvrun:    $(RUN)    rung:    $(RUN)-gui</code></pre><p>相关命令：</p><blockquote><p>make comp    //编译当前路径下的makefile文件，生成命令<br>make run/make rung    //执行run或rung的内容，生成log文件，make rung会调用vcs的可视化窗口</p></blockquote><p><strong>(3)对makefile增加输入参数</strong><br>将外部输入参数添加到tb文件中：</p><pre class=" language-systemverilog"><code class="language-systemverilog">rt_interface intf();//例化接口    assign intf.reset_n = rstn;    assign intf.clock = clk;    rt_single_ch_test  single_ch_test;    rt_multi_ch_test   multi_ch_test;            initial begin : Select_the_test    string name;      single_ch_test = new(intf);      multi_ch_test  = new(intf);      //single_ch_test.run();      //multi_ch_test.run();      if($value$plusargs("TESTNAME=%s",name))begin//$value$plusargs作用：运行仿真时输入参数        case(name)            "rt_single_ch_test" : single_ch_test.run();//输入rt_single_ch_test，调用对应run，执行输入rt_single_ch_test                "rt_multi_ch_test" :multi_ch_test.run();            default:$fatal("[ERRTEST],test name %s is invalid,please specity a valid name!0",name);        endcase        end    end</code></pre><p>相关命令：</p><blockquote><p>make run TESTNAME=rt_multi_ch_test    //传入参数rt_multi_ch_test，进行多通道测试<br>make run TESTNAME=rt_single_ch_test    //传入参数rt_single_ch_test，进行多通道测试</p></blockquote><h2 id="3-2-仿真结果"><a href="#3-2-仿真结果" class="headerlink" title="3.2 仿真结果"></a>3.2 仿真结果</h2><p>同上</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-利用类的继承，将多种test包含进base-test中&quot;&gt;&lt;a href=&quot;#1-利用类的继承，将多种test包含进base-test中&quot; class=&quot;headerlink&quot; title=&quot;1. 利用类的继承，将多种test包含进base test中&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="数字IC" scheme="https://www.daipeihong.top/categories/%E6%95%B0%E5%AD%97IC/"/>
    
    
    <category term="数字前端" scheme="https://www.daipeihong.top/tags/%E6%95%B0%E5%AD%97%E5%89%8D%E7%AB%AF/"/>
    
    <category term="SystemVerilog验证" scheme="https://www.daipeihong.top/tags/SystemVerilog%E9%AA%8C%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>lightroom后期（四）局部曝光的调整</title>
    <link href="https://www.daipeihong.top/2022/10/28/lightroom-hou-qi-si-ju-bu-pu-guang-de-diao-zheng/"/>
    <id>https://www.daipeihong.top/2022/10/28/lightroom-hou-qi-si-ju-bu-pu-guang-de-diao-zheng/</id>
    <published>2022-10-28T10:48:00.000Z</published>
    <updated>2022-10-28T12:45:45.753Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、渐变滤镜"><a href="#一、渐变滤镜" class="headerlink" title="一、渐变滤镜"></a>一、渐变滤镜</h1><p>渐变滤镜的作用呢，是创造有过度的曝光调整，可以是生硬的过度，也可以是柔和的过度。软过度的调整呢，让照片中的光线看起来要更自然。<br>拍日落的时候，当太阳逐渐降低到地平线后，天空的曝光很亮，但是地面的建筑阴影这些背光的位置很暗。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210281956398.png"><br>这个时候就可以使用渐变滤镜来调整。在照片中曝光有差别的位置，拉一个渐变滤镜，通常是在地平线的位置。过度要稍微的软一些，也就是这三条线的距离要大一点。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210282000844.png"><br>在参数的设置里，可以按照<a href="http://daipeihong.top/2022/10/27/lightroom-hou-qi-san-ti-sheng-zhao-pian-zhi-gan/">上一节</a>对比度和立体感的调整方法来设置参数<br>可以添加一个明亮度范围蒙板<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210282002665.png"><br>在范围这里边，左侧是暗部，右侧是亮部，点击显示明亮度蒙板就可以看到调整的过程当中蒙板的变化。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210282005945.png"><br>同样也可以增加阴影来调高所有的阴影位置，在这个案例当中，可以搭配阴影和明亮度蒙板来调整建筑与天空之间的过渡。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210282008223.png"><br>对比一下原片，可以看到高光的位置，也就是天空被压暗，而建筑呢被提亮。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210282009769.png"><br>无论是1/2还是1/3的构图方法，甚至是左右分割以及对角线曝光不平衡的画面，只要是大面积的需要调整曝光的时候呢，都可以使用渐变滤镜来解决。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210282011038.png"></p><h1 id="二、径向滤镜"><a href="#二、径向滤镜" class="headerlink" title="二、径向滤镜"></a>二、径向滤镜</h1><p>由于径向滤镜的覆盖面积，是圆形或者是椭圆形的，在调整高光的时候要更方便，在城市建筑以及街景的案例当中更为常用。例如这张照片左侧的树和右侧的建筑，刚好形成了一个框架，照片中间的建筑和天空被阳光直射，使用径向滤镜刚好达到完美的覆盖这个区域。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210282013415.png"><br>在径向滤镜当中，比渐变滤镜啊要多一个选项，叫做羽化，指的是滤镜周围的过渡，大多数的情况下呢，都需要使用比较大的羽化，让光线过度更自然，勾选左下角的显示选定的蒙板叠加，就可以看到现在径向滤镜所影响的范围。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210282015936.png"><br>降低羽化会让滤镜的边缘过渡非常的生硬，所以经常我们要加大羽化的数值，营造比较自然柔和的光线。</p><h1 id="三、调整画笔"><a href="#三、调整画笔" class="headerlink" title="三、调整画笔"></a>三、调整画笔</h1><p>调整画笔是非常重要的细节修补工具，特别是城市照片这种细节特别多的题材，例如这张照片当中，酒店建筑外观的立体感稍微有点差，渐变滤镜和径向滤镜的覆盖范围又没有办法在这个位置发挥很好的作用，那就刚好用到了调整画笔。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210282018972.png"></p><p>后期思路：降低屋顶曝光，提高建筑白色部分曝光度，增大与屋顶对比。添加白色色阶，降低黑色色阶，让窗户的这个窗户框能够变得更明显，增加一点点的纹理。通过这样的分区调整屋顶以及楼体的曝光，就可以实现将建筑细节重塑曝光的效果。<br>对比原片，就可以看到现在建筑拥有更立体的效果。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210282022793.png"></p><p>以上这三个工具的区别，可以理解为覆盖面积的不一样。<br>渐变滤镜的面积最大，径向滤镜适合圆形的范围调整；画笔适应能力最强，它的覆盖面积最小，可以自由的选择想要调整的位置以及形状，是精修细节的最好选择。组合搭配这三个工具，就可以实现特别的光影效果，特别是在调整黑白照片当中，利用局部曝光的明暗对比来提亮主体，压暗阴影，获得更具有戏剧性的视觉效果。</p><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p><a href="https://www.bilibili.com/video/BV15b4y1Q7xH/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=83d80c57e4377b69f911cc68016fb835">【Edi x TourBox后期训练营】光影的后期再造秘籍 - 局部曝光的调整对照片的微妙作用_哔哩哔哩_bilibili</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、渐变滤镜&quot;&gt;&lt;a href=&quot;#一、渐变滤镜&quot; class=&quot;headerlink&quot; title=&quot;一、渐变滤镜&quot;&gt;&lt;/a&gt;一、渐变滤镜&lt;/h1&gt;&lt;p&gt;渐变滤镜的作用呢，是创造有过度的曝光调整，可以是生硬的过度，也可以是柔和的过度。软过度的调整呢，让照片中的光</summary>
      
    
    
    
    <category term="摄影后期" scheme="https://www.daipeihong.top/categories/%E6%91%84%E5%BD%B1%E5%90%8E%E6%9C%9F/"/>
    
    
    <category term="lightroom" scheme="https://www.daipeihong.top/tags/lightroom/"/>
    
  </entry>
  
  <entry>
    <title>lightroom后期(三) 提升照片质感</title>
    <link href="https://www.daipeihong.top/2022/10/27/lightroom-hou-qi-san-ti-sheng-zhao-pian-zhi-gan/"/>
    <id>https://www.daipeihong.top/2022/10/27/lightroom-hou-qi-san-ti-sheng-zhao-pian-zhi-gan/</id>
    <published>2022-10-27T06:32:00.000Z</published>
    <updated>2022-10-28T12:33:03.615Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、对比度"><a href="#一、对比度" class="headerlink" title="一、对比度"></a>一、对比度</h1><h2 id="亮度对比"><a href="#亮度对比" class="headerlink" title="亮度对比"></a>亮度对比</h2><p>改变光线的明暗差别，可以提高物体的立体感。当有光照到的亮部和阴影位置的暗部差别很大的时候，物体看起来更加立体。所以天气不好或者阴天的时候建筑立体感看起来要差一些。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210271427490.png"><br>大范围设置：<font color="#0070c0">对比度</font><br>更精细设置：<font color="#0070c0">高光</font>和<font color="#0070c0">阴影</font>以及<font color="#0070c0">黑白色阶</font>设置，它基本上只影响了直方图左右两端的曲线，也就是非常亮和非常暗的区域（直方图从左到右分别是黑色色阶、阴影、曝光度、高光和白色色阶）。 </p><h2 id="颜色的明亮度对比"><a href="#颜色的明亮度对比" class="headerlink" title="颜色的明亮度对比"></a>颜色的明亮度对比</h2><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210271428890.png"><br>在<font color="#0070c0">HSL颜色工具中的</font><font color="#0070c0">明亮度</font>设置，可以将主体和背景的颜色拉开对比， 同样可以获得很好的立体感提升。</p><h1 id="二、清晰度"><a href="#二、清晰度" class="headerlink" title="二、清晰度"></a>二、清晰度</h1><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210271429623.png"><br><font color="#0070c0">纹理</font>是用来增加细节的很好方法，特别是建筑纹理或者不同材质材料的纹路。<br><font color="#0070c0">清晰度</font>的调整范围要比纹理更大，不仅影响纹理，还影响整张照片所有物体边缘的明暗对比。增加清晰度可以看到阴影部分变得更暗，<u>它和对比度参数最大的不同是：对比度设置会降低暗部提高亮度，提高亮部的亮度。而清晰度设置对物体边缘暗部的影响要更大，而高光只有一点点变化。</u></p><h1 id="三、锐化"><a href="#三、锐化" class="headerlink" title="三、锐化"></a>三、锐化</h1><p>在Lightroom的细节工具当中，<font color="#0070c0">锐化</font>是后期时常用的细节增强工具。锐化会给照片中所有的物体边缘带来非常强烈的对比。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210271424301.png"><br><font color="#00b050">数量参数</font>通常控制在50以下，避免过度锐化带来更多噪点。<br><font color="#00b050">半径参数</font>指锐化边缘的范围，半径数值从0到3.0像素，避免过度使用的话控制在1-1.5之间。<br><font color="#00b050">蒙版设置</font>是用来去掉一些不该被锐化的区域，例如只想要锐化建筑，但是并不想影响云和天空，添加蒙版就可以去掉这些区域的锐化效果</p><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p><a href="https://www.bilibili.com/video/BV1nz4y117Ub/">【Edi x TourBox后期训练营】提高照片质感的方法 - 对比度/清晰度/锐化可以为照片带来什么样改变_哔哩哔哩_bilibili</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、对比度&quot;&gt;&lt;a href=&quot;#一、对比度&quot; class=&quot;headerlink&quot; title=&quot;一、对比度&quot;&gt;&lt;/a&gt;一、对比度&lt;/h1&gt;&lt;h2 id=&quot;亮度对比&quot;&gt;&lt;a href=&quot;#亮度对比&quot; class=&quot;headerlink&quot; title=&quot;亮度对比&quot;</summary>
      
    
    
    
    <category term="摄影后期" scheme="https://www.daipeihong.top/categories/%E6%91%84%E5%BD%B1%E5%90%8E%E6%9C%9F/"/>
    
    
    <category term="lightroom" scheme="https://www.daipeihong.top/tags/lightroom/"/>
    
    <category term="提升质感" scheme="https://www.daipeihong.top/tags/%E6%8F%90%E5%8D%87%E8%B4%A8%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>车规芯片(四)  leon2处理器</title>
    <link href="https://www.daipeihong.top/2022/10/24/che-gui-xin-pian-si-leon2-chu-li-qi/"/>
    <id>https://www.daipeihong.top/2022/10/24/che-gui-xin-pian-si-leon2-chu-li-qi/</id>
    <published>2022-10-24T12:21:00.000Z</published>
    <updated>2022-10-30T01:00:17.777Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p><span style="background:rgba(240, 200, 0, 0.2)">leon2处理器是一款开源的、符合SPARC(可扩展处理器体系架构) V8规范的、采用RISC 结构的32位处理器I P 核。</span>它可以从互联网上免费下载使用。Leon2是以VHDL 形式存在的软核、完全可综合、内部硬件资源可裁剪、主要面向嵌入式应用系统、可以用FPGA/CPLD 和ASIC等技术实现。</p><h1 id="二、leno2处理器结构"><a href="#二、leno2处理器结构" class="headerlink" title="二、leno2处理器结构"></a>二、leno2处理器结构</h1><h3 id="处理器单元"><a href="#处理器单元" class="headerlink" title="处理器单元"></a>处理器单元</h3><p>处理器单元由<font color="#ff0000">整数单元IU</font>、<font color="#ff0000">浮点单元FPU</font>、<font color="#ff0000">协处理器单元CP</font>构成。</p><ul><li>整数单元的特点有：5级指令流水、分离的数据和指令Cache、支持2~32个寄存器窗口、可选的4个观察口寄存器、可配置乘法器、可选的16×16位MAC(40位累加器)、基2除法器。</li><li>可支持的浮点处理器有GaislerResearch的GRFPU，Sun Microsystems的Meiko FPU或其他通用浮点处理单元。</li><li>Leon2提供了一个通用的用户可定义的协处理器，同IU并行运行增强了系统功能。</li></ul><h3 id="Cache子系统"><a href="#Cache子系统" class="headerlink" title="Cache子系统"></a>Cache子系统</h3><p>可配置的模式有直接映射模式和2~4组相联的多组相联模式；可选的三种替换算法是LRU、LRR和伪随机。</p><h3 id="片上外设"><a href="#片上外设" class="headerlink" title="片上外设"></a>片上外设</h3><p>片上外设包括：2个中断控制器、2个UART、2个Timer和1个Watchdog、16位的I／O口、存储器控制器(PROM、SRAM、S13RAM)、PCI桥接器、Ethernet接口、高级片上调试支持单元(DSU)和跟踪缓冲器等．中断控制器可以最大处理46个内部和外部中断。2个串行通信口 (UART)，支持8位数据帧、1位校验位、1位停止位，支持硬件流控功能。调试支持单元(DSU)能够把处理器设置到调试模式，通过它可以读写处理器的所有寄存器和Cache。DSU还包括一个跟踪缓存，可以保存已执行了的指令和AHB上传输的数据。</p><p>开源的 LEON2 处理器版本中包括：<u>整数处理单元（Integer Unit，IU），独立的指令缓存（I-Cache）模块和数据缓存（D-Cache）模块，16 位I/O 端口，存储器控制器模块（Memory Controller）等等。</u>根据需求，设计者可以通过片上AMBA AHB/APB 总线控制器实现外设的添加。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210260836471.png" alt="|500"></p><h1 id="三、Leon2的技术特点"><a href="#三、Leon2的技术特点" class="headerlink" title="三、Leon2的技术特点"></a>三、Leon2的技术特点</h1><p>Leon2的技术特点主要有：<span style="background:rgba(240, 107, 5, 0.2)">采用SPARC V8结构</span>、<span style="background:rgba(240, 107, 5, 0.2)">采用内部AMBA总线结构</span>、<span style="background:rgba(240, 107, 5, 0.2)">容错设计</span>和<span style="background:rgba(240, 107, 5, 0.2)">VHDL编程风格</span>。</p><h2 id="SPARC-V8"><a href="#SPARC-V8" class="headerlink" title="SPARC V8"></a>SPARC V8</h2><p>SPARC是可扩展处理器体系架构的首字母缩略词，是一个从RISC派生出的CPU指令集结构(ISA)。指令集结构是指：定义了指令、寄存器、指令和数据存储器、指令执行对寄存器和存储器的影响、控制指令执行的算法等内容，但不定义时钟周期、每条指令的执行时钟周期数(CPI)、数据通路等内容。作为一个结构，SPARC允许在具有不同性能价格比的广泛应用中，实现不同系列的芯片和系统，包括科学、工程、编程、实时和商业应用等。<span style="background:rgba(240, 200, 0, 0.2)">SPARC的设计目标是优化编译器和易于硬件流水线实现。</span></p><h3 id="指令集架构"><a href="#指令集架构" class="headerlink" title="指令集架构"></a>指令集架构</h3><p>&nbsp;所有指令都编码成32位格式，可以分成六个基本的类型，一共有72条指令。六种基本的指令分别是：①Load／store；②Arthmetic／logical／shift；③Control transfer；④Read／write control register；⑤Floating-point operate；⑥Coprocessor operate。<br>&nbsp;### 寄存器窗口<br>它是SPARC的最大技术特点。SPARC处理器包括两种寄存器：一种是<span style="background:rgba(240, 200, 0, 0.2)">通用寄存器</span>，另一种是<span style="background:rgba(240, 200, 0, 0.2)">控制／状态寄存器</span>。其中整数单元中的控制/状态寄存器主要负责记录<br>处理器状态和计数等任务，包括PSR，WIM，TBR，PC，ASRs 等；而整数单元的通用寄存器，则<u>采用独特寄存器窗口的实现方式来提高处理器运行效率</u>，这也是SPARC  架构区别于架构设计之处。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210260939296.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210260941294.png"><br>IU的通用寄存器叫r寄存器。一个IU(整数元)的实现可能包括40<del>520个32位r寄存器。这些寄存器又被分成8个全局寄存器，再加上2</del>32个与实现有关的16位寄存器组，每一个寄存器组又进一步分为8个输入寄存器和8个输出寄存器。<br>&nbsp;<img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210260926694.png" alt="|500"><br>&nbsp;<img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210260932765.png" alt="|500"><br>上图是一个8窗口寄存器结构示意图。在任何一个时刻，一条指令只能访问8个全局寄存器和由当前窗口指针(CWP)指定的当前窗口。这个窗口是由8个输入寄存器、8个局部寄存器和8个输入寄存器构成。从图中可以看出，两个相邻窗口的入和出寄存器是共享的。<u>当前是按窗口号顺序(或前或后)转换的，正好上一次的输出寄存器成为当前窗口的输入寄存器，这样可以减少存储器读写和运行时的现场保护。</u></p><h2 id="AMBA"><a href="#AMBA" class="headerlink" title="AMBA"></a>AMBA</h2><p>&nbsp;AMBA(Advanced Microntroller Bus Architecture)规范，是一种已制定的、开放的规范，充当着SoC设计的架构，正迅速成为SoC和IP库开发事实上的标准，为高性能嵌入式微控制器设计定义了一种片上通信标准。<br>&nbsp;AMBA规范中定义了三种不同的总线,即 AHB 、ASB 和 APB 。<br>&nbsp;* AHB 是为高性能、高时钟频率的系统模块提供的,担任着高性能系统的背板总线、支持多处理器、片上各种存储器和片外外部存储器接口连接到低功耗辅助宏单元。<br>&nbsp;* ASB也是为高性能系统模块提供,当AHB 的高性能特点无需要时,就可以用ASB 来代替；它也支持多处理器、片上各种存储器和片外外部存储器接口连接到低功耗辅助宏单元。<br>&nbsp;* APB 是为低功耗的外围设备提供的,它优化到为最小功耗和减小接口的复杂性来支持辅助功能。</p><h2 id="容错问题"><a href="#容错问题" class="headerlink" title="容错问题"></a>容错问题</h2><p>为了适用于航空航天的高可靠性应用，Leon2采用多层次的容错策略；奇偶校验、TMR(三模冗余)寄存器、片上EDAC(检错和纠错)、流水线重启、强迫Cache不命中等．尽管现在几乎所有CPU都有一些常规的容错措施，如奇偶校验、流水线重启等，像IBM S／390 G5还采用了写阶段以前的全部流水线复制技术。IntelItanium采用的混合ECC和校验编码等技术；但远没有Leon2那样，采用如此全面的容错措施。</p><p>Leon2将时序(存储)单元的状态翻转作为数字容错的主要内容，根据时序逻辑的不同特点和性质，采用了不同的容错技术和手段．</p><h3 id="Cache的容错"><a href="#Cache的容错" class="headerlink" title="Cache的容错"></a>Cache的容错</h3><p>大的Cache对高性能CPU来说是至关重要的，而且位于处理器的关键(时间)通路上。为了减少复杂性和时间开销，错误检测的方法<span style="background:rgba(240, 200, 0, 0.2)">采用2位的奇偶校验位，l位用作奇校验，l位偶校验</span>，因此可以检查所有的错误情况，在读Cache的同时进行校验。当校验出错误，强制Cache丢失，并从外部存储去获取数据。</p><h3 id="处理器寄存器文件的错误保护"><a href="#处理器寄存器文件的错误保护" class="headerlink" title="处理器寄存器文件的错误保护"></a>处理器寄存器文件的错误保护</h3><p>寄存器文件是处理器内部的寄存器堆，内部的寄存器对于指令的运行速度和用户程序设计的灵活程度都是很重要的。内部寄存器的使用频率很大，其状态的正确性是也很关键。Leon2<span style="background:rgba(240, 200, 0, 0.2)">采用1、2奇偶校验位和(32.7)BCH校验和进行容错</span>。</p><h3 id="触发器的错误保护"><a href="#触发器的错误保护" class="headerlink" title="触发器的错误保护"></a>触发器的错误保护</h3><p>处理器的2500个触发器均<span style="background:rgba(240, 200, 0, 0.2)">采用三模冗余的方式进行容错</span>，通过表决器来决出正确的输出。</p><h3 id="外部存储器的错误保护"><a href="#外部存储器的错误保护" class="headerlink" title="外部存储器的错误保护"></a>外部存储器的错误保护</h3><p>采用挂上的EDAC单元实现。EDAC：<span style="background:rgba(240, 200, 0, 0.2)">采用标准的(32.7)BCH码，每32位字可纠正1位错误和检测2位错误。</span></p><h3 id="主检测模式"><a href="#主检测模式" class="headerlink" title="主检测模式"></a>主检测模式</h3><p>是指<span style="background:rgba(240, 200, 0, 0.2)">两个相同的处理器同时并行执行相同的指令，只让其中的主模式处理器输出结果，不让检测模式的处理器输出结果</span>。在内部，将检测模式处理器的输出同主模式处理器输出进行比较，以检查错误是否存在。这种工作模式，可以应用于要求更高可靠性的情况。</p><h3 id="Cache的清洗"><a href="#Cache的清洗" class="headerlink" title="Cache的清洗"></a>Cache的清洗</h3><p>因为上面介绍的五种方法，只有在对相应的单元进行访问时才进行错误检查。如果存储单元的数据不常使用，这些单元的错误会逐渐增加，因此必须<span style="background:rgba(240, 200, 0, 0.2)">使用一些软件的方法来实现</span>。</p><h2 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h1&gt;&lt;p&gt;&lt;span style=&quot;background:rgba(240, 200, 0, 0.2)&quot;&gt;leon2处理器是一款开源的</summary>
      
    
    
    
    <category term="数字IC" scheme="https://www.daipeihong.top/categories/%E6%95%B0%E5%AD%97IC/"/>
    
    
    <category term="leon2处理器" scheme="https://www.daipeihong.top/tags/leon2%E5%A4%84%E7%90%86%E5%99%A8/"/>
    
    <category term="车规芯片" scheme="https://www.daipeihong.top/tags/%E8%BD%A6%E8%A7%84%E8%8A%AF%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>Obsidan(四)  自带callout用法</title>
    <link href="https://www.daipeihong.top/2022/10/24/obsidan-si-zi-dai-callout-yong-fa/"/>
    <id>https://www.daipeihong.top/2022/10/24/obsidan-si-zi-dai-callout-yong-fa/</id>
    <published>2022-10-24T11:07:00.000Z</published>
    <updated>2022-10-24T11:07:58.940Z</updated>
    
    <content type="html"><![CDATA[<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><pre class=" language-markdown"><code class="language-markdown"><span class="token blockquote punctuation">></span> [!INFO]<span class="token blockquote punctuation">></span> 内容（它支持<span class="token bold"><span class="token punctuation">**</span>markdown<span class="token punctuation">**</span></span>，维基链接和嵌入内容）</code></pre><blockquote><p>[!INFO]<br>内容（它支持<strong>markdown</strong>，<a href="https://help.obsidian.md/How+to/Internal+link">维基链接</a>和<a href="https://help.obsidian.md/How+to/Embed+files">嵌入</a>！）</p></blockquote><h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><ol><li>note<blockquote><p>[!note]<br>内容</p></blockquote></li><li>abstract, summary, tldr<blockquote><p>[!abstract]<br>内容</p></blockquote></li><li>info, todo<blockquote><p>[!info]<br>内容</p></blockquote></li><li>tip, hint, important<blockquote><p>[!tip]<br>内容</p></blockquote></li><li>success, check, done<blockquote><p>[!success]<br>内容</p></blockquote></li><li>question, help, faq<blockquote><p>[!question]<br>内容</p></blockquote></li><li>warning, caution, attention<blockquote><p>[!warning]<br>内容</p></blockquote></li><li>failure, fail, missing<blockquote><p>[!failure]<br>内容</p></blockquote></li><li>danger, error<blockquote><p>[!danger]<br>内容</p></blockquote></li><li>bug<blockquote><p>[!bug]<br>内容</p></blockquote></li><li>example<blockquote><p>[!example]<br>内容</p></blockquote></li><li>quote, cite<blockquote><p>[!quote]<br>内容</p></blockquote></li></ol><h1 id="自定义标题"><a href="#自定义标题" class="headerlink" title="自定义标题"></a>自定义标题</h1><pre class=" language-markdown"><code class="language-markdown"><span class="token blockquote punctuation">></span> [!TIP] Callouts can have custom titles, which also supports <span class="token bold"><span class="token punctuation">**</span>markdown<span class="token punctuation">**</span></span>!</code></pre><blockquote><p>[!TIP] Callouts can have custom titles, which also supports <strong>markdown</strong>!<br>内容</p></blockquote><h1 id="折叠"><a href="#折叠" class="headerlink" title="折叠"></a>折叠</h1><p><strong>使用&nbsp;<code>+</code>&nbsp;默认展开或者&nbsp;<code>-</code>&nbsp;默认折叠正文部分</strong><br><strong>默认展开</strong>：</p><pre class=" language-markdown"><code class="language-markdown"><span class="token blockquote punctuation">></span> [!important]+<span class="token blockquote punctuation">></span> 可以使用<span class="token entity" title="&nbsp;">&amp;nbsp;</span><span class="token code keyword">`+`</span><span class="token entity" title="&nbsp;">&amp;nbsp;</span>默认展开或者<span class="token entity" title="&nbsp;">&amp;nbsp;</span><span class="token code keyword">`-`</span><span class="token entity" title="&nbsp;">&amp;nbsp;</span>默认折叠正文部分</code></pre><blockquote><p>[!important]+<br>可以使用&nbsp;<code>+</code>&nbsp;默认展开或者&nbsp;<code>-</code>&nbsp;默认折叠正文部分</p></blockquote><p><strong>默认折叠</strong>：</p><pre class=" language-markdown"><code class="language-markdown"><span class="token blockquote punctuation">></span> [!important]-<span class="token blockquote punctuation">></span> 可以使用<span class="token entity" title="&nbsp;">&amp;nbsp;</span><span class="token code keyword">`+`</span><span class="token entity" title="&nbsp;">&amp;nbsp;</span>默认展开或者<span class="token entity" title="&nbsp;">&amp;nbsp;</span><span class="token code keyword">`-`</span><span class="token entity" title="&nbsp;">&amp;nbsp;</span>默认折叠正文部分</code></pre><blockquote><p>[!important]-<br>可以使用&nbsp;<code>+</code>&nbsp;默认展开或者&nbsp;<code>-</code>&nbsp;默认折叠正文部分</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h2&gt;&lt;pre class=&quot; language-markdown&quot;&gt;&lt;code class=&quot;language-markdown&quot;&gt;&lt;span cla</summary>
      
    
    
    
    <category term="猎奇" scheme="https://www.daipeihong.top/categories/%E7%8C%8E%E5%A5%87/"/>
    
    
    <category term="Obsidian" scheme="https://www.daipeihong.top/tags/Obsidian/"/>
    
    <category term="callout" scheme="https://www.daipeihong.top/tags/callout/"/>
    
  </entry>
  
  <entry>
    <title>SystemVerilog课程笔记(六)</title>
    <link href="https://www.daipeihong.top/2022/10/24/systemverilog-ke-cheng-bi-ji-liu/"/>
    <id>https://www.daipeihong.top/2022/10/24/systemverilog-ke-cheng-bi-ji-liu/</id>
    <published>2022-10-24T00:27:00.000Z</published>
    <updated>2022-11-18T04:54:31.120Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-将数据传输从结构体改造为类"><a href="#1-将数据传输从结构体改造为类" class="headerlink" title="1. 将数据传输从结构体改造为类"></a>1. 将数据传输从结构体改造为类</h1><h2 id="1-1-改造"><a href="#1-1-改造" class="headerlink" title="1.1 改造"></a>1.1 改造</h2>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211161658402.png" width="700" height="150" title=" ">        <h2 id="1-2-改造后的tb-sv"><a href="#1-2-改造后的tb-sv" class="headerlink" title="1.2 改造后的tb.sv"></a>1.2 改造后的tb.sv</h2><pre class=" language-systemverilog"><code class="language-systemverilog">class rt_packet;  bit [3:0] src;  bit [3:0] dst;  bit [7:0] data [];  function void set_members(bit [3:0]src, bit [3:0]dst, bit[7:0]data []);    this.src = src;    this.dst = dst;    this.data = data;  endfunctionendclassinterface rt_interface();    logic clock;    logic reset_n;    logic [15:0] din;    logic [15:0] frame_n;    logic [15:0] valid_n;    logic [15:0] dout;    logic [15:0] valido_n;    logic [15:0] busy_n;    logic [15:0] frameo_n;endinterface//********************************** stimulator **********************************//module rt_stimulator(    rt_interface intf);//for debug purpose from waveform//定义检测状态的变量  typedef enum {DRV_RESET,DRV_IDLE,DRV_ADDR,DRV_PAD,DRV_DATA} drv_state_t;  drv_state_t dbg_state;    byte unsigned dbg_din_chnl0_data;   int src_chnl_status[int];  //关联数组，后面int：src_chnl的number；前面int：dest_chnl的Number ？？    //generator传送p给stimulator  rt_packet pkts[$];//定义stimulator中的的队列pkts  function void put_pkt(input rt_packet p);    pkts.push_back(p);//将generator中传过来的p放入stimulator的pkts中(在pkts队列尾插入p)  endfunction//reset阶段，复位时，reset_n为低电平,frame_n和valid_n为高电平initial begin : drive_reset_proc   drive_reset();endtask drive_reset();  @(negedge intf.reset_n);  dbg_state <= DRV_RESET;  intf.din <= 0;  intf.frame_n <= '1;//等效16'hFFFF  intf.valid_n <= '1;endtask// 发送数据initial begin : drive_chnl_proc    //rt_packet_t p;  @(negedge intf.reset_n);  repeat(10) @(posedge intf.clock);//延迟10个时钟周期  forever begin    automatic rt_packet p;//声明一个动态的    wait(pkts.size()>0);    p = pkts.pop_front();//将p从队列pkts里面取出    fork//后台触发线程，触发线程在后台运行，继续执行剩下内容        begin            wait_src_chnl_avail(p);//判断src chnl是否被占用，是否需要等待            drive_chnl(p.src, p.dst, p.data);//从P中拿到发送端口，目标端口，发送数据            set_src_chnl_avail(p);        end    join_none    endendtask automatic wait_src_chnl_avail(rt_packet p);//判断src chnl是否被占用，是否需要等待    if(!src_chnl_status.exists(p.src))//src_chnl_status关联数组里面不含p.src，(表示未占用任何dest_chnl,一开始不满足）        src_chnl_status[p.src] = p.dst;//表示当前正在使用src_chnl,对应dest_chnl就是p.dst（p.src端口在向p.dst端口发送数据）    else if(src_chnl_status[p.src] >= 0)//如果在给0,1,2...dest_chnl发送数据（被占用），需要等待,，否则不需要等待        wait(src_chnl_status[p.src] == -1);//直到src_chnl_status[p.src] == -1(自定义的dest_chnl端口数之外任意的数，表示未占用任何dest_chnl)endtaskfunction automatic set_src_chnl_avail(rt_packet p);    src_chnl_status[p.src] = -1;//如果chnl发送完后，把src_chnl置回来(自定义的dest_chnl端口数之外任意的数，表示未占用任何dest_chnl)endfunctiontask automatic drive_chnl(bit[3:0] saddr, bit [3:0] daddr, byte unsigned data[]);  $display("@%0t: [DRV]src_chnl[%0d],dest_chnl[%0d] data trans started",$time,saddr,daddr);    // drive address phase 输入地址位阶段for(int i=0;i<4;i++)begin  //4 clock  @(posedge intf.clock);  dbg_state <=DRV_ADDR;  intf.din[saddr] <= daddr[i];  intf.valid_n[saddr] <= $urandom_range(0,1);//valid_n在din的地址输入时间段可为任意值x  intf.frame_n[saddr] <= 1'b0;//frame_n需要为低end    // drive pad phase //隔离阶段  for (int i=0;i<5;i++)begin  //5 clock    @(posedge intf.clock);    dbg_state <=DRV_PAD;    intf.din[saddr] <= 1'b1;    intf.valid_n[saddr] <= 1'b1;//valid_n需为高电平    intf.frame_n[saddr] <= 1'b0; //frame_n需为低电平  end    // drive data phase 传输数据阶段  foreach(data[id])begin    for(int i=0;i<8;i++)begin     @(posedge intf.clock);      dbg_state <=DRV_DATA;      dbg_din_chnl0_data <= data[id];      intf.din[saddr] <= data[id][i];      intf.valid_n[saddr] <=1'b0;      intf.frame_n[saddr] <= (id == data.size()-1 && i == 7) ? 1'b1 : 1'b0;//packet最后一位输出数据时frameo_n为高    end  end// drive idle phase 闲置（没有数据传输）阶段  @(posedge intf.clock);  dbg_state <=DRV_IDLE;  dbg_din_chnl0_data <= 0;  intf.din[saddr] <= 1'b0;  intf.valid_n[saddr] <= 1'b1;  intf.frame_n[saddr] <= 1'b1;  $display("@%0t: [DRV]src_chnl[%0d],dest_chnl[%0d] data trans finished",$time,saddr,daddr);endtaskendmodule//********************************** generator **********************************//module rt_generator;//generator产生数据交给stimulator  rt_packet pkts[$];//定义队列  function void put_pkt(input rt_packet p);    pkts.push_back(p);//将p放入队列pkts里面（在pkts队列尾插入p）  endfunction    task get_pkt(output rt_packet p);    wait(pkts.size() >0 )//队列不为空      p = pkts.pop_front();//将p从队列pkts里面取出，提取队列首元素  endtask  //generate a random packet  function void gen_pkt(int src = -1, int dst = -1);  endfunctionendmodule//********************************** monitor **********************************//module rt_monitor(rt_interface intf);    rt_packet in_pkts[16][$];    rt_packet out_pkts[16][$];    initial begin : mon_chnl_proc        foreach(in_pkts[i]) begin            automatic int chid = i;            fork            mon_chnl_in(chid);//每个输入端口均调用mon_chnl_in任务，监测数据输入            mon_chnl_out(chid);//每个输出端口均调用mon_chnl_out任务，监测数据输入            join_none        end    end    task automatic mon_chnl_in (bit[3:0]id);//监测数据输入的任务    rt_packet pkt;//定义结构体变量    forever begin    //clear content for the same struct variable。清除pkt    pkt = new();    pkt.src = id;//第id个输入端口    //monitor specific channel-in data and put it into the queue    // monitor address phase    @(negedge intf.frame_n[id]);//监测frame_n下降沿(frame_n由时钟驱动)    for(int i=0; i<4; i++)begin        @(negedge intf.clock);//frame_n下降沿后监测4个clk negedge        pkt.dst[i]= intf.din[id];        end        $display ("@%0t: [MON] src_chn1[%0d] & dest_chn1[%0d] data trans started",$time,pkt.src,pkt.dst);    //pass pad phase 不考虑pad阶段是否满足协议要求    repeat(5) @(negedge intf.clock);    do begin        pkt.data = new [pkt.data.size + 1](pkt.data);//创建动态数组并复制pkt.data        for ( int i=0; i<8; i++) begin            @(negedge intf.clock); //在8个clk negedge监测8bit数据            pkt.data[pkt.data.size-1][i] = intf.din[id];        end    end while(!intf.frame_n[id]);    in_pkts[id].push_back(pkt);//将monitor拿到的数据放入in_pkts    $display("@%0t: [MON] src_chn1[%0d] & dest_chn1[%0d] data trans [%0p] finished",$time,pkt.src,pkt.dst,pkt.data);    endendtasktask automatic mon_chnl_out(bit[ 3:0]id);//监测数据输出的任务    rt_packet pkt;    forever begin        //clear content for the same struct variable        pkt = new();        pkt.src = 0;        pkt.dst = id;        @(negedge intf.frameo_n[id]);        $display( "@%0t: [MON] CH_OUT dest_chn1[%0d] data trans started",$time,pkt.dst);        do begin        pkt.data = new [ pkt.data.size + 1](pkt.data);        for(int i=0;i<8; i++) begin            @(negedge intf.clock iff !intf.valido_n[id]);//clock与valido_n信号同时为低            pkt.data[pkt.data.size-1][i]= intf.dout [id];        end    end while(!intf.frameo_n[id]);    out_pkts[id].push_back(pkt);    $display("@%0t: [MON] CH_OUT dest_chn1[%0d] data trans [%0p] finished",$time,pkt.dst,pkt.data);    //monitor specific channel-out data and put it into the queue    endendtaskendmodule//********************************** tb **********************************//module tb;bit clk,rstn;logic [15:0] din, frame_n, valid_n;logic [15:0] dout, valido_n, busy_n, frameo_n;// 产生时钟，周期为10nsinitial     forever #5ns clk <= !clk;// 产生复位信号  initial begin    #2ns rstn <= 1;    #10ns rstn <= 0;    #10ns rstn <= 1;  end//例化router为DUTrouter dut(             .reset_n(rstn),  .clock(clk),  .frame_n(intf.frame_n),  .valid_n(intf.valid_n),  .din(intf.din),  .dout(intf.dout),  .busy_n(intf.busy_n),  .valido_n(intf.valido_n),  .frameo_n(intf.frameo_n));rt_interface intf();//例化接口    assign intf.reset_n = rstn;    assign intf.clock = clk;    //例化stimulatorrt_stimulator stim(intf);//例化Monitorrt_monitor mon(intf);//例化generatorrt_generator gen();    initial begin:generate_data_proc//产生数据        rt_packet p;        p = new();        p.set_members(0,3,'{8'h33,8'h77});        gen.put_pkt(p);        p = new();//每次put_pkt都需要new一下        p.set_members(0,5,'{8'h55,8'h66});        gen.put_pkt(p);        p = new();        p.set_members(3,6,'{8'h77,8'h88,8'h22});        gen.put_pkt(p);        p = new();        p.set_members(4,7,'{8'haa,8'hcc,8'h33});        gen.put_pkt(p);    endinitial begin:genarator_to_stimulator_proc//取出genarator中的数据给stimulator    rt_packet p;    forever begin        gen.get_pkt(p);        stim.put_pkt(p);    endendendmodule </code></pre><h2 id="1-3-仿真结果"><a href="#1-3-仿真结果" class="headerlink" title="1.3 仿真结果"></a>1.3 仿真结果</h2>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211161639835.png" width="500" height="500" title=" ">        <h1 id="2-将drive-chnl任务的输入改为类"><a href="#2-将drive-chnl任务的输入改为类" class="headerlink" title="2. 将drive_chnl任务的输入改为类"></a>2. 将drive_chnl任务的输入改为类</h1><h2 id="2-1-改造"><a href="#2-1-改造" class="headerlink" title="2.1 改造"></a>2.1 改造</h2><p><strong>(1)增加打印函数</strong></p><pre class=" language-systemverilog"><code class="language-systemverilog">  function string sprint();//打印packet信息的函数    sprint = {sprint , $sformatf("src = %0d\n",src)};    sprint = {sprint , $sformatf("dst = %0d\n",dst)};    sprint = {sprint , $sformatf("data_length = %0d\n",data.size())};    foreach(data[i])        sprint = {sprint , $sformatf("data[%0d] = 'h%0x\n", i, data[i])};  endfunction</code></pre><p><strong>(2)将drive_chnl任务的输入改为类</strong></p><pre class=" language-systemverilog"><code class="language-systemverilog">task automatic drive_chnl(rt_packet p);</code></pre><h2 id="2-2-改造后的tb-sv"><a href="#2-2-改造后的tb-sv" class="headerlink" title="2.2 改造后的tb.sv"></a>2.2 改造后的tb.sv</h2><pre class=" language-systemverilog"><code class="language-systemverilog">class rt_packet;  bit [3:0] src;  bit [3:0] dst;  bit [7:0] data [];  function new();  endfunction  function void set_members(bit [3:0]src, bit [3:0]dst, bit[7:0]data []);    this.src = src;    this.dst = dst;    this.data = data;  endfunction  function string sprint();    sprint = {sprint , $sformatf("src = %0d\n",src)};    sprint = {sprint , $sformatf("dst = %0d\n",dst)};    sprint = {sprint , $sformatf("data_length = %0d\n",data.size())};    foreach(data[i])        sprint = {sprint , $sformatf("data[%0d] = 'h%0x\n", i, data[i])};    endfunction    endclass//**********************************  rt_stimulator  ***********************************//interface rt_interface;    logic clock;    logic reset_n;    logic [15:0] din;    logic [15:0] frame_n;    logic [15:0] valid_n;    logic [15:0] dout;    logic [15:0] valido_n;    logic [15:0] busy_n;    logic [15:0] frameo_n;endinterface    module rt_stimulator(  rt_interface intf);//for debug purpose from waveform    typedef enum {DRV_RESET,DRV_IDLE,DRV_ADDR,DRV_PAD,DRV_DATA} drv_state_t;    drv_state_t dbg_state;//定义状态检测变量dbg_state    byte unsigned dbg_din_chnl0_data;    rt_packet pkts[$];//队列里面存放的将是rt_packet句柄而不再是实际的对象    int src_chnl_status[int];  //关联数组，后面int：src_chnl的number；前面int：dest_chnl的Number ？？    function void put_pkt(input rt_packet p);        pkts.push_back(p);    endfunction    initial begin : drive_reset_proc        drive_reset();    end    task drive_reset();        @(negedge intf.reset_n);        dbg_state <= DRV_RESET;        intf.din <= 0;        intf.frame_n <= '1;        intf.valid_n <= '1;    endtask    initial begin : drive_chnl_proc        @(negedge intf.reset_n);        repeat(10) @(posedge intf.clock);        forever begin             automatic rt_packet p;//声明一个动态的            wait(pkts.size() > 0);            p = pkts.pop_front();            fork//后台触发线程，触发线程在后台运行，继续执行剩下内容                begin                wait_src_chnl_avail(p);                drive_chnl(p);                set_src_chnl_avail(p);                end            join_none        end    end        task automatic wait_src_chnl_avail(rt_packet p);//判断src chnl是否被占用，是否需要等待    if(!src_chnl_status.exists(p.src))//动态数组为空        src_chnl_status[p.src] = p.dst;//表示当前正在使用src_chnl,对应dest就是p.dst    else if(src_chnl_status[p.src] >= 0)//如果给dest的0,1,2这样的chnl在发送数据，需要等待        wait(src_chnl_status[p.src] == -1);//直到    endtask        function automatic set_src_chnl_avail(rt_packet p);        src_chnl_status[p.src] = -1;//如果chnl发送完后，把src_chnl置回来    endfunction    task automatic drive_chnl(rt_packet p);        $display("@%0t:[DRV] src_chnl[%0d] & dest_chnl[%0d] data trans started with packet: \n %s",$time,p.src,p.dst,p.sprint());// drive address phase         for(int i=0; i<4; i++)begin        @(posedge intf.clock);        dbg_state <=DRV_ADDR;        intf.din[p.src] <= p.dst[i];        intf.valid_n[p.src] <= $urandom_range(0,1);        intf.frame_n[p.src] <= 1'b0;    end// drive pad phase   for (int i=0; i<5; i++)begin    @(posedge intf.clock);    dbg_state <= DRV_PAD;    intf.din[p.src] <= 1'b1;    intf.valid_n[p.src] <= 1'b1;    intf.frame_n[p.src] <= 1'b0;  end// drive data phase  foreach(p.data[id])begin    for(int i=0;i<8; i++)begin    @(posedge intf.clock);    dbg_state <= DRV_DATA;    dbg_din_chnl0_data <= p.data[id];    intf.din[p.src] <= p.data[id][i];    intf.valid_n[p.src] <=1'b0;    intf.frame_n[p.src] <= (id == p.data.size()-1 && i == 7) ? 1'b1 : 1'b0;    end  end// drive idle phase  @(posedge intf.clock);  dbg_state <= DRV_IDLE;  dbg_din_chnl0_data <= 0;  intf.din[p.src] <= 1'b0;  intf.valid_n[p.src] <= 1'b1;  intf.frame_n[p.src] <= 1'b1;  $display("@%0t:[DRV] src_chnl[%0d] &dest_chnl[%0d ] finished",$time,p.src,p.dst);endtaskendmodule//**********************************  rt_generator  ************************************//module rt_generator;  rt_packet pkts[$];//定义队列pkts  function void put_pkt(input rt_packet p);    pkts.push_back(p);//在pkts队列尾插入p  endfunction  task get_pkt(output rt_packet p);    wait(pkts.size() >0 )      p = pkts.pop_front();//pkts.size()>0时执行，提取队列首元素，输出队列首元素  endtask  //generate a random packet  function void gen_pkt(int src = -1, int dst = -1);  endfunctionendmodulemodule rt_monitor(rt_interface intf);    rt_packet in_pkts[16][$];    rt_packet out_pkts[16][$];        initial begin: mon_chnl_proc        foreach(in_pkts[i])begin        automatic int chid = i;        fork             mon_chnl_in (chid);            mon_chnl_out (chid);        join_none        end    end        task automatic mon_chnl_in(bit[3:0] id);    rt_packet pkt;    forever begin        //clear content for the same struct variable        pkt = new();        pkt.dst = id;        //monitor specific channel-in data abd put in into the quene        //monitor adress phase        @(negedge intf.frame_n[id]);        for (int i = 0;i<4;i++)begin            @(negedge intf.clock);            pkt.dst[i] = intf.din[id];        end        $display("@%0t:[MON] CH_IN src_chnl[%0d] &dest_chnl[%0d ]data trans started",$time,pkt.src,pkt.dst);        //pass pad phase 不考虑pad阶段        repeat(5) @(negedge intf.clock);        do begin            pkt.data = new[pkt.data.size + 1] (pkt.data);            for (int i=0;i<8;i++)begin                @(negedge intf.clock);                pkt.data[pkt.data.size - 1][i] = intf.din[id];            end        end while(intf.frame_n[id]);        in_pkts[id].push_back(pkt);        $display("@%0t:[MON] CH_IN src_chnl[%0d] &dest_chnl[%0d ] finished with packet: \n %s",$time,pkt.src,pkt.dst,pkt.sprint());    end    endtask        task automatic mon_chnl_out(bit[3:0] id);        rt_packet pkt;    forever begin        //clear content for the same struct variable        pkt = new();        pkt.src = 0;        pkt.dst = id;        @(negedge intf.frameo_n[id]);        $display("@%0t:[MON] CH_OUT dest_chnl[%0d ]data trans started",$time,pkt.dst);        do begin            pkt.data = new[pkt.data.size + 1] (pkt.data);            for (int i=0;i<8;i++)begin                @(negedge intf.clock iff !intf.valido_n[id]);                pkt.data[pkt.data.size - 1][i] = intf.din[id];            end        end while(!intf.frameo_n[id]);        out_pkts[id].push_back(pkt);        $display("@%0t:[MON] CH_OUT dest_chnl[%0d ] finished with packet: \n %s",$time,pkt.dst,pkt.sprint());    end    endtaskendmodulemodule rt_test_top;endmodule//********************************** tb  ************************************//module tb;    bit clk,rstn;    logic [15:0] din, frame_n, valid_n;    logic [15:0] dout, valido_n, busy_n, frameo_n;    // generate clock    initial         forever #5ns clk <= !clk;    // genarate reset    initial begin        #2ns  rstn <= 1;        #10ns rstn <= 0;        #10ns rstn <= 1;    end    router dut(//例化router为dut        .reset_n(rstn)        ,.clock(clk)        ,.frame_n(intf.frame_n)        ,.valid_n(intf.valid_n)        ,.din(intf.din)        ,.dout(intf.dout)        ,.busy_n(intf.busy_n)        ,.valido_n(intf.valido_n)        ,.frameo_n(intf.frameo_n));    rt_interface intf(); //例化rt_interface为intf    assign intf.reset_n = rstn;    assign intf.clock = clk;        rt_stimulator stim(intf);//例化rt_stimulator为stim        rt_monitor mon(intf);        rt_generator gen(); //例化rt_generator为gen //generate and transmit packet 产生数据    initial begin : generate_proc        rt_packet p;        p = new();        p.set_members(0,3,'{8'h33,8'h77});        gen.put_pkt(p);        p = new();//每次put_pkt都需要new一下        p.set_members(0,5,'{8'h55,8'h66});        gen.put_pkt(p);        p = new();        p.set_members(3,6,'{8'h77,8'h88,8'h22});        gen.put_pkt(p);        p = new();        p.set_members(4,7,'{8'haa,8'hcc,8'h33});        gen.put_pkt(p);    end        initial begin : transmit_proc        rt_packet p;    forever  begin       gen.get_pkt(p);//generator输出p，p为generator里pkts的首元素      stim.put_pkt(p);//把数据p输入stim里的pkts队列尾   end  end  endmodule</code></pre><h2 id="2-3-仿真结果"><a href="#2-3-仿真结果" class="headerlink" title="2.3 仿真结果"></a>2.3 仿真结果</h2>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211171321867.png" width="400" height="1500" title=" ">        <h1 id="3-将stimulator、generator、monitor改为类"><a href="#3-将stimulator、generator、monitor改为类" class="headerlink" title="3. 将stimulator、generator、monitor改为类"></a>3. 将stimulator、generator、monitor改为类</h1><h2 id="3-1-改造"><a href="#3-1-改造" class="headerlink" title="3.1 改造"></a>3.1 改造</h2><p><strong>(1)将stimulator、generator、monitor从module改为class：</strong></p><pre class=" language-systemverilog"><code class="language-systemverilog">class rt_stimulator;    ...endclassclass rt_generator;    ...endclassclass rt_monitor;    ...endclass</code></pre><p><strong>(2)stimulator、generator、monitor的例化变为：</strong></p><pre class=" language-systemverilog"><code class="language-systemverilog">rt_stimulator stim;rt_monitor mon;rt_generator gen;        initial begin : inst_init_proc        //build stage,例化        stim = new();        gen = new();        mon = new();        //connect sage，连接        stim.intf = intf;        mon.intf = intf;        //run stage，run        fork            stim.run();//class里面的函数不会自动调用，需要手动调用            gen.run();            mon.run();        join_none    end</code></pre><p>类默认为动态，所以使用的automatic可以去掉<br><strong>(3)将drive_reset_proc和drive_chnl_proc这两个initial begin end语句改为task:</strong></p><pre class=" language-systemverilog"><code class="language-systemverilog">task run();    fork        drive_reset(); //reset动作        get_packet_and_drive(); //drive_chnl动作    join_noneendtask    task drive_reset();//reset    ...endtasktask drive_chnl_proc();//drive_chnl    ...endtask</code></pre><h2 id="3-2-改造后的tb-sv"><a href="#3-2-改造后的tb-sv" class="headerlink" title="3.2 改造后的tb.sv"></a>3.2 改造后的tb.sv</h2><pre class=" language-systemverilog"><code class="language-systemverilog">class rt_packet;  bit [3:0] src;  bit [3:0] dst;  bit [7:0] data [];  function new();  endfunction  function void set_members(bit [3:0]src, bit [3:0]dst, bit[7:0]data []);    this.src = src;    this.dst = dst;    this.data = data;  endfunction  function string sprint();//打印packet信息的函数    sprint = {sprint , $sformatf("src = %0d\n",src)};    sprint = {sprint , $sformatf("dst = %0d\n",dst)};    sprint = {sprint , $sformatf("data_length = %0d\n",data.size())};    foreach(data[i])        sprint = {sprint , $sformatf("data[%0d] = 'h%0x\n", i, data[i])};  endfunctionendclassinterface rt_interface();    logic clock;    logic reset_n;    logic [15:0] din;    logic [15:0] frame_n;    logic [15:0] valid_n;    logic [15:0] dout;    logic [15:0] valido_n;    logic [15:0] busy_n;    logic [15:0] frameo_n;endinterface//********************************** stimulator **********************************//class rt_stimulator;    virtual rt_interface intf;//class里的接口不能用端口的方式描述，需要添加virtual关键字，在类里面用接口的指针//for debug purpose from waveform//定义检测状态的变量  typedef enum {DRV_RESET,DRV_IDLE,DRV_ADDR,DRV_PAD,DRV_DATA} drv_state_t;  drv_state_t dbg_state;    byte unsigned dbg_din_chnl0_data;   int src_chnl_status[int];  //关联数组，后面int：src_chnl的number；前面int：dest_chnl的Number ？？    //generator传送p给stimulator  rt_packet pkts[$];//定义stimulator中的的队列pkts  function void put_pkt(input rt_packet p);    pkts.push_back(p);//将generator中传过来的p放入stimulator的pkts中(在pkts队列尾插入p)  endfunctiontask run();    fork        drive_reset(); //reset动作        get_packet_and_drive(); //drive_chnl动作    join_noneendtask    task drive_reset();//reset    forever begin        @(negedge intf.reset_n);        dbg_state <= DRV_RESET;        intf.din <= 0;        intf.frame_n <= '1;//等效16'hFFFF        intf.valid_n <= '1;    endendtask// 发送数据task get_packet_and_drive();//drive_chnl    //rt_packet_t p;  @(negedge intf.reset_n);  repeat(10) @(posedge intf.clock);//延迟10个时钟周期  forever begin    automatic rt_packet p;//声明一个动态的    wait(pkts.size()>0);    p = pkts.pop_front();//将p从队列pkts里面取出    fork//后台触发线程，触发线程在后台运行，继续执行剩下内容        begin            wait_src_chnl_avail(p);//判断src chnl是否被占用，是否需要等待            drive_chnl(p);//从P中拿到发送端口，目标端口，发送数据            set_src_chnl_avail(p);        end    join_none    endendtasktask  wait_src_chnl_avail(rt_packet p);//判断src chnl是否被占用，是否需要等待    if(!src_chnl_status.exists(p.src))//src_chnl_status关联数组里面不含p.src，(表示未占用任何dest_chnl,一开始不满足）        src_chnl_status[p.src] = p.dst;//表示当前正在使用src_chnl,对应dest_chnl就是p.dst（p.src端口在向p.dst端口发送数据）    else if(src_chnl_status[p.src] >= 0)//如果在给0,1,2...dest_chnl发送数据（被占用），需要等待,，否则不需要等待        wait(src_chnl_status[p.src] == -1);//直到src_chnl_status[p.src] == -1(自定义的dest_chnl端口数之外任意的数，表示未占用任何dest_chnl)endtaskfunction  set_src_chnl_avail(rt_packet p);    src_chnl_status[p.src] = -1;//如果chnl发送完后，把src_chnl置回来(自定义的dest_chnl端口数之外任意的数，表示未占用任何dest_chnl)endfunctiontask  drive_chnl(rt_packet p);  $display("@%0t:[DRV] src_chnl[%0d] & dest_chnl[%0d] data trans started with packet: \n%s",$time,p.src,p.dst,p.sprint());    // drive address phase 输入地址位阶段for(int i=0;i<4;i++)begin  //4 clock  @(posedge intf.clock);  dbg_state <=DRV_ADDR;  intf.din[p.src] <= p.dst[i];  intf.valid_n[p.src] <= $urandom_range(0,1);//valid_n在din的地址输入时间段可为任意值x  intf.frame_n[p.src] <= 1'b0;//frame_n需要为低end    // drive pad phase //隔离阶段  for (int i=0;i<5;i++)begin  //5 clock    @(posedge intf.clock);    dbg_state <=DRV_PAD;    intf.din[p.src] <= 1'b1;    intf.valid_n[p.src] <= 1'b1;//valid_n需为高电平    intf.frame_n[p.src] <= 1'b0; //frame_n需为低电平  end    // drive data phase 传输数据阶段  foreach(p.data[id])begin    for(int i=0;i<8;i++)begin     @(posedge intf.clock);      dbg_state <=DRV_DATA;      dbg_din_chnl0_data <= p.data[id];      intf.din[p.src] <= p.data[id][i];      intf.valid_n[p.src] <=1'b0;      intf.frame_n[p.src] <= (id == p.data.size()-1 && i == 7) ? 1'b1 : 1'b0;//packet最后一位输出数据时frameo_n为高    end  end// drive idle phase 闲置（没有数据传输）阶段  @(posedge intf.clock);  dbg_state <=DRV_IDLE;  dbg_din_chnl0_data <= 0;  intf.din[p.src] <= 1'b0;  intf.valid_n[p.src] <= 1'b1;  intf.frame_n[p.src] <= 1'b1;  $display("@%0t: [DRV]src_chnl[%0d],dest_chnl[%0d] data trans finished",$time,p.src,p.dst);endtaskendclass//********************************** generator **********************************//class rt_generator;//generator产生数据交给stimulator  rt_packet pkts[$];//定义队列  function void put_pkt(input rt_packet p);    pkts.push_back(p);//将p放入队列pkts里面（在pkts队列尾插入p）  endfunction    task get_pkt(output rt_packet p);    wait(pkts.size() >0 )//队列不为空      p = pkts.pop_front();//将p从队列pkts里面取出，提取队列首元素  endtask  //generate a random packet  function void gen_pkt(int src = -1, int dst = -1);  endfunction    task run();        //TODO  endtask    endclass//********************************** monitor **********************************//class rt_monitor;virtual rt_interface intf;    rt_packet in_pkts[16][$];    rt_packet out_pkts[16][$];    task run();    fork        mon_chnls();    join_noneendtask    task mon_chnls;    foreach(in_pkts[i]) begin        automatic int chid = i;        fork        mon_chnl_in(chid);//每个输入端口均调用mon_chnl_in任务，监测数据输入        mon_chnl_out(chid);//每个输出端口均调用mon_chnl_out任务，监测数据输入        join_none    endendtask    task  mon_chnl_in (bit[3:0]id);//监测数据输入的任务    rt_packet pkt;//定义结构体变量    forever begin    //clear content for the same struct variable。清除pkt    pkt = new();    pkt.src = id;//第id个输入端口    //monitor specific channel-in data and put it into the queue    // monitor address phase    @(negedge intf.frame_n[id]);//监测frame_n下降沿(frame_n由时钟驱动)    for(int i=0; i<4; i++)begin        @(negedge intf.clock);//frame_n下降沿后监测4个clk negedge        pkt.dst[i]= intf.din[id];        end        $display ("@%0t: [MON] src_chn1[%0d] & dest_chn1[%0d] data trans started",$time,pkt.src,pkt.dst);    //pass pad phase 不考虑pad阶段是否满足协议要求    repeat(5) @(negedge intf.clock);    do begin        pkt.data = new [pkt.data.size + 1](pkt.data);//创建动态数组并复制pkt.data        for ( int i=0; i<8; i++) begin            @(negedge intf.clock); //在8个clk negedge监测8bit数据            pkt.data[pkt.data.size-1][i] = intf.din[id];        end    end while(!intf.frame_n[id]);    in_pkts[id].push_back(pkt);//将monitor拿到的数据放入in_pkts    $display("@%0t:[MON] CH_IN src_chnl[%0d] &dest_chnl[%0d ] finished with packet: \n%s",$time,pkt.src,pkt.dst,pkt.sprint());    endendtasktask  mon_chnl_out(bit[ 3:0]id);//监测数据输出的任务    rt_packet pkt;    forever begin        //clear content for the same struct variable        pkt = new();        pkt.src = 0;        pkt.dst = id;        @(negedge intf.frameo_n[id]);        $display( "@%0t: [MON] CH_OUT dest_chn1[%0d] data trans started",$time,pkt.dst);        do begin        pkt.data = new [ pkt.data.size + 1](pkt.data);        for(int i=0;i<8; i++) begin            @(negedge intf.clock iff !intf.valido_n[id]);//clock与valido_n信号同时为低            pkt.data[pkt.data.size-1][i]= intf.dout [id];        end    end while(!intf.frameo_n[id]);    out_pkts[id].push_back(pkt);    $display("@%0t: [MON] CH_OUT dest_chn1[%0d] data finished woth packet : \n %s",$time,pkt.dst,pkt.sprint());    //monitor specific channel-out data and put it into the queue    endendtaskendclass//********************************** tb **********************************//module tb;bit clk,rstn;logic [15:0] din, frame_n, valid_n;logic [15:0] dout, valido_n, busy_n, frameo_n;// 产生时钟，周期为10nsinitial     forever #5ns clk <= !clk;// 产生复位信号  initial begin    #2ns rstn <= 1;    #10ns rstn <= 0;    #10ns rstn <= 1;  end//例化router为DUTrouter dut(             .reset_n(rstn),  .clock(clk),  .frame_n(intf.frame_n),  .valid_n(intf.valid_n),  .din(intf.din),  .dout(intf.dout),  .busy_n(intf.busy_n),  .valido_n(intf.valido_n),  .frameo_n(intf.frameo_n));rt_interface intf();//例化接口    assign intf.reset_n = rstn;    assign intf.clock = clk;    //例化stimulatorrt_stimulator stim;//例化Monitorrt_monitor mon;//例化generatorrt_generator gen;        initial begin : inst_init_proc        //build stage,例化        stim = new();        gen = new();        mon = new();        //connect sage，连接        stim.intf = intf;        mon.intf = intf;        //run stage，run        fork            stim.run();//class里面的函数不会自动调用，需要手动调用            gen.run();            mon.run();        join_none    end    initial begin:generate_data_proc//产生数据        rt_packet p;        #0; //wait for test components instantiated以下句柄并没有在仿真开始前例化完成，需要进入上面initial里面，所以为了上述initial先执行，等module转化为class例化完成再使用这些句柄，添加延迟最小时间单元        p = new();        p.set_members(0,3,'{8'h33,8'h77});        gen.put_pkt(p);        p = new();//每次put_pkt都需要new一下        p.set_members(0,5,'{8'h55,8'h66});        gen.put_pkt(p);        p = new();        p.set_members(3,6,'{8'h77,8'h88,8'h22});        gen.put_pkt(p);        p = new();        p.set_members(4,7,'{8'haa,8'hcc,8'h33});        gen.put_pkt(p);    endinitial begin:genarator_to_stimulator_proc//取出genarator中的数据给stimulator    rt_packet p;    #0; //wait for test components instantiated    forever begin        gen.get_pkt(p);        stim.put_pkt(p);    endendendmodule </code></pre><h2 id="3-3-仿真结果"><a href="#3-3-仿真结果" class="headerlink" title="3.3 仿真结果"></a>3.3 仿真结果</h2><p>结果同上，硬件结构层次如下：</p>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211171624571.png" width="400" height="900" title=" ">        <h1 id="4-增加checker组件"><a href="#4-增加checker组件" class="headerlink" title="4. 增加checker组件"></a>4. 增加checker组件</h1><h2 id="4-1-思路"><a href="#4-1-思路" class="headerlink" title="4.1 思路"></a>4.1 思路</h2><p>Checker从Monitor中拿到monitor采样的输入数据为期望的输出、拿到monitor采样的输出数据为实际的输出，比较二者判断输入与输出是否相等。</p>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211171936043.png" width="400" height="200" title=" ">        <h2 id="4-2-改造后的tb-sv"><a href="#4-2-改造后的tb-sv" class="headerlink" title="4.2 改造后的tb.sv"></a>4.2 改造后的tb.sv</h2><pre class=" language-systemverilog"><code class="language-systemverilog">class rt_packet;  bit [3:0] src;  bit [3:0] dst;  bit [7:0] data [];  function new();  endfunction  function void set_members(bit [3:0]src, bit [3:0]dst, bit[7:0]data []);    this.src = src;    this.dst = dst;    this.data = data;  endfunction  function string sprint();//打印packet信息的函数    sprint = {sprint , $sformatf("src = %0d\n",src)};    sprint = {sprint , $sformatf("dst = %0d\n",dst)};    sprint = {sprint , $sformatf("data_length = %0d\n",data.size())};    foreach(data[i])        sprint = {sprint , $sformatf("data[%0d] = 'h%0x\n", i, data[i])};  endfunction  function bit compare(rt_packet p);//输入exp_pkt        if(dst == p.dst && data == p.data)            compare = 1;        else             compare = 0;  endfunctionendclassinterface rt_interface();    logic clock;    logic reset_n;    logic [15:0] din;    logic [15:0] frame_n;    logic [15:0] valid_n;    logic [15:0] dout;    logic [15:0] valido_n;    logic [15:0] busy_n;    logic [15:0] frameo_n;endinterface//********************************** stimulator **********************************//class rt_stimulator;    virtual rt_interface intf;//class里的接口不能用端口的方式描述，需要添加virtual关键字，在类里面用接口的指针//for debug purpose from waveform//定义检测状态的变量  typedef enum {DRV_RESET,DRV_IDLE,DRV_ADDR,DRV_PAD,DRV_DATA} drv_state_t;  drv_state_t dbg_state;    byte unsigned dbg_din_chnl0_data;   int src_chnl_status[int];  //关联数组，后面int：src_chnl的number；前面int：dest_chnl的Number ？？    //generator传送p给stimulator  rt_packet pkts[$];//定义stimulator中的的队列pkts  function void put_pkt(input rt_packet p);    pkts.push_back(p);//将generator中传过来的p放入stimulator的pkts中(在pkts队列尾插入p)  endfunctiontask run();    fork        drive_reset(); //reset动作        get_packet_and_drive(); //drive_chnl动作    join_noneendtask    task drive_reset();//reset    forever begin        @(negedge intf.reset_n);        dbg_state <= DRV_RESET;        intf.din <= 0;        intf.frame_n <= '1;//等效16'hFFFF        intf.valid_n <= '1;    endendtask// 发送数据task get_packet_and_drive();//drive_chnl    //rt_packet_t p;  @(negedge intf.reset_n);  repeat(10) @(posedge intf.clock);//延迟10个时钟周期  forever begin    automatic rt_packet p;//声明一个动态的    wait(pkts.size()>0);    p = pkts.pop_front();//将p从队列pkts里面取出    fork//后台触发线程，触发线程在后台运行，继续执行剩下内容        begin            wait_src_chnl_avail(p);//判断src chnl是否被占用，是否需要等待            drive_chnl(p);//从P中拿到发送端口，目标端口，发送数据            set_src_chnl_avail(p);        end    join_none    endendtasktask  wait_src_chnl_avail(rt_packet p);//判断src chnl是否被占用，是否需要等待    if(!src_chnl_status.exists(p.src))//src_chnl_status关联数组里面不含p.src，(表示未占用任何dest_chnl,一开始不满足）        src_chnl_status[p.src] = p.dst;//表示当前正在使用src_chnl,对应dest_chnl就是p.dst（p.src端口在向p.dst端口发送数据）    else if(src_chnl_status[p.src] >= 0)//如果在给0,1,2...dest_chnl发送数据（被占用），需要等待,，否则不需要等待        wait(src_chnl_status[p.src] == -1);//直到src_chnl_status[p.src] == -1(自定义的dest_chnl端口数之外任意的数，表示未占用任何dest_chnl)endtaskfunction  set_src_chnl_avail(rt_packet p);    src_chnl_status[p.src] = -1;//如果chnl发送完后，把src_chnl置回来(自定义的dest_chnl端口数之外任意的数，表示未占用任何dest_chnl)endfunctiontask  drive_chnl(rt_packet p);  $display("@%0t:[DRV] src_chnl[%0d] & dest_chnl[%0d] data trans started with packet: \n%s",$time,p.src,p.dst,p.sprint());    // drive address phase 输入地址位阶段for(int i=0;i<4;i++)begin  //4 clock  @(posedge intf.clock);  dbg_state <=DRV_ADDR;  intf.din[p.src] <= p.dst[i];  intf.valid_n[p.src] <= $urandom_range(0,1);//valid_n在din的地址输入时间段可为任意值x  intf.frame_n[p.src] <= 1'b0;//frame_n需要为低end    // drive pad phase //隔离阶段  for (int i=0;i<5;i++)begin  //5 clock    @(posedge intf.clock);    dbg_state <=DRV_PAD;    intf.din[p.src] <= 1'b1;    intf.valid_n[p.src] <= 1'b1;//valid_n需为高电平    intf.frame_n[p.src] <= 1'b0; //frame_n需为低电平  end    // drive data phase 传输数据阶段  foreach(p.data[id])begin    for(int i=0;i<8;i++)begin     @(posedge intf.clock);      dbg_state <=DRV_DATA;      dbg_din_chnl0_data <= p.data[id];      intf.din[p.src] <= p.data[id][i];      intf.valid_n[p.src] <=1'b0;      intf.frame_n[p.src] <= (id == p.data.size()-1 && i == 7) ? 1'b1 : 1'b0;//packet最后一位输出数据时frameo_n为高    end  end// drive idle phase 闲置（没有数据传输）阶段  @(posedge intf.clock);  dbg_state <=DRV_IDLE;  dbg_din_chnl0_data <= 0;  intf.din[p.src] <= 1'b0;  intf.valid_n[p.src] <= 1'b1;  intf.frame_n[p.src] <= 1'b1;  $display("@%0t: [DRV]src_chnl[%0d],dest_chnl[%0d] data trans finished",$time,p.src,p.dst);endtaskendclass//********************************** generator **********************************//class rt_generator;//generator产生数据交给stimulator  rt_packet pkts[$];//定义队列  function void put_pkt(input rt_packet p);    pkts.push_back(p);//将p放入队列pkts里面（在pkts队列尾插入p）  endfunction    task get_pkt(output rt_packet p);    wait(pkts.size() >0 )//队列不为空      p = pkts.pop_front();//将p从队列pkts里面取出，提取队列首元素  endtask  //generate a random packet  function void gen_pkt(int src = -1, int dst = -1);  endfunction    task run();        //TODO  endtask    endclass//********************************** monitor **********************************//class rt_monitor;virtual rt_interface intf;    rt_packet in_pkts[16][$];    rt_packet out_pkts[16][$];    task run();    fork        mon_chnls();    join_noneendtask    task mon_chnls;    foreach(in_pkts[i]) begin        automatic int chid = i;        fork        mon_chnl_in(chid);//每个输入端口均调用mon_chnl_in任务，监测数据输入        mon_chnl_out(chid);//每个输出端口均调用mon_chnl_out任务，监测数据输入        join_none    endendtask    task  mon_chnl_in (bit[3:0]id);//监测数据输入的任务    rt_packet pkt;//定义结构体变量    forever begin    //clear content for the same struct variable。清除pkt    pkt = new();    pkt.src = id;//第id个输入端口    //monitor specific channel-in data and put it into the queue    // monitor address phase    @(negedge intf.frame_n[id]);//监测frame_n下降沿(frame_n由时钟驱动)    for(int i=0; i<4; i++)begin        @(negedge intf.clock);//frame_n下降沿后监测4个clk negedge        pkt.dst[i]= intf.din[id];        end        $display ("@%0t: [MON] src_chn1[%0d] & dest_chn1[%0d] data trans started",$time,pkt.src,pkt.dst);    //pass pad phase 不考虑pad阶段是否满足协议要求    repeat(5) @(negedge intf.clock);    do begin        pkt.data = new [pkt.data.size + 1](pkt.data);//创建动态数组并复制pkt.data        for ( int i=0; i<8; i++) begin            @(negedge intf.clock); //在8个clk negedge监测8bit数据            pkt.data[pkt.data.size-1][i] = intf.din[id];        end    end while(!intf.frame_n[id]);    in_pkts[id].push_back(pkt);//将monitor拿到的数据放入in_pkts    $display("@%0t:[MON] CH_IN src_chnl[%0d] &dest_chnl[%0d ] finished with packet: \n%s",$time,pkt.src,pkt.dst,pkt.sprint());    endendtasktask  mon_chnl_out(bit[ 3:0]id);//监测数据输出的任务    rt_packet pkt;    forever begin        //clear content for the same struct variable        pkt = new();        pkt.src = 0;        pkt.dst = id;        @(negedge intf.frameo_n[id]);        $display( "@%0t: [MON] CH_OUT dest_chn1[%0d] data trans started",$time,pkt.dst);        do begin        pkt.data = new [ pkt.data.size + 1](pkt.data);        for(int i=0;i<8; i++) begin            @(negedge intf.clock iff !intf.valido_n[id]);//clock与valido_n信号同时为低            pkt.data[pkt.data.size-1][i]= intf.dout [id];        end    end while(!intf.frameo_n[id]);    out_pkts[id].push_back(pkt);    $display("@%0t: [MON] CH_OUT dest_chn1[%0d] data finished woth packet : \n %s",$time,pkt.dst,pkt.sprint());    //monitor specific channel-out data and put it into the queue    endendtaskendclass//********************************** checker **********************************//class rt_checker;    int unsigned compare_count;    int unsigned error_count;        function new();//赋初值，可有可无，整形变量默认初始值为0        compare_count = 0;        error_count = 0;    endfunction        rt_packet exp_out_pkts[16][$];    rt_monitor mon;        task run();    foreach(exp_out_pkts[i])begin        automatic int chid = i;        fork            do_routing(chid);            do_compare(chid);        join_none        end    endtask        task do_routing(bit[3:0] id);//将monitor中采样到的输入数据放入期望的输出端队列中        rt_packet pkt;        forever begin            wait(mon.in_pkts[id].size > 0);            pkt = mon.in_pkts[id].pop_front();//从monitor中拿到in_pkts队列数据放入pkt            exp_out_pkts[pkt.dst].push_back(pkt);//将pkt数据放入对应期望的dest_chnl            end    endtask         task do_compare(bit[3:0] id);//比较采集的实际输出与期望输出        rt_packet exp_pkt, act_pkt;        forever begin            wait(mon.out_pkts[id].size > 0 && exp_out_pkts[id].size > 0);//实际采样数据与期望数据都有值            act_pkt = mon.out_pkts[id].pop_front();//实际数据为monitor采样的输出数据            exp_pkt = exp_out_pkts[id].pop_front();//期望数据为monitor采样到的输入数据            if(act_pkt.compare(exp_pkt))begin//如果exp_pkt与act_pkt比较成功，返回1                $display("[CHK] data compare success with packet : \n%s",act_pkt.sprint());            end            else begin                $display("[CHK] data compare failure with actual packet : \n%s \nexpected packet : \n%s", act_pkt.sprint(), exp_pkt.sprint());                error_count++;            end                compare_count++;        end    endtask         function void do_report();        $display("TOTAL COMPARING %0d times",compare_count);        if(!error_count)            $display("TEST PASSED!");        else begin            $display("TEST FAILED!");            $display("TOTAL ERROR %0d times", error_count);        end    endfunctionendclass//********************************** tb **********************************//module tb;bit clk,rstn;logic [15:0] din, frame_n, valid_n;logic [15:0] dout, valido_n, busy_n, frameo_n;// 产生时钟，周期为10nsinitial     forever #5ns clk <= !clk;// 产生复位信号  initial begin    #2ns rstn <= 1;    #10ns rstn <= 0;    #10ns rstn <= 1;  end//例化router为DUTrouter dut(             .reset_n(rstn),  .clock(clk),  .frame_n(intf.frame_n),  .valid_n(intf.valid_n),  .din(intf.din),  .dout(intf.dout),  .busy_n(intf.busy_n),  .valido_n(intf.valido_n),  .frameo_n(intf.frameo_n));rt_interface intf();//例化接口    assign intf.reset_n = rstn;    assign intf.clock = clk;    //例化stimulatorrt_stimulator stim;//例化Monitorrt_monitor mon;//例化generatorrt_generator gen;rt_checker chk;        initial begin : inst_init_proc        //build stage,例化        stim = new();        gen = new();        mon = new();        chk = new();        //connect sage，连接        stim.intf = intf;        mon.intf = intf;        chk.mon = mon;//check拿monitor句柄，即拿monitor中in_pkts与out_pkts队列        //run stage，run        fork            stim.run();//class里面的函数不会自动调用，需要手动调用            gen.run();            mon.run();            chk.run();        join_none    end    initial begin:generate_data_proc//产生数据        rt_packet p;        #0; //wait for test components instantiated以下句柄并没有在仿真开始前例化完成，需要进入上面initial里面，所以为了上述initial先执行，等module转化为class例化完成再使用这些句柄，添加延迟最小时间单元        p = new();        p.set_members(0,3,'{8'h33,8'h77});        gen.put_pkt(p);        p = new();//每次put_pkt都需要new一下        p.set_members(0,5,'{8'h55,8'h66});        gen.put_pkt(p);        p = new();        p.set_members(3,6,'{8'h77,8'h88,8'h22});        gen.put_pkt(p);        p = new();        p.set_members(4,7,'{8'haa,8'hcc,8'h33});        gen.put_pkt(p);    endinitial begin:genarator_to_stimulator_proc//取出genarator中的数据给stimulator    rt_packet p;    #0; //wait for test components instantiated    forever begin        gen.get_pkt(p);        stim.put_pkt(p);    endendendmodule </code></pre><h2 id="4-3-仿真结果"><a href="#4-3-仿真结果" class="headerlink" title="4.3 仿真结果"></a>4.3 仿真结果</h2><p><strong>DVE报告</strong></p><blockquote><p>dve&gt; run 2us<br>2000000 ps<br>@105000:[DRV] src_chnl[0] &amp; dest_chnl[3] data trans started with packet:<br>src = 0<br>dst = 3<br>data_length = 2<br>data[0] = ‘h33<br>data[1] = ‘h77</p><p>@105000:[DRV] src_chnl[3] &amp; dest_chnl[6] data trans started with packet:<br>src = 3<br>dst = 6<br>data_length = 3<br>data[0] = ‘h77<br>data[1] = ‘h88<br>data[2] = ‘h22</p><p>@105000:[DRV] src_chnl[4] &amp; dest_chnl[7] data trans started with packet:<br>src = 4<br>dst = 7<br>data_length = 3<br>data[0] = ‘haa<br>data[1] = ‘hcc<br>data[2] = ‘h33</p><p>@150000: [MON] src_chn1[0] &amp; dest_chn1[3] data trans started<br>@150000: [MON] src_chn1[3] &amp; dest_chn1[6] data trans started<br>@150000: [MON] src_chn1[4] &amp; dest_chn1[7] data trans started<br>@205000: [MON] CH_OUT dest_chn1[3] data trans started<br>@205000: [MON] CH_OUT dest_chn1[6] data trans started<br>@205000: [MON] CH_OUT dest_chn1[7] data trans started<br>@360000:[MON] CH_IN src_chnl[0] &amp;dest_chnl[3 ] finished with packet:<br>src = 0<br>dst = 3<br>data_length = 2<br>data[0] = ‘h33<br>data[1] = ‘h77</p><p>@365000: [DRV]src_chnl[0],dest_chnl[3] data trans finished<br>@365000:[DRV] src_chnl[0] &amp; dest_chnl[5] data trans started with packet:<br>src = 0<br>dst = 5<br>data_length = 2<br>data[0] = ‘h55<br>data[1] = ‘h66</p><p>@380000: [MON] CH_OUT dest_chn1[3] data finished woth packet :<br>src = 0<br>dst = 3<br>data_length = 2<br>data[0] = ‘h33<br>data[1] = ‘h77</p><p>[CHK] data compare success with packet :<br>src = 0<br>dst = 3<br>data_length = 2<br>data[0] = ‘h33<br>data[1] = ‘h77</p><p>@410000: [MON] src_chn1[0] &amp; dest_chn1[5] data trans started<br>@440000:[MON] CH_IN src_chnl[3] &amp;dest_chnl[6 ] finished with packet:<br>src = 3<br>dst = 6<br>data_length = 3<br>data[0] = ‘h77<br>data[1] = ‘h88<br>data[2] = ‘h22</p><p>@440000:[MON] CH_IN src_chnl[4] &amp;dest_chnl[7 ] finished with packet:<br>src = 4<br>dst = 7<br>data_length = 3<br>data[0] = ‘haa<br>data[1] = ‘hcc<br>data[2] = ‘h33</p><p>@445000: [DRV]src_chnl[3],dest_chnl[6] data trans finished<br>@445000: [DRV]src_chnl[4],dest_chnl[7] data trans finished<br>@460000: [MON] CH_OUT dest_chn1[6] data finished woth packet :<br>src = 0<br>dst = 6<br>data_length = 3<br>data[0] = ‘h77<br>data[1] = ‘h88<br>data[2] = ‘h22</p><p>@460000: [MON] CH_OUT dest_chn1[7] data finished woth packet :<br>src = 0<br>dst = 7<br>data_length = 3<br>data[0] = ‘haa<br>data[1] = ‘hcc<br>data[2] = ‘h33</p><p>[CHK] data compare success with packet :<br>src = 0<br>dst = 6<br>data_length = 3<br>data[0] = ‘h77<br>data[1] = ‘h88<br>data[2] = ‘h22</p><p>[CHK] data compare success with packet :<br>src = 0<br>dst = 7<br>data_length = 3<br>data[0] = ‘haa<br>data[1] = ‘hcc<br>data[2] = ‘h33</p><p>@465000: [MON] CH_OUT dest_chn1[5] data trans started<br>@620000:[MON] CH_IN src_chnl[0] &amp;dest_chnl[5 ] finished with packet:<br>src = 0<br>dst = 5<br>data_length = 2<br>data[0] = ‘h55<br>data[1] = ‘h66</p><p>@625000: [DRV]src_chnl[0],dest_chnl[5] data trans finished<br>@640000: [MON] CH_OUT dest_chn1[5] data finished woth packet :<br>src = 0<br>dst = 5<br>data_length = 2<br>data[0] = ‘h55<br>data[1] = ‘h66</p><p>[CHK] data compare success with packet :<br>src = 0<br>dst = 5<br>data_length = 2<br>data[0] = ‘h55<br>data[1] = ‘h66</p></blockquote><p><strong>硬件结构层次如下：</strong></p>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211171907835.png" width="400" height="900" title=" ">        <h1 id="5-TestBench概览"><a href="#5-TestBench概览" class="headerlink" title="5. TestBench概览"></a>5. TestBench概览</h1>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211171924107.png" width="600" height="360" title=" ">        ]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-将数据传输从结构体改造为类&quot;&gt;&lt;a href=&quot;#1-将数据传输从结构体改造为类&quot; class=&quot;headerlink&quot; title=&quot;1. 将数据传输从结构体改造为类&quot;&gt;&lt;/a&gt;1. 将数据传输从结构体改造为类&lt;/h1&gt;&lt;h2 id=&quot;1-1-改造&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="数字IC" scheme="https://www.daipeihong.top/categories/%E6%95%B0%E5%AD%97IC/"/>
    
    
    <category term="数字前端" scheme="https://www.daipeihong.top/tags/%E6%95%B0%E5%AD%97%E5%89%8D%E7%AB%AF/"/>
    
    <category term="SystemVerilog验证" scheme="https://www.daipeihong.top/tags/SystemVerilog%E9%AA%8C%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>lightroom后期（二）后期快速修片流程</title>
    <link href="https://www.daipeihong.top/2022/10/23/lightroom-hou-qi-er-hou-qi-kuai-su-xiu-pian-liu-cheng/"/>
    <id>https://www.daipeihong.top/2022/10/23/lightroom-hou-qi-er-hou-qi-kuai-su-xiu-pian-liu-cheng/</id>
    <published>2022-10-23T13:59:00.000Z</published>
    <updated>2022-10-28T12:32:36.792Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一步：改变照片的尺寸和比例"><a href="#第一步：改变照片的尺寸和比例" class="headerlink" title="第一步：改变照片的尺寸和比例"></a>第一步：改变照片的尺寸和比例</h1><h2 id="变换工具"><a href="#变换工具" class="headerlink" title="变换工具"></a>变换工具</h2><p>在变换工具中，可以进行手动或者自动校正垂直线<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210232202333.png"></p><h2 id="裁剪工具"><a href="#裁剪工具" class="headerlink" title="裁剪工具"></a>裁剪工具</h2><p>在裁剪叠加里有一个非常好用的小工具，当地平线在照片里比较明显可以看出来的时候，点击“自动”按钮就可以自动修正。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210232205428.png"><br>有很多时候照片里看不出水平线，需要手动调整，可以点击下面这个小尺子的图标。拉一条水平线，来告诉Lightroom这里本该是地平线，全都设置好了之后就可以锁定图像了。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/20221023_221022.gif"></p><h2 id="镜头矫正"><a href="#镜头矫正" class="headerlink" title="镜头矫正"></a>镜头矫正</h2><p>勾选移除色差和启用配置文件校正这两个选项可以进行视角矫正。<br>同样地，也可尽手动操作来校正广角镜头的畸变、以及消除紫边和暗角。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210232241294.png"></p><h1 id="第二步：修整曝光还原色彩"><a href="#第二步：修整曝光还原色彩" class="headerlink" title="第二步：修整曝光还原色彩"></a>第二步：修整曝光还原色彩</h1><h2 id="白平衡校正"><a href="#白平衡校正" class="headerlink" title="白平衡校正"></a>白平衡校正</h2><p>这一步的目的主要是让照片中的颜色还原成拍摄时的样子，为之后的调色打基础。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210232246573.png"></p><h2 id="色调修正"><a href="#色调修正" class="headerlink" title="色调修正"></a>色调修正</h2><p>对照片的全局曝光进行修正<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210232246382.png"><br>调整局部曝光可以使用径向滤镜、渐变滤镜和调整画笔。<br>可以使用渐变滤镜调整比较规律的大面积；径向滤镜用来调整圆形或椭圆形范围；画笔可以更加精细调整局部范围。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210232249320.png"></p><h1 id="第三步：增加立体感和细节"><a href="#第三步：增加立体感和细节" class="headerlink" title="第三步：增加立体感和细节"></a>第三步：增加立体感和细节</h1><h2 id="偏好设置"><a href="#偏好设置" class="headerlink" title="偏好设置"></a>偏好设置</h2><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210232252200.png"><br>其中，纹理和清晰度可以有效的增加细节和质感。</p><h2 id="色调曲线工具"><a href="#色调曲线工具" class="headerlink" title="色调曲线工具"></a>色调曲线工具</h2><p>色调曲线工具可以同时改变照片的曝光和对比度，色调的改变可以导致照片的立体感产生变化。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210232254636.png"></p><h2 id="细节工具"><a href="#细节工具" class="headerlink" title="细节工具"></a>细节工具</h2><p>对照片进行锐化和细节增强<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210232256377.png"></p><h1 id="第四步：调色和添加效果"><a href="#第四步：调色和添加效果" class="headerlink" title="第四步：调色和添加效果"></a>第四步：调色和添加效果</h1><p>接下来对照片进行微调或者加强渲染，形成自己的独特调色风格<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210232301802.png"></p><h1 id="第五步：去除污点和杂物"><a href="#第五步：去除污点和杂物" class="headerlink" title="第五步：去除污点和杂物"></a>第五步：去除污点和杂物</h1><p>去除如传感器污点，影响照片效果的内容等等。可以使用Lightroom中的污点去除工具，不仅可以去除点状的内容，还可以去除复杂外形的杂物。只需要拖动鼠标，完整的覆盖想要去除的区域，lightroom就会寻找一个类似的内容进行覆盖。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210232305738.png"></p><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p><a href="https://www.bilibili.com/video/BV1mK4y1Q7uy/?vd_source=83d80c57e4377b69f911cc68016fb835">【Edi x TourBox后期训练营】后期修片的流程顺序 - 新手快速入门摄影后期的实用方法_哔哩哔哩_bilibili</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一步：改变照片的尺寸和比例&quot;&gt;&lt;a href=&quot;#第一步：改变照片的尺寸和比例&quot; class=&quot;headerlink&quot; title=&quot;第一步：改变照片的尺寸和比例&quot;&gt;&lt;/a&gt;第一步：改变照片的尺寸和比例&lt;/h1&gt;&lt;h2 id=&quot;变换工具&quot;&gt;&lt;a href=&quot;#变</summary>
      
    
    
    
    <category term="摄影后期" scheme="https://www.daipeihong.top/categories/%E6%91%84%E5%BD%B1%E5%90%8E%E6%9C%9F/"/>
    
    
    <category term="lightroom" scheme="https://www.daipeihong.top/tags/lightroom/"/>
    
    <category term="修片流程" scheme="https://www.daipeihong.top/tags/%E4%BF%AE%E7%89%87%E6%B5%81%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>WordPress安装教程</title>
    <link href="https://www.daipeihong.top/2022/10/22/wordpress-an-zhuang-jiao-cheng/"/>
    <id>https://www.daipeihong.top/2022/10/22/wordpress-an-zhuang-jiao-cheng/</id>
    <published>2022-10-22T14:06:00.000Z</published>
    <updated>2022-11-05T13:00:35.265Z</updated>
    
    <content type="html"><![CDATA[<p>首先，需要购买一台云服务器/轻量云服务器，步骤如下<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222121301.png"><br>选择云服务器配置<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222126775.png"><br>购买完成后即可在如下位置看见已购买的云服务器（此处我购买的为轻量云服务器）<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222130358.png"><br>点击进入<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210231651076.png"></p><p>接下来进入管理面板<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210231651672.png"></p><p>要访问宝塔面板，防火墙/安全组需要放行面板[8888]端口，操作如下：<br>点进如下界面<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210231652992.png"></p><p>点击添加规则<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222135726.png"></p><p>在端口一栏输入<strong>8888</strong>以开放端口<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222135122.png"></p><p>之后在“应用管理”界面复制命令，点击登录<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210231653542.png"></p><p>此处需要登录一下<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222136412.png"></p><p>粘贴刚才复制的命令，回车<br>得到宝塔面板的登录信息，可以保存下来方便后面使用<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222136778.png"></p><p>浏览器中输入刚保存的外网面板地址，输入刚保存的账户密码登录<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222136087.png"></p><p>绑定宝塔账号(没有就去<a href="https://www.bt.cn/new/index.html">宝塔面板官网</a>)注册一个再来绑定）<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222136339.png"></p><p>点击查看，新建API密钥<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222137388.png"></p><p>点击新建密钥，密钥就会出现在下方<br>复制APPID、Secretid、SecretKey输入到刚才关联API密钥界面即可<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222138035.png"></p><p>此处选择急速安装与编译安装都可以，之后点击一键安装<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222138624.png"></p><p>接下来等待安装完成就行<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222138905.png"></p><p>安装完成后，在软件商店搜索wordpress，如下<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222120098.png"><br>这里需要填写自己购买的域名，域名的购买可参考我的另一篇博客==（链接）==<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210231654333.png"></p><hr><p>——————————————分割线——————————————————<br>==注意：以下属于购买域名部分的不同处：==<br>在对域名进行解析时，需要将记录值添加为云服务器的公网IP<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210231654475.png"></p><p>云服务器的公网IP在这里获取：<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222146682.png"><br>——————————————分割线——————————————————–<br>填好域名后，<img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222148697.png"><br>进入wordpress安装界面（建议在这一步安装之前，先部署ssl证书，否则可能访问不了安装页面，如何获取ssl证书见下一步）<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222148503.png"><br>进入此页面，搜索ssl证书，点击进入<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222149111.png"><br>在“我的证书”里面进行购买（免费）<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222150531.png"><br>选择如下<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222150546.png"><br>填写信息<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222152165.png"><br>根据给出得主机记录、记录类型、记录值添加域名解析记录==（见我的另一篇关于域名购买的博客）==<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222152866.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222152753.png"><br>之后验证域名<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222154908.png"><br>验证通过之后在“我的证书”里面下载<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222155303.png"><br>请根据服务器类型选择证书下载:<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222155468.png"><br>下载解压打开，有如下文件<br><img src="/!%5B%5D(https:/cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/20221022215719.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/20221022215719.png"><br>进入宝塔面板如下页面：<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222156120.png"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222157240.png"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222158087.png"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222158808.png"></p><p>完成之后在此进入Wordpress安装界面，点击安装<img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222159505.png"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222159244.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222159535.png"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222159668.png"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222200184.png"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222200978.png"><br>WordPress安装完成，接下来更改相关设置<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222200401.png"></p><p>进入如下页面<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222201542.png"></p><p>选择好之后回到宝塔页面<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222202188.png"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222202515.png"><br>再回到wordpress<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222202459.png"><br>设置更新完成<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/~2$6O0@%7DQLSFCET5H3L3Z5M.png"></p><p>至此，WordPress安装全部完成，可以通过自己购买的域名访问WordPress<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222203746.png"></p><p>备注：网站需要备案才能访问<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210231859668.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先，需要购买一台云服务器/轻量云服务器，步骤如下&lt;br&gt;&lt;img src=&quot;https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222121301.png&quot;&gt;&lt;b</summary>
      
    
    
    
    <category term="Web前端" scheme="https://www.daipeihong.top/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="WordPress" scheme="https://www.daipeihong.top/tags/WordPress/"/>
    
    <category term="安装教程" scheme="https://www.daipeihong.top/tags/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>lightroom后期（一）图片管理方法</title>
    <link href="https://www.daipeihong.top/2022/10/21/lightroom-hou-qi-yi-tu-pian-guan-li-fang-fa/"/>
    <id>https://www.daipeihong.top/2022/10/21/lightroom-hou-qi-yi-tu-pian-guan-li-fang-fa/</id>
    <published>2022-10-21T04:18:00.000Z</published>
    <updated>2022-10-28T12:31:59.356Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-文件管理体系"><a href="#一-文件管理体系" class="headerlink" title="(一)文件管理体系"></a>(一)文件管理体系</h2><ol><li>使用<font color="#7030a0">摄影日期</font>(或加上<font color="rgb(227, 108, 9)">地名</font>)命名文件夹</li><li>按照文件格式分类分别保存JEPG、RAW、视频文件</li><li>新建加水印图片的文件夹，保存缩小尺寸、添加水印的照片，用于网络分享</li></ol><h2 id="二-lightroom导入照片的方式"><a href="#二-lightroom导入照片的方式" class="headerlink" title="(二)lightroom导入照片的方式"></a>(二)lightroom导入照片的方式</h2><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210211231869.png"><br><font color="#fac08f">复制</font>：将照片复制到新位置并添加到目录<br><font color="#00b0f0">移动</font>：将照片移到新位置并添加到目录<br><font color="#b2a2c7">添加</font>：将照片添加到目录而不移动</p><h2 id="三-筛选和照片分类"><a href="#三-筛选和照片分类" class="headerlink" title="(三)筛选和照片分类"></a>(三)筛选和照片分类</h2><p><strong>可以对照片进行旗标、评定星级和添加颜色标签，以及添加人脸标签来进行标记和分类</strong></p><h3 id="1-添加旗帜"><a href="#1-添加旗帜" class="headerlink" title="1. 添加旗帜"></a>1. 添加旗帜</h3><p>可以把想要保留的照片添加旗标<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210211245144.png"><br>在过滤器中选择留用即可在当前窗口只保留被标记旗子的照片<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210211246948.png"></p><h3 id="2-设置星级"><a href="#2-设置星级" class="headerlink" title="2. 设置星级"></a>2. 设置星级</h3><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210211248403.png"></p><h3 id="3-颜色标签"><a href="#3-颜色标签" class="headerlink" title="3. 颜色标签"></a>3. 颜色标签</h3><p>可以对照片的类型做一个区分，区分日落、夜景等等<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210211250975.png"></p><h3 id="4-人脸标签"><a href="#4-人脸标签" class="headerlink" title="4. 人脸标签"></a>4. 人脸标签</h3><p>通过一张照片上的人脸识别，可以让Lightroom自动搜索所有的照片，并且添加人物标签。</p><h2 id="四-添加导出预设"><a href="#四-添加导出预设" class="headerlink" title="(四)添加导出预设"></a>(四)添加导出预设</h2><p>建议建一个原尺寸JPEG导出预设，其他根据需要添加自定义导出预设<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210211300675.png"></p><p>如果照片导出后预览颜色奇怪，或者在其他设备上看到的颜色和原片不—样，多半是这个色彩空间没有选择sRGB的原因</p><h2 id="五-添加水印"><a href="#五-添加水印" class="headerlink" title="(五)添加水印"></a>(五)添加水印</h2><p>可添加<font color="#ffc000">文字</font>/<font color="#00b0f0">图片</font>水印，导出时勾选即可<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210211303104.png"></p><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p><a href="https://www.bilibili.com/video/BV1uv411v7Qe/">【Edi x TourBox后期训练营】如何管理和批量处理旅行照片 - 完整的图片数据整理方案_哔哩哔哩_bilibili</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-文件管理体系&quot;&gt;&lt;a href=&quot;#一-文件管理体系&quot; class=&quot;headerlink&quot; title=&quot;(一)文件管理体系&quot;&gt;&lt;/a&gt;(一)文件管理体系&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;使用&lt;font color=&quot;#7030a0&quot;&gt;摄影日期&lt;/font&gt;(或加</summary>
      
    
    
    
    <category term="摄影后期" scheme="https://www.daipeihong.top/categories/%E6%91%84%E5%BD%B1%E5%90%8E%E6%9C%9F/"/>
    
    
    <category term="lightroom" scheme="https://www.daipeihong.top/tags/lightroom/"/>
    
    <category term="后期思路" scheme="https://www.daipeihong.top/tags/%E5%90%8E%E6%9C%9F%E6%80%9D%E8%B7%AF/"/>
    
    <category term="图片管理" scheme="https://www.daipeihong.top/tags/%E5%9B%BE%E7%89%87%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>SystemVerilog学习笔记(七)</title>
    <link href="https://www.daipeihong.top/2022/10/20/systemverilog-xue-xi-bi-ji-qi/"/>
    <id>https://www.daipeihong.top/2022/10/20/systemverilog-xue-xi-bi-ji-qi/</id>
    <published>2022-10-20T11:53:00.000Z</published>
    <updated>2022-10-22T05:29:04.240Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h1><h2 id="实例1-子类没有定义new函数，会调用父类new函数"><a href="#实例1-子类没有定义new函数，会调用父类new函数" class="headerlink" title="实例1 子类没有定义new函数，会调用父类new函数"></a>实例1 子类没有定义new函数，会调用父类new函数</h2><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210202009690.png"><br><strong>仿真结果</strong>：</p><blockquote><p>p.i = 2;<br>lp.i = 2;</p></blockquote><h2 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h2><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210202022227.png"><br><strong>仿真结果</strong>：</p><blockquote><p>lp.i = 3;</p></blockquote><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210202023256.png"></p><h2 id="实例3-如果子类定义function-new，仍会默认调用父类的new函数"><a href="#实例3-如果子类定义function-new，仍会默认调用父类的new函数" class="headerlink" title="实例3 如果子类定义function new，仍会默认调用父类的new函数"></a>实例3 如果子类定义function new，仍会默认调用父类的new函数</h2><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210202056452.png"><br><strong>仿真结果</strong>：</p><blockquote><p>p.i = 2;<br>lp.i = 2;</p></blockquote><h2 id="实例4"><a href="#实例4" class="headerlink" title="实例4"></a>实例4</h2><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210202121976.png"><br>子类和父类出现同名函数function，如果子类没有使用supper.(functionname)，不会调用父类的此函数。如果子类里使用supper.(functionname)，即调用父类的此函数。</p><h2 id="实例5"><a href="#实例5" class="headerlink" title="实例5"></a>实例5</h2><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/20221020213918.png"></p><ol><li>子类带参数，父类不带参数，仍会调用父类new函数。</li><li>只要父类new没有参数，就可以默认调用</li><li>子类必须调动父类的new函数，否则编译无法通过。</li><li>如果父类new函数没有参数，直接调用；如果父类new函数有参数，子类里面需要严格用supper.new</li></ol><h2 id="实例6"><a href="#实例6" class="headerlink" title="实例6"></a>实例6</h2><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210202329703.png"></p><p><strong>仿真结果</strong></p><blockquote><p>p.i = 2;<br>lp.i = 2;<br>after shift p.i = 8;<br>after shift lp.i = 12;</p></blockquote><p><strong>设置断点分析</strong>：<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210202349849.png"></p><p><strong>注意</strong>：</p><ol><li>子类和父类出现同名的函数或者同名的函数或者任务（同名方法），子类想要继承，需要方法名一致参数一致，调用一定写supper</li><li>子类的方法名称可以与父类同名，但子类的变量最好不要跟父类的变量同名</li></ol><h2 id="实例7-子类的句柄能够赋值给父类的句柄，父类的句柄不能赋值给子类的句柄"><a href="#实例7-子类的句柄能够赋值给父类的句柄，父类的句柄不能赋值给子类的句柄" class="headerlink" title="实例7 子类的句柄能够赋值给父类的句柄，父类的句柄不能赋值给子类的句柄"></a>实例7 子类的句柄能够赋值给父类的句柄，父类的句柄不能赋值给子类的句柄</h2>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210212108619.png" width="500" height="530">                    <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210212108436.png" width="500" height="300">        <ol><li>子类的句柄能够赋值给父类的句柄（ ==能够访问区域缩小==），父类的句柄不能赋值给子类的句柄</li><li>lp.i只能指向子类中的i，无法指向父类的i（子类的变量跟父类的变量同名，i被覆盖）；tmp.i可以指向父类的i</li><li>lp能访问子类的i、k、m，无法访问父类的i；tmp能访问父类的i、m，但找不到子类的i、k</li></ol><h1 id="包的使用"><a href="#包的使用" class="headerlink" title="包的使用"></a>包的使用</h1><h2 id="包的概念"><a href="#包的概念" class="headerlink" title="包的概念"></a>包的概念</h2><p>为了使得可以在多个模块（硬件）或者奕（默件)间共子用厂化乂大型,SV添加了包(package) 。包的概念参考于VHDL，用户自定义的类型譬如==类、方法、变量、结构体、枚举类==（==偏软件类，Module、inteface偏硬件就不能定义在包里面==）等都可以在package…endpackage中定义。</p><h2 id="包的使用方法"><a href="#包的使用方法" class="headerlink" title="包的使用方法"></a>包的使用方法</h2><ol><li><p>module、interface、class等可以使用包中定义或者声明的内容。</p></li><li><p>导出：可以通过域的==索引符::号==直接引用。</p>      <meta charset="utf-8">     <title>HTML</title>               <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210212212179.png" width="500" height="300">     </li><li><p>可以==指定索引==一些需要的包中定义的类型到指定的容器中(module/class/…) 。</p>      <meta charset="utf-8">     <title>HTML</title>               <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210212213098.png" width="500" height="300">     </li><li><p>通过通配符$*$来将包中==所有类别导入==到指定容器中。</p></li></ol><h2 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h2>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210212210008.png" width="500" height="1200">        <h1 id="问答题"><a href="#问答题" class="headerlink" title="问答题"></a>问答题</h1><p><strong>1.在packet和linkedpacket有关类的继承的例子中(如图)，tb中的句柄p是否可以访问父类的成员i?lp是否可以访问父类的成员i?句柄tmp是否可以访问子类的成员i?</strong></p><p><strong>代码：</strong></p><pre class=" language-systemverilog"><code class="language-systemverilog">/*Problem1在packet和linkedpacket有关类的继承的例子中(如图)，tb中的句柄p是否可以访问父类的成员i?lp是否可以访问父类的成员i?句柄tmp是否可以访问子类的成员i?*/class packet;    integer i = 1;    integer m = 2;    function new(int val);        i = val + 1;    endfunction    function shift();        i = i << 1;    endfunction    endclass    class linkedpacket extends packet;    integer i = 3;    integer k = 5;    function new (val);        super.new(val);        if (val >= 2)            i = val;    endfunction    function shift();        super.shift();        i = i << 2;    endfunctionendclassmodule tb;    initial begin        packet p = new(3);        linkedpacket lp = new(1);        packet tmp;        tmp = lp;        //tb中的句柄p是否可以访问父类的成员i?    $display("p.i = %0d",p.i);    //lp是否可以访问父类的成员i?     $display("lp.i = %0d",lp.i);//lp.i只能指向子类中的i，无法指向父类的i（子类的变量跟父类的变量同名，i被覆盖）    $display("lp.m = %0d",lp.m);//但lp可以访问父类的其他成员    //句柄tmp是否可以访问子类的成员i?    $display("tmp.i = %0d",tmp.i);    //$display("tmp.k = %0d",tmp.k); //ERROR：Could not find member 'k' in class 'packet', at "class_test.sv", 7.        endendmodule</code></pre><p><strong>仿真结果：</strong></p><blockquote><p>p.i = 4      tb中的句柄p是否可以访问父类的成员i<br>lp.i = 3     lp.i只能指向子类中的i，无法指向父类的i（子类的变量跟父类的变量同名，i被覆盖）<br>lp.m = 2  但lp可以访问父类的其他成员<br>tmp.i = 2  tmp能访问父类的i、m，但找不到子类的i、k</p></blockquote>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210221243924.png" width="500" height="300">        <p><strong>2.试着在对应的位置填入代码，即如何导入pkg_a中的类型packet_a，从pkg_b中导入packet_b，以及从pkg_b中导入静态变量shared?</strong></p><p><strong>代码：</strong></p><pre class=" language-systemverilog"><code class="language-systemverilog">package pkt_a;    class packet_a;        int pkg_a;    endclass    typedef struct{        int data;        int command;        }struct_a;        int va = 1;        int shared = 10;endpackagepackage pkt_b;    class packet_b;        int pkg_b;    endclass    typedef struct{        int data;        int command;        }struct_b;        int vb = 2;        int shared = 20;endpackage                module tb;    class packet_tb;    endclass    typedef struct{        int data;        int command;    }struct_tb;        class packet_a;        int tb_a;    endclass    class packet_b;        int tb_b;    endclass    //how to import type from packages can be seen as follows    //精确导出    import pkt_a::va;    import pkt_b::vb;    //import pkt_a::shared;//从pkt_a取出shared    import pkg_b::shared;//从pkt_b取出shared        ////全部导出    //import pkt_a::*;    //import pkt_b::*;        initial begin         packet_a pa = new();        packet_b pb = new();        packet_tb ptb = new();        $display("pkg_a::va = %0d,pkg_b:: = %0d",va ,vb);        $display("shared = %0d", shared);        //$display("shared = %0d", pkt_b::shared);    end    endmodule</code></pre><p><strong>仿真结果：</strong></p><blockquote><p>pkg_a::va = 1,pkg_b:: = 2<br>shared = 20</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;类的继承&quot;&gt;&lt;a href=&quot;#类的继承&quot; class=&quot;headerlink&quot; title=&quot;类的继承&quot;&gt;&lt;/a&gt;类的继承&lt;/h1&gt;&lt;h2 id=&quot;实例1-子类没有定义new函数，会调用父类new函数&quot;&gt;&lt;a href=&quot;#实例1-子类没有定义new函数，会调用</summary>
      
    
    
    
    <category term="数字IC" scheme="https://www.daipeihong.top/categories/%E6%95%B0%E5%AD%97IC/"/>
    
    
    <category term="SystemVerilog验证" scheme="https://www.daipeihong.top/tags/SystemVerilog%E9%AA%8C%E8%AF%81/"/>
    
    <category term="类(class)" scheme="https://www.daipeihong.top/tags/%E7%B1%BB-class/"/>
    
    <category term="包(package)" scheme="https://www.daipeihong.top/tags/%E5%8C%85-package/"/>
    
  </entry>
  
  <entry>
    <title>SystemVerilog学习笔记(六)</title>
    <link href="https://www.daipeihong.top/2022/10/19/systemverilog-xue-xi-bi-ji-liu/"/>
    <id>https://www.daipeihong.top/2022/10/19/systemverilog-xue-xi-bi-ji-liu/</id>
    <published>2022-10-19T08:31:00.000Z</published>
    <updated>2022-10-23T08:41:28.055Z</updated>
    
    <content type="html"><![CDATA[<p><strong>类</strong>是一种可以包含数据和方法(function,task)的类型。<br>例如一个数据包，可能被定义为一个类，类中可以包含指令、地址、队列ID、时间戳和数据等成员。</p><p>类的三要素：<strong>封装、继承、多态</strong></p><p><strong>OOP（面向对象编程）术语</strong><br><strong>类(class) :  包含成员变量和成员方法。<br>对象(object)</strong>:类在例化后的实例。<br><strong>句柄(handle)</strong> :指向对象的指针。<br><strong>原型(prototype)</strong> :程序的声明部分，包含程序名、返回类型和参数列表。</p><h1 id="（一）类、模块、结构体比较"><a href="#（一）类、模块、结构体比较" class="headerlink" title="（一）类、模块、结构体比较"></a>（一）类、模块、结构体比较</h1>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210190953671.png" width="450" height="550">        <p>c1、c2称为句柄（类似于c中的指针），句柄是否例化通过是否有new的动作判断。new是在仿真时让仿真器创建一个相应实例（如果没有定义new函数，系统也会自动添加一个function new）。调用new函数后，开辟空间存放存放变量。new函数没有返回值，无需表明返回值类型，甚至无需声明void。当创建了一个实际对象时，new函数的返回值为对象的头部句柄（指针）</p>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210190954540.png" width="350" height="500">        <p>仿真目的是仿真真实的硬件，没有run任何时间单位前，整个硬件的结构就确定下来了。在仿真前，模块是有值的，而对象的创建是在仿真以后才会执行：<img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210190955582.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210190955905.png"></p><p>仿真run 0(很小的时间单位)后：<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210190956769.png"><br>同样地在进行仿真前，结构体也会有值（initial中的结构体静态变量同样如此），可进行如下验证：<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210190957043.png"><br>在仿真开始前：<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210190958060.png"></p><p>对new函数函数赋初值(new函数可以传参数)<br>对packet_c创建100个实例如下：<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191046905.png"><br><strong>c1最终指向最后一个实例，前面99个实例无法找回。</strong></p><p><strong>总结：</strong></p><ol><li>SV并不像C++语言一样要求复杂的存储空间开辟和销毁的手段，而是采用了像Java—样空间自动开辟和回收的手段。</li><li>因此SV的类在定义时，只需要定义构建函数(constructor)而不需要定义析构函数(destructor) 。</li><li>类在定义时，需要定义构建函数，如果未定义，则系统会自动帮助定义一个空的构建函数（没有形式参数，函数体亦为空)。</li></ol><h1 id="（二）句柄的拷贝"><a href="#（二）句柄的拷贝" class="headerlink" title="（二）句柄的拷贝"></a>（二）句柄的拷贝</h1>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191328440.jpg" width="550" height="850">        <p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191335916.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191335243.png"></p><p>两个句柄一个对象，几个new几个对象。（赋值的是句柄，不是对象!）<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191336888.png"></p><h1 id="（三）静态变量-amp-动态变量"><a href="#（三）静态变量-amp-动态变量" class="headerlink" title="（三）静态变量&amp;动态变量"></a>（三）静态变量&amp;动态变量</h1><p><strong>静态变量</strong>：仿真开始前已经分配空间<br><strong>动态变量</strong>：仿真开始时才分配空间<br>默认类里面所有成员(成员变量、成员方法或者其他)均是动态的，如果想要使用静态的，可用static<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191341299.png"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191343949.png"></p><p>此时句柄悬空，能否找到data？</p>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191424199.png" width="550" height="850">        <p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191424614.png"><br>编译器在编译时分析，句柄指向data是一个静态变量，仿真时data不会存放到任何实例化对象里面（c1.data、c2.data，任何一个data变量的存放空间不会在任何一个实例化的对象里面，如果存放在实例化对象里面，则空间各自独立。真正的空间在编译过程中开辟，可以姑且理解为放在类的下面）因此，编译器在编译时告诉我们说c1句柄指向的是packet这个类，data是一个静态变量。接下来仿真过程中找data时，不管c1有无指向对象，真正要找的变量放在类的域里面。</p><p><strong>总结：</strong></p><ol><li>类的成员(变量/方法)默认都是动态(automatic)生命周期，即每一个对象的变量和方法都会为其开辟新的空间。</li><li>如果多个对象为了共享一个成员(变量/方法)，那么可以为其添加关键字static。</li><li>多个对象因此可以共享同一个成员变量或者方法。</li><li>访问该成员时，无需进行对象的例化。</li><li>成员方法也可以声明为静态。</li><li>静态方法无法访问非静态成员(变量/方法)，否则会发生编译错误。</li></ol><h1 id="（四）this"><a href="#（四）this" class="headerlink" title="（四）this"></a>（四）this</h1><ol><li>this是用来明确索引当前所在对象的成员(变量/参数/方法。</li><li>this只可以用来在类的非静态成员、约束和覆盖组中使用。</li><li>this的使用可以明确所指向变量的作用域。</li></ol><pre class=" language-systemverilog"><code class="language-systemverilog">class Demo ;    integer x;    function new (integer x) ;        this.x =x;    endfunction    endclass</code></pre><p>this<br>赋值拷贝<br>链表</p><h1 id="（五）浅拷贝与深拷贝"><a href="#（五）浅拷贝与深拷贝" class="headerlink" title="（五）浅拷贝与深拷贝"></a>（五）浅拷贝与深拷贝</h1><p><strong>浅拷贝</strong>：只能拷贝成员里面的变量<br><strong>深拷贝</strong>：递进式拷贝，拷贝句柄及其指定对象。深拷贝与浅拷贝空间独立。</p>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191548706.png" width="500" height="260">        <h1 id="（六）数据的隐藏和封装"><a href="#（六）数据的隐藏和封装" class="headerlink" title="（六）数据的隐藏和封装"></a>（六）数据的隐藏和封装</h1><ol><li>类的成员(变量/方法)默认情况下，即是公共属性的。这表示对于类自身和外部均可以访问该成员。</li><li>对于成员的限定，如果使用local，则只有该类可以访问此成员，而子类或者外部均无法访问。</li><li>对于成员的限定，如果使用protected，则表示该类和其子类均可以访问此成员，而外部无法访问。</li></ol><pre class=" language-systemverilog"><code class="language-systemverilog">class Packet;    local integer i ;    function integer compare (Packet other) ;        compare = (this.i =other.i) ;    endfunctionendclass</code></pre><ol start="4"><li>对于商业开发，类的提供方会限制一些类成员的外部访问权限，继而隐藏类成员的更多细节。这种方式也使得类的外部访问接口更为精简，减轻了类的维护工作量，也使得类在修改时便于与旧版本保持兼容。数据隐藏的方式使得类的测试和维护都变得更为简单。</li></ol><p><strong>问答题</strong><br><strong>1.类和结构体的联系和差别有哪些?类和模块(module)的联系和差别有哪些?</strong><br>    <strong>类与结构体:</strong><br>    同：都可以包含指令、地址、队列ID、时间戳和数据等成员。<br>    异：(1)类需要调用new函数进行例化，才会开辟空间存放存放变量。而结构体在仿真前就开辟空间存放变量；(2)类可以包含数据和方法(function,task)的类型。<br>    <strong>类与模块：</strong><br>    同：都可以包含数据和方法(function,task)的类型。<br>    异：(1)类中的成员变量和方法默认是动态的，而模块默认是静态的；(2)在仿真前，模块是有值的，而类中对象的创建是在仿真以后才会执行</p><p><strong>3.如果有同名的模块，那么在编译过程中应该怎么解决“同名”问题?</strong><br>    可以用 this来明确索引当前所在对象的成员(变量/参数)方法。this只可以用来在类的非静态成员、约束和覆盖组中使用。</p><pre class=" language-systemverilog"><code class="language-systemverilog">class Demo ;    integer x;    function new (integer x) ;        this.x =x;    endfunction    endclass</code></pre><p>可参考：<a href="https://zhuanlan.zhihu.com/p/480524030">结构体、模块和类的联系和区别？ 类的学习小结 - 知乎 (zhihu.com)</a></p>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191616982.png" width="550" height="1000">        ]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;类&lt;/strong&gt;是一种可以包含数据和方法(function,task)的类型。&lt;br&gt;例如一个数据包，可能被定义为一个类，类中可以包含指令、地址、队列ID、时间戳和数据等成员。&lt;/p&gt;
&lt;p&gt;类的三要素：&lt;strong&gt;封装、继承、多态&lt;/strong&gt;</summary>
      
    
    
    
    <category term="数字IC" scheme="https://www.daipeihong.top/categories/%E6%95%B0%E5%AD%97IC/"/>
    
    
    <category term="数字前端" scheme="https://www.daipeihong.top/tags/%E6%95%B0%E5%AD%97%E5%89%8D%E7%AB%AF/"/>
    
    <category term="SystemVerilog验证" scheme="https://www.daipeihong.top/tags/SystemVerilog%E9%AA%8C%E8%AF%81/"/>
    
    <category term="类" scheme="https://www.daipeihong.top/tags/%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>SystemVerilog课程笔记(五)</title>
    <link href="https://www.daipeihong.top/2022/10/17/systemverilog-ke-cheng-bi-ji-wu/"/>
    <id>https://www.daipeihong.top/2022/10/17/systemverilog-ke-cheng-bi-ji-wu/</id>
    <published>2022-10-17T08:05:00.000Z</published>
    <updated>2022-11-17T11:25:37.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-构建generator"><a href="#1-构建generator" class="headerlink" title="1. 构建generator"></a>1. 构建generator</h1><p>stimulator只发送数据，构建generator产生数据发送给stimulator<br>数组与队列用法见[[SystemVerilog学习笔记(五)]]</p><h2 id="1-1改造"><a href="#1-1改造" class="headerlink" title="1.1改造"></a>1.1改造</h2><p>定义<span style="background:#fff88f">put_pkt</span>函数，将结构体p放入队列pkts里面</p><blockquote><p>function void put_pkt(input rt_packet_t p);<br>pkts.push_back(p);<br>endfunction</p></blockquote><p>定义<span style="background:#fff88f">get_pkt</span>任务，将p从队列pkts里面取出</p><blockquote><p>task get_pkt(output rt_packet_t p);<br>    wait(pkts.size() &gt;0 )//队列不为空<br>      p = pkts.pop_front();<br>  endtask</p></blockquote><p>数据发送过程<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211051352379.png" alt="|500"></p><h2 id="1-2改造后的tb-sv"><a href="#1-2改造后的tb-sv" class="headerlink" title="1.2改造后的tb.sv"></a>1.2改造后的tb.sv</h2><pre class=" language-systemverilog"><code class="language-systemverilog">typedef struct{  bit [3:0] src;  bit [3:0] dst;  bit [7:0] data [];}rt_packet_t;//定义结构体，结构体成员为发送端口，目标端口，发送数据//********************************** stimulator **********************************//module rt_stimulator(  input clock  ,input reset_n  ,output logic [15:0] din  ,output logic [15:0] frame_n  ,output logic [15:0] valid_n  ,input [15:0] dout  ,input [15:0] valido_n  ,input [15:0] busy_n  ,input [15:0] frameo_n);//for debug purpose from waveform//定义检测状态的变量  typedef enum {DRV_RESET,DRV_IDLE,DRV_ADDR,DRV_PAD,DRV_DATA} drv_state_t;  drv_state_t dbg_state;    byte unsigned dbg_din_chnl0_data; //receive p from generator  rt_packet_t pkts[$];//定义stimulator中的的队列okts  function void put_pkt(input rt_packet_t p);    pkts.push_back(p);//将generator中传过来的p放入stimulator的pkts中(在pkts队列尾插入p)  endfunction//reset阶段，复位时，reset_n为低电平,frame_n和valid_n为高电平initial begin : drive_reset_proc   drive_reset();endtask drive_reset();  @(negedge reset_n);  dbg_state <= DRV_RESET;  din <= 0;  frame_n <= '1;//等效16'hFFFF  valid_n <= '1;endtask// drive chaannel 0 - chanel 15 (din[15:0])定义数据输出地址及数据bit [3:0] daddr;byte unsigned data[];initial begin : drive_chnl0_proc    rt_packet_t p;  @(negedge reset_n);  repeat(10) @(posedge clock);//延迟10个时钟周期  forever begin    wait(pkts.size()>0);    p = pkts.pop_front();//将p从队列pkts里面取出    drive_chnl(p.src,p.dst,p.data);//从P中拿到发送端口，目标端口，发送数据    end    //drive_chnl(0,3,'{8'h33,8'h77});//name mapping    //drive_chnl(0,5,'{8'h55,8'h66});//name mappingendinitial begin : drive_chnl3_proc  @(negedge reset_n);  repeat(10) @(posedge clock);//延迟10个时钟周期    drive_chnl(3,6,'{8'h77,8'h88,8'h22});//name mappingendtask automatic drive_chnl(bit[3:0] saddr, bit [3:0] daddr, byte unsigned data[]);  $display("[DRV]src_chnl[%0d],dest_chnl[%0d] data trans started",saddr,daddr);    // drive address phase 输入地址位阶段for(int i=0;i<4;i++)begin  //4 clock  @(posedge clock);  dbg_state <=DRV_ADDR;  din[saddr] <= daddr[i];  valid_n[saddr] <= $urandom_range(0,1);//valid_n在din的地址输入时间段可为任意值x  frame_n[saddr] <= 1'b0;//frame_n需要为低end    // drive pad phase //隔离阶段  for (int i=0;i<5;i++)begin  //5 clock    @(posedge clock);    dbg_state <=DRV_PAD;    din[saddr] <= 1'b1;    valid_n[saddr] <= 1'b1;//valid_n需为高电平    frame_n[saddr] <= 1'b0; //frame_n需为低电平  end    // drive data phase 传输数据阶段  foreach(data[id])begin    for(int i=0;i<8;i++)begin     @(posedge clock);      dbg_state <=DRV_DATA;      dbg_din_chnl0_data <= data[id];      din[saddr] <= data[id][i];      valid_n[saddr] <=1'b0;      frame_n[saddr] <= (id == data.size()-1 && i == 7) ? 1'b1 : 1'b0;//packet最后一位输出数据时frameo_n为高    end  end// drive idle phase 闲置（没有数据传输）阶段  @(posedge clock);  dbg_state <=DRV_IDLE;  dbg_din_chnl0_data <= 0;  din[saddr] <= 1'b0;  valid_n[saddr] <= 1'b1;  frame_n[saddr] <= 1'b1;  $display("[DRV]src_chnl[%0d],dest_chnl[%0d] data trans finished",saddr,daddr);endtaskendmodule//********************************** generator **********************************//module rt_generator;//generator产生数据交给stimulator  rt_packet_t pkts[$];//定义队列  function void put_pkt(input rt_packet_t p);    pkts.push_back(p);//将p放入队列pkts里面（在pkts队列尾插入p）  endfunction    task get_pkt(output rt_packet_t p);    wait(pkts.size() >0 )//队列不为空      p = pkts.pop_front();//将p从队列pkts里面取出，提取队列首元素  endtask  //generate a random packet  function void gen_pkt(int src = -1, int dst = -1);  endfunctionendmodule//********************************** tb **********************************//module tb;bit clk,rstn;logic [15:0] din, frame_n, valid_n;logic [15:0] dout, valido_n, busy_n, frameo_n;// 产生时钟，周期为10nsinitial     forever #5ns clk <= !clk;// 产生复位信号  initial begin    #2ns rstn <= 1;    #10ns rstn <= 0;    #10ns rstn <= 1;  end//例化router为DUTrouter dut(             .reset_n(rstn),  .clock(clk),  .*  //其余端口名称均相同);//例化stimulatorrt_stimulator stim(  .reset_n(rstn),  .clock(clk),  .*);//例化generatorrt_generator gen();initial begin:generate_data_proc//产生数据    rt_packet_t p;    p =  '{0,3,'{8'h33,8'h77}};    gen.put_pkt(p);//调用genarator里面的put_pkt函数    gen.put_pkt('{0,5,'{8'h55,8'h66}});endinitial begin:genarator_to_stimulator_proc//取出genarator中的数据给stimulator    rt_packet_t p;    forever begin        gen.get_pkt(p);        stim.put_pkt(p);    endendendmodule                      </code></pre><h2 id="1-3仿真结果"><a href="#1-3仿真结果" class="headerlink" title="1.3仿真结果"></a>1.3仿真结果</h2><p>同前面一样<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211051044480.png"></p><h2 id="1-4问题"><a href="#1-4问题" class="headerlink" title="1.4问题"></a>1.4问题</h2><p>但是如果生成数据采用如下方式，不同source_chnl不能同时发送数据（<span style="background:rgba(240, 200, 0, 0.2)">上一节是因为采用了两个initial begin end语句块才能并行发送</span>）</p><blockquote><p>gen.put_pkt(‘{0,3,’{8’h33,8’h77}});<br>gen.put_pkt(‘{0,5,’{8’h55,8’h66}});<br>gen.put_pkt(‘{3,6,’{8’h77,8’h88,8’h22}});<br>//source_chnl0和source_chnl3不能同时发送</p></blockquote><p>仿真结果如下<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211051554321.png"></p><h1 id="2-来自于不同的source-chnl可以并行发送"><a href="#2-来自于不同的source-chnl可以并行发送" class="headerlink" title="2. 来自于不同的source chnl可以并行发送"></a>2. 来自于不同的source chnl可以并行发送</h1><h2 id="2-1改造"><a href="#2-1改造" class="headerlink" title="2.1改造"></a>2.1改造</h2><p><strong>增加要求</strong>：如果两个chnl没有冲突，可以同时发送<br><strong>具体为：</strong><br>来自于不同的source chnl就可以并行发送<br>source chnl、destination chnl不一样可以并行发送<br><strong>方法：</strong></p><ul><li><p><strong>定义关联数组</strong><br>int src_chnl_status[int];  //关联数组</p></li><li><p><strong>定义判断src_chnl是否空闲的任务</strong><br>task判断src chnl是否被占用，是否需要等待。src_chnl_status关联数组里面不含p.src，(表示未占用任何dest_chnl,一开始不满足）。反之，如果含有，表示当前正在使用src_chnl,对应dest_chnl就是p.dst（p.src端口在向p.dst端口发送数据）。如果在给0,1,2…dest_chnl发送数据（被占用），需要等待,，否则不需要等待。直到src_chnl_status[p.src] == -1(自定义的dest_chnl端口数之外任意的数，表示未占用任何dest_chnl)</p><blockquote><p>task automatic wait_src_chnl_avail(rt_packet_t p);<br>  if(!src_chnl_status.exists(p.src))//src_chnl_status关联数组里面不含p.src，(表示未占用任何dest_chnl,一开始不满足）<br>  src_chnl_status[p.src] = p.dst;//表示当前正在使用src_chnl,对应dest_chnl就是p.dst（p.src端口在向p.dst端口发送数据）<br>  else if(src_chnl_status[p.src] &gt;= 0)//如果在给0,1,2…dest_chnl发送数据（被占用），需要等待,，否则不需要等待<br>  wait(src_chnl_status[p.src] == -1);//直到src_chnl_status[p.src] == -1(自定义的dest_chnl端口数之外任意的数，表示未占用任何dest_chnl)<br>endtask</p></blockquote></li><li><p><strong>采用fork join none后台线程，判断src chnl是否被占用，是否需要等待</strong></p><blockquote><p>fork//后台触发线程，触发线程在后台运行，继续执行剩下内容<br>  begin<br>      wait_src_chnl_avail(p);//判断src chnl是否被占用，是否需要等待<br>      drive_chnl(p.src, p.dst, p.data);//从P中拿到发送端口，目标端口，发送数据<br>      set_src_chnl_avail(p);<br>  end<br>  join_none</p></blockquote></li><li><p>然后把src_chnl置位</p><blockquote><p>function automatic set_src_chnl_avail(rt_packet_t p);<br>  src_chnl_status[p.src] = -1;//如果chnl发送完后，把src_chnl置回来(自定义的dest_chnl端口数之外任意的数，表示未占用任何dest_chnl)<br>endfunction</p></blockquote></li></ul><h2 id="2-2改造后的tb-sv"><a href="#2-2改造后的tb-sv" class="headerlink" title="2.2改造后的tb.sv"></a>2.2改造后的tb.sv</h2><pre class=" language-systemverilog"><code class="language-systemverilog">typedef struct{  bit [3:0] src;  bit [3:0] dst;  bit [7:0] data [];}rt_packet_t;//定义结构体，结构体成员为发送端口，目标端口，发送数据//********************************** stimulator **********************************//module rt_stimulator(  input clock  ,input reset_n  ,output logic [15:0] din  ,output logic [15:0] frame_n  ,output logic [15:0] valid_n  ,input [15:0] dout  ,input [15:0] valido_n  ,input [15:0] busy_n  ,input [15:0] frameo_n);//for debug purpose from waveform//定义检测状态的变量  typedef enum {DRV_RESET,DRV_IDLE,DRV_ADDR,DRV_PAD,DRV_DATA} drv_state_t;  drv_state_t dbg_state;    byte unsigned dbg_din_chnl0_data;     int src_chnl_status[int];  //关联数组，后面int：src_chnl的number；前面int：dest_chnl的Number ？？    //receive p from generator  rt_packet_t pkts[$];//定义stimulator中的的队列okts  function void put_pkt(input rt_packet_t p);    pkts.push_back(p);//将generator中传过来的p放入stimulator的pkts中(在pkts队列尾插入p)  endfunction//reset阶段，复位时，reset_n为低电平,frame_n和valid_n为高电平initial begin : drive_reset_proc   drive_reset();endtask drive_reset();  @(negedge reset_n);  dbg_state <= DRV_RESET;  din <= 0;  frame_n <= '1;//等效16'hFFFF  valid_n <= '1;endtask// 发送数据bit [3:0] daddr;byte unsigned data[];initial begin : drive_chnl_proc    //rt_packet_t p;  @(negedge reset_n);  repeat(10) @(posedge clock);//延迟10个时钟周期  forever begin    automatic rt_packet_t p;//声明一个动态的    wait(pkts.size()>0);    p = pkts.pop_front();//将p从队列pkts里面取出        fork//后台触发线程，触发线程在后台运行，继续执行剩下内容        begin            wait_src_chnl_avail(p);//判断src chnl是否被占用，是否需要等待            drive_chnl(p.src, p.dst, p.data);//从P中拿到发送端口，目标端口，发送数据            set_src_chnl_avail(p);        end    join_none        end    //drive_chnl(0,3,'{8'h33,8'h77});//name mapping    //drive_chnl(0,5,'{8'h55,8'h66});//name mappingendtask automatic wait_src_chnl_avail(rt_packet_t p);//判断src chnl是否被占用，是否需要等待    if(!src_chnl_status.exists(p.src))//src_chnl_status关联数组里面不含p.src，(表示未占用任何dest_chnl,一开始不满足）        src_chnl_status[p.src] = p.dst;//表示当前正在使用src_chnl,对应dest_chnl就是p.dst（p.src端口在向p.dst端口发送数据）    else if(src_chnl_status[p.src] >= 0)//如果在给0,1,2...dest_chnl发送数据（被占用），需要等待,，否则不需要等待        wait(src_chnl_status[p.src] == -1);//直到src_chnl_status[p.src] == -1(自定义的dest_chnl端口数之外任意的数，表示未占用任何dest_chnl)endtaskfunction automatic set_src_chnl_avail(rt_packet_t p);    src_chnl_status[p.src] = -1;//如果chnl发送完后，把src_chnl置回来(自定义的dest_chnl端口数之外任意的数，表示未占用任何dest_chnl)endfunctiontask automatic drive_chnl(bit[3:0] saddr, bit [3:0] daddr, byte unsigned data[]);  $display("@%0t:[DRV]src_chnl[%0d],dest_chnl[%0d] data trans started",$time,saddr,daddr);    // drive address phase 输入地址位阶段for(int i=0;i<4;i++)begin  //4 clock  @(posedge clock);  dbg_state <=DRV_ADDR;  din[saddr] <= daddr[i];  valid_n[saddr] <= $urandom_range(0,1);//valid_n在din的地址输入时间段可为任意值x  frame_n[saddr] <= 1'b0;//frame_n需要为低end    // drive pad phase //隔离阶段  for (int i=0;i<5;i++)begin  //5 clock    @(posedge clock);    dbg_state <=DRV_PAD;    din[saddr] <= 1'b1;    valid_n[saddr] <= 1'b1;//valid_n需为高电平    frame_n[saddr] <= 1'b0; //frame_n需为低电平  end    // drive data phase 传输数据阶段  foreach(data[id])begin    for(int i=0;i<8;i++)begin     @(posedge clock);      dbg_state <=DRV_DATA;      dbg_din_chnl0_data <= data[id];      din[saddr] <= data[id][i];      valid_n[saddr] <=1'b0;      frame_n[saddr] <= (id == data.size()-1 && i == 7) ? 1'b1 : 1'b0;//packet最后一位输出数据时frameo_n为高    end  end// drive idle phase 闲置（没有数据传输）阶段  @(posedge clock);  dbg_state <=DRV_IDLE;  dbg_din_chnl0_data <= 0;  din[saddr] <= 1'b0;  valid_n[saddr] <= 1'b1;  frame_n[saddr] <= 1'b1;  $display("@%0t:[DRV]src_chnl[%0d],dest_chnl[%0d] data trans finished",$time,saddr,daddr);endtaskendmodule//********************************** generator **********************************//module rt_generator;//generator产生数据交给stimulator  rt_packet_t pkts[$];//定义队列  function void put_pkt(input rt_packet_t p);    pkts.push_back(p);//将p放入队列pkts里面（在pkts队列尾插入p）  endfunction    task get_pkt(output rt_packet_t p);    wait(pkts.size() >0 )//队列不为空      p = pkts.pop_front();//将p从队列pkts里面取出，提取队列首元素  endtask  //generate a random packet  function void gen_pkt(int src = -1, int dst = -1);  endfunctionendmodule//********************************** tb **********************************//module tb;bit clk,rstn;logic [15:0] din, frame_n, valid_n;logic [15:0] dout, valido_n, busy_n, frameo_n;// 产生时钟，周期为10nsinitial     forever #5ns clk <= !clk;// 产生复位信号  initial begin    #2ns rstn <= 1;    #10ns rstn <= 0;    #10ns rstn <= 1;  end//例化router为DUTrouter dut(             .reset_n(rstn),  .clock(clk),  .*  //其余端口名称均相同);//例化stimulatorrt_stimulator stim(  .reset_n(rstn),  .clock(clk),  .*);//例化generatorrt_generator gen();initial begin:generate_data_proc//产生数据    rt_packet_t p;    gen.put_pkt('{0,3,'{8'h33,8'h77}});//调用genarator里面的put_pkt函数    gen.put_pkt('{0,5,'{8'h55,8'h66}});    gen.put_pkt('{3,6,'{8'h77,8'h88,8'h22}});    gen.put_pkt('{4,7,'{8'haa,8'hcc,8'h33}});endinitial begin:genarator_to_stimulator_proc//取出genarator中的数据给stimulator    rt_packet_t p;    forever begin        gen.get_pkt(p);        stim.put_pkt(p);    endendendmodule </code></pre><h2 id="2-3仿真结果"><a href="#2-3仿真结果" class="headerlink" title="2.3仿真结果"></a>2.3仿真结果</h2><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211051538925.png"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210201409514.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210201543806.png"></p><h1 id="3-增加接口-interface"><a href="#3-增加接口-interface" class="headerlink" title="3. 增加接口(interface)"></a>3. 增加接口(interface)</h1><p>interface用法见[[SystemVerilog学习笔记(三)]]</p><h2 id="3-1改进"><a href="#3-1改进" class="headerlink" title="3.1改进"></a>3.1改进</h2><p>增加接口模块</p><blockquote><p>interface rt_interface();<br>logic clock;<br>logic reset_n;<br>logic [15:0] din;<br>logic [15:0] frame_n;<br>logic [15:0] valid_n;<br>logic [15:0] dout;<br>logic [15:0] valido_n;<br>logic [15:0] busy_n;<br>logic [15:0] frameo_n;<br>endinterface</p></blockquote><h2 id="3-2改造后的tb-sv"><a href="#3-2改造后的tb-sv" class="headerlink" title="3.2改造后的tb.sv"></a>3.2改造后的tb.sv</h2><pre class=" language-systemverilog"><code class="language-systemverilog">typedef struct{  bit [3:0] src;  bit [3:0] dst;  bit [7:0] data [];}rt_packet_t;//定义结构体，结构体成员为发送端口，目标端口，发送数据interface rt_interface();    logic clock;    logic reset_n;    logic [15:0] din;    logic [15:0] frame_n;    logic [15:0] valid_n;    logic [15:0] dout;    logic [15:0] valido_n;    logic [15:0] busy_n;    logic [15:0] frameo_n;endinterface//********************************** stimulator **********************************//module rt_stimulator(rt_interface intf);//for debug purpose from waveform//定义检测状态的变量  typedef enum {DRV_RESET,DRV_IDLE,DRV_ADDR,DRV_PAD,DRV_DATA} drv_state_t;  drv_state_t dbg_state;    byte unsigned dbg_din_chnl0_data;     int src_chnl_status[int];  //关联数组，后面int：src_chnl的number；前面int：dest_chnl的Number ？？    //receive p from generator  rt_packet_t pkts[$];//定义stimulator中的的队列okts  function void put_pkt(input rt_packet_t p);    pkts.push_back(p);//将generator中传过来的p放入stimulator的pkts中(在pkts队列尾插入p)  endfunction//reset阶段，复位时，reset_n为低电平,frame_n和valid_n为高电平initial begin : drive_reset_proc   drive_reset();endtask drive_reset();  @(negedge intf.reset_n);  dbg_state <= DRV_RESET;  intf.din <= 0;  intf.frame_n <= '1;//等效16'hFFFF  intf.valid_n <= '1;endtask// 发送数据bit [3:0] daddr;byte unsigned data[];initial begin : drive_chnl_proc    //rt_packet_t p;  @(negedge intf.reset_n);  repeat(10) @(posedge intf.clock);//延迟10个时钟周期  forever begin    automatic rt_packet_t p;//声明一个动态的    wait(pkts.size()>0);    p = pkts.pop_front();//将p从队列pkts里面取出        fork//后台触发线程，触发线程在后台运行，继续执行剩下内容        begin            wait_src_chnl_avail(p);//判断src chnl是否被占用，是否需要等待            drive_chnl(p.src, p.dst, p.data);//从P中拿到发送端口，目标端口，发送数据            set_src_chnl_avail(p);        end    join_none        end    //drive_chnl(0,3,'{8'h33,8'h77});//name mapping    //drive_chnl(0,5,'{8'h55,8'h66});//name mappingendtask automatic wait_src_chnl_avail(rt_packet_t p);//判断src chnl是否被占用，是否需要等待    if(!src_chnl_status.exists(p.src))//src_chnl_status关联数组里面不含p.src，(表示未占用任何dest_chnl,一开始不满足）        src_chnl_status[p.src] = p.dst;//表示当前正在使用src_chnl,对应dest_chnl就是p.dst（p.src端口在向p.dst端口发送数据）    else if(src_chnl_status[p.src] >= 0)//如果在给0,1,2...dest_chnl发送数据（被占用），需要等待,，否则不需要等待        wait(src_chnl_status[p.src] == -1);//直到src_chnl_status[p.src] == -1(自定义的dest_chnl端口数之外任意的数，表示未占用任何dest_chnl)endtaskfunction automatic set_src_chnl_avail(rt_packet_t p);    src_chnl_status[p.src] = -1;//如果chnl发送完后，把src_chnl置回来(自定义的dest_chnl端口数之外任意的数，表示未占用任何dest_chnl)endfunctiontask automatic drive_chnl(bit[3:0] saddr, bit [3:0] daddr, byte unsigned data[]);  $display("@%0t:[DRV]src_chnl[%0d],dest_chnl[%0d] data trans started",$time,saddr,daddr);    // drive address phase 输入地址位阶段for(int i=0;i<4;i++)begin  //4 clock  @(posedge intf.clock);  dbg_state <=DRV_ADDR;  intf.din[saddr] <= daddr[i];  intf.valid_n[saddr] <= $urandom_range(0,1);//valid_n在din的地址输入时间段可为任意值x  intf.frame_n[saddr] <= 1'b0;//frame_n需要为低end    // drive pad phase //隔离阶段  for (int i=0;i<5;i++)begin  //5 clock    @(posedge intf.clock);    dbg_state <=DRV_PAD;    intf.din[saddr] <= 1'b1;    intf.valid_n[saddr] <= 1'b1;//valid_n需为高电平    intf.frame_n[saddr] <= 1'b0; //frame_n需为低电平  end    // drive data phase 传输数据阶段  foreach(data[id])begin    for(int i=0;i<8;i++)begin     @(posedge intf.clock);      dbg_state <=DRV_DATA;      dbg_din_chnl0_data <= data[id];      intf.din[saddr] <= data[id][i];      intf.valid_n[saddr] <=1'b0;      intf.frame_n[saddr] <= (id == data.size()-1 && i == 7) ? 1'b1 : 1'b0;//packet最后一位输出数据时frameo_n为高    end  end// drive idle phase 闲置（没有数据传输）阶段  @(posedge intf.clock);  dbg_state <=DRV_IDLE;  dbg_din_chnl0_data <= 0;  intf.din[saddr] <= 1'b0;  intf.valid_n[saddr] <= 1'b1;  intf.frame_n[saddr] <= 1'b1;  $display("@%0t:[DRV]src_chnl[%0d],dest_chnl[%0d] data trans finished",$time,saddr,daddr);endtaskendmodule//********************************** generator **********************************//module rt_generator;//generator产生数据交给stimulator  rt_packet_t pkts[$];//定义队列  function void put_pkt(input rt_packet_t p);    pkts.push_back(p);//将p放入队列pkts里面（在pkts队列尾插入p）  endfunction    task get_pkt(output rt_packet_t p);    wait(pkts.size() >0 )//队列不为空      p = pkts.pop_front();//将p从队列pkts里面取出，提取队列首元素  endtask  //generate a random packet  function void gen_pkt(int src = -1, int dst = -1);  endfunctionendmodule//********************************** tb **********************************//module tb;bit clk,rstn;logic [15:0] din, frame_n, valid_n;logic [15:0] dout, valido_n, busy_n, frameo_n;// 产生时钟，周期为10nsinitial     forever #5ns clk <= !clk;// 产生复位信号  initial begin    #2ns rstn <= 1;    #10ns rstn <= 0;    #10ns rstn <= 1;  end//例化router为DUTrouter dut(             .reset_n(rstn),  .clock(clk),  .frame_n(intf.frame_n),  .valid_n(intf.valid_n),  .dout(intf.dout),  .busy_n(intf.busy_n),  .valido_n(intf.valido_n),  .frameo_n(intf.frameo_n));rt_interface intf();//例化接口    assign intf.reset_n = rstn;    assign intf.clock = clk;    //例化stimulatorrt_stimulator stim(intf);//例化generatorrt_generator gen();    initial begin:generate_data_proc//产生数据    rt_packet_t p;    gen.put_pkt('{0,3,'{8'h33,8'h77}});//调用genarator里面的put_pkt函数    gen.put_pkt('{0,5,'{8'h55,8'h66}});    gen.put_pkt('{3,6,'{8'h77,8'h88,8'h22}});    gen.put_pkt('{4,7,'{8'haa,8'hcc,8'h33}});endinitial begin:genarator_to_stimulator_proc//取出genarator中的数据给stimulator    rt_packet_t p;    forever begin        gen.get_pkt(p);        stim.put_pkt(p);    endendendmodule </code></pre><h2 id="3-3仿真结果"><a href="#3-3仿真结果" class="headerlink" title="3.3仿真结果"></a>3.3仿真结果</h2><p>只增加了接口，仿真结果未变<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211052013674.png"><br>硬件层次结构如下<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211052014621.png"></p><h1 id="4-初步TestBench概览"><a href="#4-初步TestBench概览" class="headerlink" title="4. 初步TestBench概览"></a>4. 初步TestBench概览</h1>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211052040259.png" width="600" height="360" title=" ">        <h1 id="5-增加monitor"><a href="#5-增加monitor" class="headerlink" title="5. 增加monitor"></a>5. 增加monitor</h1><h2 id="5-1-改造"><a href="#5-1-改造" class="headerlink" title="5.1 改造"></a>5.1 改造</h2><p>增加组件monitor，监测输入数据和输出数据<br>监测数据输入的task：</p><pre class=" language-systemverilog"><code class="language-systemverilog">task automatic mon_chnl_in (bit[3:0]id);//监测数据输入的任务    rt_packet_t pkt;//定义结构体变量    forever begin    //clear content for the same struct variable。清除pkt    pkt.data.delete();    pkt.src = id;//第id个输入端口    //monitor specific channel-in data and put it into the queue    // monitor address phase    @(negedge intf.frame_n[id]);//监测frame_n下降沿(frame_n由时钟驱动)    $display ("@%0t: [MON] src_chn1[%0d] & dest_chn1[%0d] data trans started",$time,pkt.src,pkt.dst);    for(int i=0; i<4; i++)begin        @(negedge intf.clock);//frame_n下降沿后监测4个clk negedge        pkt.dst[i]= intf.din[id];        end    //pass pad phase 不考虑pad阶段是否满足协议要求    repeat(5) @(negedge intf.clock);    do begin        pkt.data = new [pkt.data.size + 1](pkt.data);//创建动态数组并复制pkt.data        for ( int i=0; i<8; i++) begin            @(negedge intf.clock); //在8个clk negedge监测8bit数据            pkt.data[pkt.data.size-1][i] = intf.din[id];        end    end while(!intf.frame_n[id]);    in_pkts[id].push_back(pkt);//将monitor拿到的数据放入in_pkts    $display("@%0t: [MON] src_chn1[%0d] & dest_chn1[%0d] data trans [%0p] finished",$time,pkt.src,pkt.dst,pkt.data);    endendtask</code></pre><p>监测数据输入的task：</p><pre class=" language-systemverilog"><code class="language-systemverilog">task automatic mon_chnl_out(bit[ 3:0]id);//监测数据输出的任务    rt_packet_t pkt;    forever begin        //clear content for the same struct variable        pkt.data.delete();        pkt.src = 0;        pkt.dst = id;        @(negedge intf.frameo_n[id]);        $display( "@%0t: [MON] CH_OUT dest_chn1[%0d] data trans started",$time,pkt.dst);        do begin        pkt.data = new [ pkt.data.size + 1](pkt.data);        for(int i=0;i<8; i++) begin            @(negedge intf.clock iff !intf.valido_n[id]);//clock与valido_n信号同时为低            pkt.data[pkt.data.size-1][i]= intf.dout [id];        end    end while(!intf.frameo_n[id]);    out_pkts[id].push_back(pkt);    $display("@%0t: [MON] CH_OUT dest_chn1[%0d] data trans [%0p] finished",$time,pkt.dst,pkt.data);    //monitor specific channel-out data and put it into the queue    endendtask</code></pre><h2 id="5-2-改造后的tb-sv"><a href="#5-2-改造后的tb-sv" class="headerlink" title="5.2 改造后的tb.sv"></a>5.2 改造后的tb.sv</h2><pre class=" language-systemverilog"><code class="language-systemverilog">typedef struct{  bit [3:0] src;  bit [3:0] dst;  bit [7:0] data [];}rt_packet_t;//定义结构体，结构体成员为发送端口，目标端口，发送数据interface rt_interface();    logic clock;    logic reset_n;    logic [15:0] din;    logic [15:0] frame_n;    logic [15:0] valid_n;    logic [15:0] dout;    logic [15:0] valido_n;    logic [15:0] busy_n;    logic [15:0] frameo_n;endinterface//********************************** stimulator **********************************//module rt_stimulator(    rt_interface intf);//for debug purpose from waveform//定义检测状态的变量  typedef enum {DRV_RESET,DRV_IDLE,DRV_ADDR,DRV_PAD,DRV_DATA} drv_state_t;  drv_state_t dbg_state;    byte unsigned dbg_din_chnl0_data;   int src_chnl_status[int];  //关联数组，后面int：src_chnl的number；前面int：dest_chnl的Number ？？    //generator传送p给stimulator  rt_packet_t pkts[$];//定义stimulator中的的队列pkts  function void put_pkt(input rt_packet_t p);    pkts.push_back(p);//将generator中传过来的p放入stimulator的pkts中(在pkts队列尾插入p)  endfunction//reset阶段，复位时，reset_n为低电平,frame_n和valid_n为高电平initial begin : drive_reset_proc   drive_reset();endtask drive_reset();  @(negedge intf.reset_n);  dbg_state <= DRV_RESET;  intf.din <= 0;  intf.frame_n <= '1;//等效16'hFFFF  intf.valid_n <= '1;endtask// 发送数据initial begin : drive_chnl_proc    //rt_packet_t p;  @(negedge intf.reset_n);  repeat(10) @(posedge intf.clock);//延迟10个时钟周期  forever begin    automatic rt_packet_t p;//声明一个动态的    wait(pkts.size()>0);    p = pkts.pop_front();//将p从队列pkts里面取出    fork//后台触发线程，触发线程在后台运行，继续执行剩下内容        begin            wait_src_chnl_avail(p);//判断src chnl是否被占用，是否需要等待            drive_chnl(p.src, p.dst, p.data);//从P中拿到发送端口，目标端口，发送数据            set_src_chnl_avail(p);        end    join_none    endendtask automatic wait_src_chnl_avail(rt_packet_t p);//判断src chnl是否被占用，是否需要等待    if(!src_chnl_status.exists(p.src))//src_chnl_status关联数组里面不含p.src，(表示未占用任何dest_chnl,一开始不满足）        src_chnl_status[p.src] = p.dst;//表示当前正在使用src_chnl,对应dest_chnl就是p.dst（p.src端口在向p.dst端口发送数据）    else if(src_chnl_status[p.src] >= 0)//如果在给0,1,2...dest_chnl发送数据（被占用），需要等待,，否则不需要等待        wait(src_chnl_status[p.src] == -1);//直到src_chnl_status[p.src] == -1(自定义的dest_chnl端口数之外任意的数，表示未占用任何dest_chnl)endtaskfunction automatic set_src_chnl_avail(rt_packet_t p);    src_chnl_status[p.src] = -1;//如果chnl发送完后，把src_chnl置回来(自定义的dest_chnl端口数之外任意的数，表示未占用任何dest_chnl)endfunctiontask automatic drive_chnl(bit[3:0] saddr, bit [3:0] daddr, byte unsigned data[]);  $display("@%0t: [DRV]src_chnl[%0d],dest_chnl[%0d] data trans started",$time,saddr,daddr);    // drive address phase 输入地址位阶段for(int i=0;i<4;i++)begin  //4 clock  @(posedge intf.clock);  dbg_state <=DRV_ADDR;  intf.din[saddr] <= daddr[i];  intf.valid_n[saddr] <= $urandom_range(0,1);//valid_n在din的地址输入时间段可为任意值x  intf.frame_n[saddr] <= 1'b0;//frame_n需要为低end    // drive pad phase //隔离阶段  for (int i=0;i<5;i++)begin  //5 clock    @(posedge intf.clock);    dbg_state <=DRV_PAD;    intf.din[saddr] <= 1'b1;    intf.valid_n[saddr] <= 1'b1;//valid_n需为高电平    intf.frame_n[saddr] <= 1'b0; //frame_n需为低电平  end    // drive data phase 传输数据阶段  foreach(data[id])begin    for(int i=0;i<8;i++)begin     @(posedge intf.clock);      dbg_state <=DRV_DATA;      dbg_din_chnl0_data <= data[id];      intf.din[saddr] <= data[id][i];      intf.valid_n[saddr] <=1'b0;      intf.frame_n[saddr] <= (id == data.size()-1 && i == 7) ? 1'b1 : 1'b0;//packet最后一位输出数据时frameo_n为高    end  end// drive idle phase 闲置（没有数据传输）阶段  @(posedge intf.clock);  dbg_state <=DRV_IDLE;  dbg_din_chnl0_data <= 0;  intf.din[saddr] <= 1'b0;  intf.valid_n[saddr] <= 1'b1;  intf.frame_n[saddr] <= 1'b1;  $display("@%0t: [DRV]src_chnl[%0d],dest_chnl[%0d] data trans finished",$time,saddr,daddr);endtaskendmodule//********************************** generator **********************************//module rt_generator;//generator产生数据交给stimulator  rt_packet_t pkts[$];//定义队列  function void put_pkt(input rt_packet_t p);    pkts.push_back(p);//将p放入队列pkts里面（在pkts队列尾插入p）  endfunction    task get_pkt(output rt_packet_t p);    wait(pkts.size() >0 )//队列不为空      p = pkts.pop_front();//将p从队列pkts里面取出，提取队列首元素  endtask  //generate a random packet  function void gen_pkt(int src = -1, int dst = -1);  endfunctionendmodule//********************************** monitor **********************************//module rt_monitor(rt_interface intf);    rt_packet_t in_pkts[16][$];    rt_packet_t out_pkts[16][$];    initial begin : mon_chnl_proc        foreach(in_pkts[i]) begin            automatic int chid = i;            fork            mon_chnl_in(chid);//每个输入端口均调用mon_chnl_in任务，监测数据输入            mon_chnl_out(chid);//每个输出端口均调用mon_chnl_out任务，监测数据输入            join_none        end    end    task automatic mon_chnl_in (bit[3:0]id);//监测数据输入的任务    rt_packet_t pkt;//定义结构体变量    forever begin    //clear content for the same struct variable。清除pkt    pkt.data.delete();    pkt.src = id;//第id个输入端口    //monitor specific channel-in data and put it into the queue    // monitor address phase    @(negedge intf.frame_n[id]);//监测frame_n下降沿(frame_n由时钟驱动)        for(int i=0; i<4; i++)begin        @(negedge intf.clock);//frame_n下降沿后监测4个clk negedge        pkt.dst[i]= intf.din[id];        end  $display ("@%0t: [MON] src_chn1[%0d] & dest_chn1[%0d] data trans started",$time,pkt.src,pkt.dst);    //pass pad phase 不考虑pad阶段是否满足协议要求    repeat(5) @(negedge intf.clock);    do begin        pkt.data = new [pkt.data.size + 1](pkt.data);//创建动态数组并复制pkt.data        for ( int i=0; i<8; i++) begin            @(negedge intf.clock); //在8个clk negedge监测8bit数据            pkt.data[pkt.data.size-1][i] = intf.din[id];        end    end while(!intf.frame_n[id]);    in_pkts[id].push_back(pkt);//将monitor拿到的数据放入in_pkts    $display("@%0t: [MON] src_chn1[%0d] & dest_chn1[%0d] data trans [%0p] finished",$time,pkt.src,pkt.dst,pkt.data);    endendtasktask automatic mon_chnl_out(bit[ 3:0]id);//监测数据输出的任务    rt_packet_t pkt;    forever begin        //clear content for the same struct variable        pkt.data.delete();        pkt.src = 0;        pkt.dst = id;        @(negedge intf.frameo_n[id]);        $display( "@%0t: [MON] CH_OUT dest_chn1[%0d] data trans started",$time,pkt.dst);        do begin        pkt.data = new [ pkt.data.size + 1](pkt.data);        for(int i=0;i<8; i++) begin            @(negedge intf.clock iff !intf.valido_n[id]);//clock与valido_n信号同时为低            pkt.data[pkt.data.size-1][i]= intf.dout [id];        end    end while(!intf.frameo_n[id]);    out_pkts[id].push_back(pkt);    $display("@%0t: [MON] CH_OUT dest_chn1[%0d] data trans [%0p] finished",$time,pkt.dst,pkt.data);    //monitor specific channel-out data and put it into the queue    endendtaskendmodule//********************************** tb **********************************//module tb;bit clk,rstn;logic [15:0] din, frame_n, valid_n;logic [15:0] dout, valido_n, busy_n, frameo_n;// 产生时钟，周期为10nsinitial     forever #5ns clk <= !clk;// 产生复位信号  initial begin    #2ns rstn <= 1;    #10ns rstn <= 0;    #10ns rstn <= 1;  end//例化router为DUTrouter dut(             .reset_n(rstn),  .clock(clk),  .frame_n(intf.frame_n),  .valid_n(intf.valid_n),  .din(intf.din),  .dout(intf.dout),  .busy_n(intf.busy_n),  .valido_n(intf.valido_n),  .frameo_n(intf.frameo_n));rt_interface intf();//例化接口    assign intf.reset_n = rstn;    assign intf.clock = clk;    //例化stimulatorrt_stimulator stim(intf);//例化Monitorrt_monitor mon(intf);//例化generatorrt_generator gen();    initial begin:generate_data_proc//产生数据    rt_packet_t p;    gen.put_pkt('{0,3,'{8'h33,8'h77}});//调用genarator里面的put_pkt函数    gen.put_pkt('{0,5,'{8'h55,8'h66}});    gen.put_pkt('{3,6,'{8'h77,8'h88,8'h22}});    gen.put_pkt('{4,7,'{8'haa,8'hcc,8'h33}});endinitial begin:genarator_to_stimulator_proc//取出genarator中的数据给stimulator    rt_packet_t p;    forever begin        gen.get_pkt(p);        stim.put_pkt(p);    endendendmodule </code></pre><h2 id="5-3-仿真结果"><a href="#5-3-仿真结果" class="headerlink" title="5.3 仿真结果"></a>5.3 仿真结果</h2>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211161422827.png" width="350" height="500" title=" ">                    <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211161639835.png" width="500" height="500" title=" ">        <h1 id="6-初步TestBench概览"><a href="#6-初步TestBench概览" class="headerlink" title="6. 初步TestBench概览"></a>6. 初步TestBench概览</h1>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211171916069.png" width="600" height="360" title=" ">        ]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-构建generator&quot;&gt;&lt;a href=&quot;#1-构建generator&quot; class=&quot;headerlink&quot; title=&quot;1. 构建generator&quot;&gt;&lt;/a&gt;1. 构建generator&lt;/h1&gt;&lt;p&gt;stimulator只发送数据，构建genera</summary>
      
    
    
    
    <category term="数字IC" scheme="https://www.daipeihong.top/categories/%E6%95%B0%E5%AD%97IC/"/>
    
    
    <category term="数字前端" scheme="https://www.daipeihong.top/tags/%E6%95%B0%E5%AD%97%E5%89%8D%E7%AB%AF/"/>
    
    <category term="SystemVerilog验证" scheme="https://www.daipeihong.top/tags/SystemVerilog%E9%AA%8C%E8%AF%81/"/>
    
  </entry>
  
</feed>
