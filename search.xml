<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SystemVerilog课程笔记(十)</title>
      <link href="/2022/11/23/systemverilog-ke-cheng-bi-ji-shi/"/>
      <url>/2022/11/23/systemverilog-ke-cheng-bi-ji-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="1-从generator收到的数据按照chnl编号分发到16个mailbox里"><a href="#1-从generator收到的数据按照chnl编号分发到16个mailbox里" class="headerlink" title="1. 从generator收到的数据按照chnl编号分发到16个mailbox里"></a>1. 从generator收到的数据按照chnl编号分发到16个mailbox里</h1><h2 id="1-1-改进后的rt-tst-pkg-sv"><a href="#1-1-改进后的rt-tst-pkg-sv" class="headerlink" title="1.1 改进后的rt_tst_pkg.sv"></a>1.1 改进后的rt_tst_pkg.sv</h2><pre class=" language-systemverilog"><code class="language-systemverilog">package rt_test_pkg;class rt_packet;  rand bit [3:0] src;  rand bit [3:0] dst;  rand bit [7:0] data [];  constraint pkg_cstr{    soft data.size inside{[1:32]};    foreach(data[i])        soft data[i] == (src << 4) + i;    }  function new();  endfunction  function void set_members(bit [3:0]src, bit [3:0]dst, bit[7:0]data []);    this.src = src;    this.dst = dst;    this.data = data;  endfunction  function string sprint();//打印packet信息的函数    sprint = {sprint , $sformatf("src = %0d\n",src)};    sprint = {sprint , $sformatf("dst = %0d\n",dst)};    sprint = {sprint , $sformatf("data_length = %0d\n",data.size())};    foreach(data[i])        sprint = {sprint , $sformatf("data[%0d] = 'h%0x\n", i, data[i])};  endfunction  function bit compare(rt_packet p);//输入exp_pkt        if(dst == p.dst && data == p.data)            compare = 1;        else             compare = 0;  endfunctionendclass//********************************** stimulator **********************************//class rt_stimulator;    virtual rt_interface intf;//class里的接口不能用端口的方式描述，需要添加virtual关键字，在类里面用接口的指针//for debug purpose from waveform//定义检测状态的变量  typedef enum {DRV_RESET,DRV_IDLE,DRV_ADDR,DRV_PAD,DRV_DATA} drv_state_t;  drv_state_t dbg_state;    byte unsigned dbg_din_chnl0_data;   semaphore src_chnl_status[16];//16个chnl的钥匙  mailbox #(rt_packet) gen_pkts;  mailbox #(rt_packet) ch_pkts[16];//从generator收到的数据按照chnl编号分发到16个mailbox里      function new();  //pkts = new(1);//设定mailbox上限为1    foreach(src_chnl_status[i])        src_chnl_status[i] = new(1);        foreach (ch_pkts[i])            ch_pkts[i] = new(1);        endfunction//generator传送p给stimulatortask run();    fork        drive_reset(); //reset动作        distribute_packets();//分发数据        get_packet_and_drive(); //drive_chnl动作，发送数据    join_noneendtask//分发数据task distribute_packets();//从generator收到的数据按照chnl编号分发到16个mailbox里    rt_packet p;    forever begin        gen_pkts.get(p);//从stimulator中的mailbox中取出数据        ch_pkts[p.src].put(p);//将数据写入分发的对应chnl的mailbox中    endendtasktask drive_reset();//reset    forever begin        @(negedge intf.reset_n);        dbg_state <= DRV_RESET;        intf.din <= 0;        intf.frame_n <= '1;//等效16'hFFFF        intf.valid_n <= '1;    endendtask// 发送数据task get_packet_and_drive();    @(negedge intf.reset_n);    repeat (10)@(posedge intf.clock);    foreach(ch_pkts[i])begin    automatic int id = i;    automatic rt_packet p;        fork            forever begin            ch_pkts[id].get(p);//从对应chnl的mailbox中取出数据            drive_chnl(p);//drive数据            end        join_none    endendtasktask  drive_chnl(rt_packet p);  $display("@%0t:[DRV] src_chnl[%0d] & dest_chnl[%0d] data trans started with packet: \n%s",$time,p.src,p.dst,p.sprint());    // drive address phase 输入地址位阶段for(int i=0;i<4;i++)begin  //4 clock  @(posedge intf.clock);  dbg_state <=DRV_ADDR;  intf.din[p.src] <= p.dst[i];  intf.valid_n[p.src] <= $urandom_range(0,1);//valid_n在din的地址输入时间段可为任意值x  intf.frame_n[p.src] <= 1'b0;//frame_n需要为低end    // drive pad phase //隔离阶段  for (int i=0;i<5;i++)begin  //5 clock    @(posedge intf.clock);    dbg_state <=DRV_PAD;    intf.din[p.src] <= 1'b1;    intf.valid_n[p.src] <= 1'b1;//valid_n需为高电平    intf.frame_n[p.src] <= 1'b0; //frame_n需为低电平  end    // drive data phase 传输数据阶段  foreach(p.data[id])begin    for(int i=0;i<8;i++)begin     @(posedge intf.clock);      dbg_state <=DRV_DATA;      dbg_din_chnl0_data <= p.data[id];      intf.din[p.src] <= p.data[id][i];      intf.valid_n[p.src] <=1'b0;      intf.frame_n[p.src] <= (id == p.data.size()-1 && i == 7) ? 1'b1 : 1'b0;//packet最后一位输出数据时frameo_n为高    end  end// drive idle phase 闲置（没有数据传输）阶段  @(posedge intf.clock);  dbg_state <=DRV_IDLE;  dbg_din_chnl0_data <= 0;  intf.din[p.src] <= 1'b0;  intf.valid_n[p.src] <= 1'b1;  intf.frame_n[p.src] <= 1'b1;  $display("@%0t: [DRV]src_chnl[%0d],dest_chnl[%0d] data trans finished",$time,p.src,p.dst);endtaskendclass//********************************** generator **********************************//class rt_generator;//generator产生数据交给stimulator  mailbox #(rt_packet) pkts;//定义队列        function new();        pkts = new(1);//设定mailbox上限为1    endfunction      task put_pkt(input rt_packet p);    pkts.put(p);  endtask    task get_pkt(output rt_packet p);    pkts.get(p);  endtask  //generate a random packet  function void gen_pkt(int src = -1, int dst = -1);  endfunction    task run();        //TODO  endtask    endclass//********************************** monitor **********************************//class rt_monitor;virtual rt_interface intf;    rt_packet in_pkts[16][$];    rt_packet out_pkts[16][$];    task run();    fork        mon_chnls();    join_noneendtask    task mon_chnls;    foreach(in_pkts[i]) begin        automatic int chid = i;        fork        mon_chnl_in(chid);//每个输入端口均调用mon_chnl_in任务，监测数据输入        mon_chnl_out(chid);//每个输出端口均调用mon_chnl_out任务，监测数据输入        join_none    endendtask    task  mon_chnl_in (bit[3:0]id);//监测数据输入的任务    rt_packet pkt;//定义结构体变量    forever begin    //clear content for the same struct variable。清除pkt    pkt = new();    pkt.src = id;//第id个输入端口    //monitor specific channel-in data and put it into the queue    // monitor address phase    @(negedge intf.frame_n[id]);//监测frame_n下降沿(frame_n由时钟驱动)    for(int i=0; i<4; i++)begin        @(negedge intf.clock);//frame_n下降沿后监测4个clk negedge        pkt.dst[i]= intf.din[id];        end        $display ("@%0t: [MON] src_chn1[%0d] & dest_chn1[%0d] data trans started",$time,pkt.src,pkt.dst);    //pass pad phase 不考虑pad阶段是否满足协议要求    repeat(5) @(negedge intf.clock);    do begin        pkt.data = new [pkt.data.size + 1](pkt.data);//创建动态数组并复制pkt.data        for ( int i=0; i<8; i++) begin            @(negedge intf.clock); //在8个clk negedge监测8bit数据            pkt.data[pkt.data.size-1][i] = intf.din[id];        end    end while(!intf.frame_n[id]);    in_pkts[id].push_back(pkt);//将monitor拿到的数据放入in_pkts    $display("@%0t:[MON] CH_IN src_chnl[%0d] &dest_chnl[%0d ] finished with packet: \n%s",$time,pkt.src,pkt.dst,pkt.sprint());    endendtasktask  mon_chnl_out(bit[ 3:0]id);//监测数据输出的任务    rt_packet pkt;    forever begin        //clear content for the same struct variable        pkt = new();        pkt.dst = id;        @(negedge intf.frameo_n[id]);        $display( "@%0t: [MON] CH_OUT dest_chn1[%0d] data trans started",$time,pkt.dst);        do begin        pkt.data = new [ pkt.data.size + 1](pkt.data);        for(int i=0;i<8; i++) begin            @(negedge intf.clock iff !intf.valido_n[id]);//clock与valido_n信号同时为低            pkt.data[pkt.data.size-1][i]= intf.dout [id];        end    end while(!intf.frameo_n[id]);    // NOTE : src is from data format (user defined)    pkt.src = pkt.data[0][7:4];//高4位    out_pkts[id].push_back(pkt);    $display("@%0t: [MON] CH_OUT dest_chn1[%0d] data finished woth packet : \n %s",$time,pkt.dst,pkt.sprint());    //monitor specific channel-out data and put it into the queue    endendtaskendclass//********************************** checker **********************************//class rt_checker;    int unsigned compare_count;    int unsigned error_count;        function new();//赋初值，可有可无，整形变量默认初始值为0        compare_count = 0;        error_count = 0;    endfunction        rt_packet exp_out_pkts[16][$];    rt_monitor mon;        task run();    foreach(exp_out_pkts[i])begin        automatic int chid = i;        fork            do_routing(chid);            do_compare(chid);        join_none        end    endtask        task do_routing(bit[3:0] id);//将monitor中采样到的输入数据放入期望的输出端队列中        rt_packet pkt;        forever begin            wait(mon.in_pkts[id].size > 0);            pkt = mon.in_pkts[id].pop_front();//从monitor中拿到in_pkts队列数据放入pkt            exp_out_pkts[pkt.dst].push_back(pkt);//将pkt数据放入对应期望的dest_chnl            end    endtask         task do_compare(bit[3:0] id);//比较采集的实际输出与期望输出        rt_packet exp_pkt, act_pkt;        forever begin            wait(mon.out_pkts[id].size > 0 && exp_out_pkts[id].size > 0);//实际采样数据与期望数据都有值            act_pkt = mon.out_pkts[id].pop_front();//实际数据为monitor采样的输出数据            exp_pkt = exp_out_pkts[id].pop_front();//期望数据为monitor采样到的输入数据            if(act_pkt.compare(exp_pkt))begin//如果exp_pkt与act_pkt比较成功，返回1                $display("[CHK] data compare success with packet : \n%s",exp_pkt.sprint());            end            else begin                $display("[CHK] data compare failure with actual packet : \n%s \nexpected packet : \n%s", act_pkt.sprint(), exp_pkt.sprint());                error_count++;            end                compare_count++;        end    endtask         function void report(string name);        $display("TOTAL COMPARING %0d times",compare_count);        if(!error_count && check_data_buffer())//判断无误且二者有数据            $display("TEST [%s] PASSED!",name);        else begin            $display("TEST [%s]FAILED!",name);            $display("TOTAL ERROR %0d times", error_count);        end    endfunction        function bit check_data_buffer();        check_data_buffer = 1;        foreach(exp_out_pkts[id])begin             if(exp_out_pkts[id].size != 0)begin//exp_out_pkts必须有数据                check_data_buffer = 0;                $display("exp_out_pkts[%0d] buffer size is not 0(still with %0d data)",id,exp_out_pkts[id].size);            end            if(mon.out_pkts[id].size != 0)begin//mon.out_pkts必须有数据                check_data_buffer = 0;                $display("mon.out_pkts[%0d] buffer size is not 0(still with %0d data)",id,mon.out_pkts[id].size);            end        end    endfunction    endclass//********************************** Optional tests **********************************//class rt_env;//rt_env包含各个组件    rt_stimulator stim;    rt_monitor mon;    rt_generator gen;    rt_checker chk;            function new(virtual rt_interface intf);        //build stage,例化        stim = new();        gen = new();        mon = new();        chk = new();        //connect stage，连接        stim.intf = intf;        mon.intf = intf;        chk.mon = mon;//check拿monitor句柄，即拿monitor中in_pkts与out_pkts队列        stim.gen_pkts = gen.pkts;//将generaor的句柄赋值给stimlutor，数据从gen传到stim    endfunction         task run();        rt_packet p;        //run stage，run        fork            stim.run();//class里面的函数不会自动调用，需要手动调用            gen.run();            mon.run();            chk.run();        join_none    endtask        function void report(string name);        chk.report(name);    endfunction    endclassclass rt_base_test;//rt_base_test包含rt_env，rt_env包含各个组件    rt_env env;    bit gen_trans_done = 0;//表示数据传输未开始    int unsigned test_drain_time_us = 200;//数据传输完后等待报告的时间    string name;        function new(virtual rt_interface intf,string name = "rt_base_test");        env = new(intf);        this.name = name;    endfunction        virtual task run();    $display("TEST %s started",name);        fork            env.run();            report();//调用report        join_none    endtask        task report();        wait(gen_trans_done == 1);        #(test_drain_time_us * 1us);        env.report(name);//调用env里的chk.report()进行report        $finish();//terminates the current test    endtask  function void set_trans_done(bit done = 1);//将set_trans_done信号置为1，表示数据传输已完成        gen_trans_done = done;    endfunctionendclass    class rt_single_ch_test extends rt_base_test;//单个通道测试        rand bit signed [4:0] src;        rand bit signed [4:0] dst;        rand int unsigned pkt_count =10;        constraint test_cstr {            soft pkt_count inside {[20:30]};            src inside {[0 : 15]};            dst inside {[0 : 15]};            }        function new(virtual rt_interface intf,string name = "rt_single_ch_test");            super.new(intf,name);        endfunction                    task run();            rt_packet p;            super.run();//调用父类的run，即执行env.run()，进行组件的例化等操作            this.randomize(); //randmoize self to get constrained data            for ( int cnt=0; cnt < pkt_count; cnt++) begin//随机10次                p = new( );                p.randomize() with {src == local::src; dst == local::dst; };                env.gen.put_pkt(p);            end            set_trans_done();        endtask            endclass    class rt_two_ch_test extends rt_base_test;        rand bit signed [4:0] src[2];        rand bit signed [4:0] dst[2];        rand int unsigned pkt_count =10;        constraint test_cstr {            soft pkt_count inside {[5:10]};            foreach (src[i]) src[i] inside {[0 : 15]};            foreach (src[i]) dst[i] inside {[0 : 15]};            unique {src};//随机过程过程中每个src、dst不一样            unique {dst};            }        function new(virtual rt_interface intf,string name = "rt_two_ch_test");            super.new(intf,name);        endfunction                    task run();            rt_packet p;            super.run();//调用父类的run，即执行env.run()，进行组件的例化等操作            this.randomize(); //randmoize self to get constrained data            for ( int cnt=0; cnt < pkt_count; cnt++) begin//随机10次                foreach (src[i]) begin                p = new( );                p.randomize() with {src == local::src[i]; dst == local::dst[i]; };                env.gen.put_pkt(p);                end            end            set_trans_done();        endtask    endclass        class rt_two_ch_same_chout_test extends rt_two_ch_test;            function new(virtual rt_interface intf,string name = "rt_two_ch_same_chout_test");                super.new(intf,name);            endfunction        endclass    class rt_multi_ch_test extends rt_base_test;//多通道测试        function new(virtual rt_interface intf,string name = "rt_multi_ch_test");            super.new(intf,name);        endfunction                task run();            rt_packet p;            super.run();            p = new();            p.set_members(0,3,'{8'h33,8'h77});            env.gen.put_pkt(p);            p = new();//每次put_pkt都需要new一下            p.set_members(0,5,'{8'h55,8'h66});            env.gen.put_pkt(p);            p = new();            p.set_members(3,6,'{8'h77,8'h88,8'h22});            env.gen.put_pkt(p);            p = new();            p.set_members(4,7,'{8'haa,8'hcc,8'h33});            env.gen.put_pkt(p);            set_trans_done();        endtask    endclass        class rt_full_ch_test extends rt_multi_ch_test;            function new(virtual rt_interface intf,string name = "rt_full_ch_test");                super.new(intf,name);            endfunction        endclassendpackage</code></pre><h2 id="1-2-改进后的lab10tb-sv"><a href="#1-2-改进后的lab10tb-sv" class="headerlink" title="1.2 改进后的lab10tb.sv"></a>1.2 改进后的lab10tb.sv</h2><pre class=" language-systemverilog"><code class="language-systemverilog">//********************************** rt_interface **********************************//interface rt_interface();    logic clock;    logic reset_n;    logic [15:0] din;    logic [15:0] frame_n;    logic [15:0] valid_n;    logic [15:0] dout;    logic [15:0] valido_n;    logic [15:0] busy_n;    logic [15:0] frameo_n;endinterface//********************************** tb **********************************//module tb;  import rt_test_pkg ::*;        bit clk,rstn;    logic [15:0] din, frame_n, valid_n;    logic [15:0] dout, valido_n, busy_n, frameo_n;// 产生时钟，周期为10nsinitial     forever #5ns clk <= !clk;// 产生复位信号  initial begin    #2ns rstn <= 1;    #10ns rstn <= 0;    #10ns rstn <= 1;  end//例化router为DUTrouter dut(             .reset_n(rstn),  .clock(clk),  .frame_n(intf.frame_n),  .valid_n(intf.valid_n),  .din(intf.din),  .dout(intf.dout),  .busy_n(intf.busy_n),  .valido_n(intf.valido_n),  .frameo_n(intf.frameo_n));rt_interface intf();//例化接口    assign intf.reset_n = rstn;    assign intf.clock = clk;    rt_single_ch_test  single_ch_test;    rt_two_ch_test   two_ch_test;    rt_multi_ch_test   multi_ch_test;        rt_base_test tests[string];//父类记得添加virtual，否则存放的是父类句柄，执行父类的run        initial begin : Select_the_test        string name;        single_ch_test = new(intf);        two_ch_test  = new(intf);        multi_ch_test  = new(intf);        tests["rt_single_ch_test"] = single_ch_test;        tests["rt_two_ch_test"   ] = two_ch_test;        tests["rt_multi_ch_test" ] = multi_ch_test ;        if($value$plusargs("TESTNAME=%s",name))begin//$value$plusargs作用：运行仿真时输入参数            if(tests.exists(name))        tests[name].run();//调用对应test进行run            else                $fatal("[ERRTEST],test name %s is invalid,please specity a valid name!0",name);            end  end    endmodule </code></pre><h2 id="1-3-仿真结果"><a href="#1-3-仿真结果" class="headerlink" title="1.3 仿真结果"></a>1.3 仿真结果</h2><p>执行two_ch_test命令：</p><blockquote><p>make rung TESTNAME=rt_two_ch_test</p></blockquote><p><span style="background:rgba(240, 200, 0, 0.2)">结果没有交替发送的情况</span></p><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211231510365.png" width="100%" height="100%"></div><h1 id="2-完善two-ch-same-chout-test、full-ch-test"><a href="#2-完善two-ch-same-chout-test、full-ch-test" class="headerlink" title="2.  完善two_ch_same_chout_test、full_ch_test"></a>2.  完善two_ch_same_chout_test、full_ch_test</h1><h2 id="2-1-改进后的rt-pkg-sv"><a href="#2-1-改进后的rt-pkg-sv" class="headerlink" title="2.1 改进后的rt_pkg.sv"></a>2.1 改进后的rt_pkg.sv</h2><pre class=" language-systemverilog"><code class="language-systemverilog">package rt_test_pkg;class rt_packet;  rand bit [3:0] src;  rand bit [3:0] dst;  rand bit [7:0] data [];  constraint pkg_cstr{    soft data.size inside{[1:32]};    foreach(data[i])        soft data[i] == (src << 4) + i;    }  function new();  endfunction  function void set_members(bit [3:0]src, bit [3:0]dst, bit[7:0]data []);    this.src = src;    this.dst = dst;    this.data = data;  endfunction  function string sprint();//打印packet信息的函数    sprint = {sprint , $sformatf("src = %0d\n",src)};    sprint = {sprint , $sformatf("dst = %0d\n",dst)};    sprint = {sprint , $sformatf("data_length = %0d\n",data.size())};    foreach(data[i])        sprint = {sprint , $sformatf("data[%0d] = 'h%0x\n", i, data[i])};  endfunction  function bit compare(rt_packet p);//输入exp_pkt        if(dst == p.dst && data == p.data)            compare = 1;        else             compare = 0;  endfunctionendclass//********************************** stimulator **********************************//class rt_stimulator;    virtual rt_interface intf;//class里的接口不能用端口的方式描述，需要添加virtual关键字，在类里面用接口的指针//for debug purpose from waveform//定义检测状态的变量  typedef enum {DRV_RESET,DRV_IDLE,DRV_ADDR,DRV_PAD,DRV_DATA} drv_state_t;  drv_state_t dbg_state;    byte unsigned dbg_din_chnl0_data;   semaphore src_chnl_status[16];//16个chnl的钥匙  mailbox #(rt_packet) gen_pkts;  mailbox #(rt_packet) ch_pkts[16];//从generator收到的数据按照chnl编号分发到16个mailbox里      function new();  //pkts = new(1);//设定mailbox上限为1    foreach(src_chnl_status[i])        src_chnl_status[i] = new(1);        foreach (ch_pkts[i])            ch_pkts[i] = new(1);  endfunction//generator传送p给stimulatortask run();    fork        drive_reset(); //reset动作        distribute_packets();//分发数据        get_packet_and_drive(); //drive_chnl动作，发送数据    join_noneendtask//分发数据task distribute_packets();//从generator收到的数据按照chnl编号分发到16个mailbox里    rt_packet p;    forever begin        gen_pkts.get(p);//从stimulator中的mailbox中取出数据        ch_pkts[p.src].put(p);//将数据写入分发的对应chnl的mailbox中    endendtasktask drive_reset();//reset    forever begin        @(negedge intf.reset_n);        dbg_state <= DRV_RESET;        intf.din <= 0;        intf.frame_n <= '1;//等效16'hFFFF        intf.valid_n <= '1;    endendtask// 发送数据task get_packet_and_drive();    @(negedge intf.reset_n);    repeat (10)@(posedge intf.clock);    foreach(ch_pkts[i])begin    automatic int id = i;    automatic rt_packet p;        fork            forever begin            ch_pkts[id].get(p);//从对应chnl的mailbox中取出数据            drive_chnl(p);//drive数据            end        join_none    endendtasktask  drive_chnl(rt_packet p);  $display("@%0t:[DRV] src_chnl[%0d] & dest_chnl[%0d] data trans started with packet: \n%s",$time,p.src,p.dst,p.sprint());    // drive address phase 输入地址位阶段for(int i=0;i<4;i++)begin  //4 clock  @(posedge intf.clock);  dbg_state <=DRV_ADDR;  intf.din[p.src] <= p.dst[i];  intf.valid_n[p.src] <= $urandom_range(0,1);//valid_n在din的地址输入时间段可为任意值x  intf.frame_n[p.src] <= 1'b0;//frame_n需要为低end    // drive pad phase //隔离阶段  for (int i=0;i<5;i++)begin  //5 clock    @(posedge intf.clock);    dbg_state <=DRV_PAD;    intf.din[p.src] <= 1'b1;    intf.valid_n[p.src] <= 1'b1;//valid_n需为高电平    intf.frame_n[p.src] <= 1'b0; //frame_n需为低电平  end    // drive data phase 传输数据阶段  foreach(p.data[id])begin    for(int i=0;i<8;i++)begin     @(posedge intf.clock);      dbg_state <=DRV_DATA;      dbg_din_chnl0_data <= p.data[id];      intf.din[p.src] <= p.data[id][i];      intf.valid_n[p.src] <=1'b0;      intf.frame_n[p.src] <= (id == p.data.size()-1 && i == 7) ? 1'b1 : 1'b0;//packet最后一位输出数据时frameo_n为高    end  end// drive idle phase 闲置（没有数据传输）阶段  @(posedge intf.clock);  dbg_state <=DRV_IDLE;  dbg_din_chnl0_data <= 0;  intf.din[p.src] <= 1'b0;  intf.valid_n[p.src] <= 1'b1;  intf.frame_n[p.src] <= 1'b1;  $display("@%0t: [DRV]src_chnl[%0d],dest_chnl[%0d] data trans finished",$time,p.src,p.dst);endtaskendclass//********************************** generator **********************************//class rt_generator;//generator产生数据交给stimulator  mailbox #(rt_packet) pkts;//定义队列        function new();        pkts = new(1);//设定mailbox上限为1    endfunction      task put_pkt(input rt_packet p);    pkts.put(p);  endtask    task get_pkt(output rt_packet p);    pkts.get(p);  endtask  //generate a random packet  function void gen_pkt(int src = -1, int dst = -1);  endfunction    task run();        //TODO  endtask    endclass//********************************** monitor **********************************//class rt_monitor;virtual rt_interface intf;    rt_packet in_pkts[16][$];    rt_packet out_pkts[16][$];    task run();    fork        mon_chnls();    join_noneendtask    task mon_chnls;    foreach(in_pkts[i]) begin        automatic int chid = i;        fork        mon_chnl_in(chid);//每个输入端口均调用mon_chnl_in任务，监测数据输入        mon_chnl_out(chid);//每个输出端口均调用mon_chnl_out任务，监测数据输入        join_none    endendtask    task  mon_chnl_in (bit[3:0]id);//监测数据输入的任务    rt_packet pkt;//定义结构体变量    forever begin    //clear content for the same struct variable。清除pkt    pkt = new();    pkt.src = id;//第id个输入端口    //monitor specific channel-in data and put it into the queue    // monitor address phase    @(negedge intf.frame_n[id]);//监测frame_n下降沿(frame_n由时钟驱动)    for(int i=0; i<4; i++)begin        @(negedge intf.clock);//frame_n下降沿后监测4个clk negedge        pkt.dst[i]= intf.din[id];        end        $display ("@%0t: [MON] src_chn1[%0d] & dest_chn1[%0d] data trans started",$time,pkt.src,pkt.dst);    //pass pad phase 不考虑pad阶段是否满足协议要求    repeat(5) @(negedge intf.clock);    do begin        pkt.data = new [pkt.data.size + 1](pkt.data);//创建动态数组并复制pkt.data        for ( int i=0; i<8; i++) begin            @(negedge intf.clock); //在8个clk negedge监测8bit数据            pkt.data[pkt.data.size-1][i] = intf.din[id];        end    end while(!intf.frame_n[id]);    in_pkts[id].push_back(pkt);//将monitor拿到的数据放入in_pkts    $display("@%0t:[MON] CH_IN src_chnl[%0d] &dest_chnl[%0d ] finished with packet: \n%s",$time,pkt.src,pkt.dst,pkt.sprint());    endendtasktask  mon_chnl_out(bit[ 3:0]id);//监测数据输出的任务    rt_packet pkt;    forever begin        //clear content for the same struct variable        pkt = new();        pkt.dst = id;        @(negedge intf.frameo_n[id]);        $display( "@%0t: [MON] CH_OUT dest_chn1[%0d] data trans started",$time,pkt.dst);        do begin        pkt.data = new [ pkt.data.size + 1](pkt.data);        for(int i=0;i<8; i++) begin            @(negedge intf.clock iff !intf.valido_n[id]);//clock与valido_n信号同时为低            pkt.data[pkt.data.size-1][i]= intf.dout [id];        end    end while(!intf.frameo_n[id]);    // NOTE : src is from data format (user defined)    pkt.src = pkt.data[0][7:4];//高4位    out_pkts[id].push_back(pkt);    $display("@%0t: [MON] CH_OUT dest_chn1[%0d] data finished woth packet : \n %s",$time,pkt.dst,pkt.sprint());    //monitor specific channel-out data and put it into the queue    endendtaskendclass//********************************** checker **********************************//class rt_checker;    int unsigned compare_count;    int unsigned error_count;        function new();//赋初值，可有可无，整形变量默认初始值为0        compare_count = 0;        error_count = 0;    endfunction        rt_packet exp_out_pkts[16][$];    rt_monitor mon;        task run();    foreach(exp_out_pkts[i])begin        automatic int chid = i;        fork            do_routing(chid);            do_compare(chid);        join_none        end    endtask        task do_routing(bit[3:0] id);//将monitor中采样到的输入数据放入期望的输出端队列中        rt_packet pkt;        forever begin            wait(mon.in_pkts[id].size > 0);            pkt = mon.in_pkts[id].pop_front();//从monitor中拿到in_pkts队列数据放入pkt            exp_out_pkts[pkt.dst].push_back(pkt);//将pkt数据放入对应期望的dest_chnl            end    endtask         task do_compare(bit[3:0] id);//比较采集的实际输出与期望输出        rt_packet exp_pkt, act_pkt;        forever begin            wait(mon.out_pkts[id].size > 0 && exp_out_pkts[id].size > 0);//实际采样数据与期望数据都有值            act_pkt = mon.out_pkts[id].pop_front();//实际数据为monitor采样的输出数据            exp_pkt = exp_out_pkts[id].pop_front();//期望数据为monitor采样到的输入数据            if(act_pkt.compare(exp_pkt))begin//如果exp_pkt与act_pkt比较成功，返回1                $display("[CHK] data compare success with packet : \n%s",exp_pkt.sprint());            end            else begin                $display("[CHK] data compare failure with actual packet : \n%s \nexpected packet : \n%s", act_pkt.sprint(), exp_pkt.sprint());                error_count++;            end                compare_count++;        end    endtask         function void report(string name);        $display("TOTAL COMPARING %0d times",compare_count);        if(!error_count && check_data_buffer())//判断无误且二者有数据            $display("TEST [%s] PASSED!",name);        else begin            $display("TEST [%s]FAILED!",name);            $display("TOTAL ERROR %0d times", error_count);        end    endfunction        function bit check_data_buffer();        check_data_buffer = 1;        foreach(exp_out_pkts[id])begin             if(exp_out_pkts[id].size != 0)begin//exp_out_pkts必须有数据                check_data_buffer = 0;                $display("exp_out_pkts[%0d] buffer size is not 0(still with %0d data)",id,exp_out_pkts[id].size);            end            if(mon.out_pkts[id].size != 0)begin//mon.out_pkts必须有数据                check_data_buffer = 0;                $display("mon.out_pkts[%0d] buffer size is not 0(still with %0d data)",id,mon.out_pkts[id].size);            end        end    endfunction    endclass//********************************** Optional tests **********************************//class rt_env;//rt_env包含各个组件    rt_stimulator stim;    rt_monitor mon;    rt_generator gen;    rt_checker chk;            function new(virtual rt_interface intf);        //build stage,例化        stim = new();        gen = new();        mon = new();        chk = new();        //connect stage，连接        stim.intf = intf;        mon.intf = intf;        chk.mon = mon;//check拿monitor句柄，即拿monitor中in_pkts与out_pkts队列        stim.gen_pkts = gen.pkts;//将generaor的句柄赋值给stimlutor，数据从gen传到stim    endfunction         task run();        rt_packet p;        //run stage，run        fork            stim.run();//class里面的函数不会自动调用，需要手动调用            gen.run();            mon.run();            chk.run();        join_none    endtask        function void report(string name);        chk.report(name);    endfunction    endclassclass rt_base_test;//rt_base_test包含rt_env，rt_env包含各个组件    rt_env env;    bit gen_trans_done = 0;//表示数据传输未开始    int unsigned test_drain_time_us = 200;//数据传输完后等待报告的时间    string name;        function new(virtual rt_interface intf,string name = "rt_base_test");        env = new(intf);        this.name = name;    endfunction        virtual task run();    $display("TEST %s started",name);        fork            env.run();            report();//调用report        join_none    endtask        task report();        wait(gen_trans_done == 1);        #(test_drain_time_us * 1us);        env.report(name);//调用env里的chk.report()进行report        $finish();//terminates the current test    endtask  function void set_trans_done(bit done = 1);//将set_trans_done信号置为1，表示数据传输已完成        gen_trans_done = done;    endfunctionendclass    class rt_single_ch_test extends rt_base_test;//单个通道测试        rand bit signed [4:0] src;        rand bit signed [4:0] dst;        rand int unsigned pkt_count =10;        constraint test_cstr {            soft pkt_count inside {[20:30]};            src inside {[0 : 15]};            dst inside {[0 : 15]};            }        function new(virtual rt_interface intf,string name = "rt_single_ch_test");            super.new(intf,name);        endfunction                    task run();            rt_packet p;            super.run();//调用父类的run，即执行env.run()，进行组件的例化等操作            this.randomize(); //randmoize self to get constrained data            for ( int cnt=0; cnt < pkt_count; cnt++) begin//随机10次                p = new( );                p.randomize() with {src == local::src; dst == local::dst; };                env.gen.put_pkt(p);            end            set_trans_done();        endtask    endclass    class rt_two_ch_test extends rt_base_test;        rand bit signed [3:0] src[2];        rand bit signed [3:0] dst[2];        rand int unsigned pkt_count =10;        constraint test_cstr {            soft pkt_count inside {[5:10]};            foreach (src[i]) src[i] inside {[0 : 15]};            foreach (src[i]) dst[i] inside {[0 : 15]};            unique {src};//随机过程过程中每个src、dst不一样            unique {dst};            }        function new(virtual rt_interface intf,string name = "rt_two_ch_test");            super.new(intf,name);        endfunction                    task run();            rt_packet p;            super.run();//调用父类的run，即执行env.run()，进行组件的例化等操作            this.randomize(); //randmoize self to get constrained data            for ( int cnt=0; cnt < pkt_count; cnt++) begin//随机10次                foreach (src[i]) begin                p = new( );                p.randomize() with {src == local::src[i]; dst == local::dst[i]; };                env.gen.put_pkt(p);                end            end            set_trans_done();        endtask    endclass        class rt_two_ch_same_chout_test extends rt_two_ch_test;//子类可以继承父类的run，此处不需要再添加，只需添加约束即可            rand bit [3:0]same_dst;            constraint two_ch_same_chout_cstr{            foreach(dst[i]) dst[i] == same_dst;//保证dst_chnl相同            same_dst inside {[0:15]};            }            function new(virtual rt_interface intf,string name = "rt_two_ch_same_chout_test");                super.new(intf,name);            endfunction        endclass    class rt_multi_ch_test extends rt_base_test;//多通道测试        function new(virtual rt_interface intf,string name = "rt_multi_ch_test");            super.new(intf,name);        endfunction                task run();            rt_packet p;            super.run();            p = new();            p.set_members(0,3,'{8'h33,8'h77});            env.gen.put_pkt(p);            p = new();//每次put_pkt都需要new一下            p.set_members(0,5,'{8'h55,8'h66});            env.gen.put_pkt(p);            p = new();            p.set_members(3,6,'{8'h77,8'h88,8'h22});            env.gen.put_pkt(p);            p = new();            p.set_members(4,7,'{8'haa,8'hcc,8'h33});            env.gen.put_pkt(p);            set_trans_done();        endtask    endclass        class rt_full_ch_test extends rt_multi_ch_test;            function new(virtual rt_interface intf,string name = "rt_full_ch_test");                super.new(intf,name);            endfunction        endclassendpackage</code></pre><h2 id="2-2-改进后的lab10tb-sv"><a href="#2-2-改进后的lab10tb-sv" class="headerlink" title="2.2 改进后的lab10tb.sv"></a>2.2 改进后的lab10tb.sv</h2><pre class=" language-systemveirlog"><code class="language-systemveirlog">//********************************** rt_interface **********************************//interface rt_interface();    logic clock;    logic reset_n;    logic [15:0] din;    logic [15:0] frame_n;    logic [15:0] valid_n;    logic [15:0] dout;    logic [15:0] valido_n;    logic [15:0] busy_n;    logic [15:0] frameo_n;endinterface//********************************** tb **********************************//module tb;  import rt_test_pkg ::*;        bit clk,rstn;    logic [15:0] din, frame_n, valid_n;    logic [15:0] dout, valido_n, busy_n, frameo_n;// 产生时钟，周期为10nsinitial     forever #5ns clk <= !clk;// 产生复位信号  initial begin    #2ns rstn <= 1;    #10ns rstn <= 0;    #10ns rstn <= 1;  end//例化router为DUTrouter dut(             .reset_n(rstn),  .clock(clk),  .frame_n(intf.frame_n),  .valid_n(intf.valid_n),  .din(intf.din),  .dout(intf.dout),  .busy_n(intf.busy_n),  .valido_n(intf.valido_n),  .frameo_n(intf.frameo_n));rt_interface intf();//例化接口    assign intf.reset_n = rstn;    assign intf.clock = clk;    rt_single_ch_test  single_ch_test;    rt_two_ch_test   two_ch_test;    rt_multi_ch_test   multi_ch_test;    rt_two_ch_same_chout_test two_ch_same_chout_test;    rt_full_ch_test full_ch_test;        rt_base_test tests[string];//父类记得添加virtual，否则存放的是父类句柄，执行父类的run        initial begin : Select_the_test        string name;        single_ch_test = new(intf);        two_ch_test  = new(intf);        multi_ch_test  = new(intf);        two_ch_same_chout_test  = new(intf);        full_ch_test  = new(intf);                tests["rt_single_ch_test"] = single_ch_test;        tests["rt_two_ch_test"   ] = two_ch_test;        tests["rt_multi_ch_test" ] = multi_ch_test ;        tests["rt_two_ch_same_chout_test"] = two_ch_same_chout_test;        tests["rt_full_ch_test "] = full_ch_test;                if($value$plusargs("TESTNAME=%s",name))begin//$value$plusargs作用：运行仿真时输入参数            if(tests.exists(name))        tests[name].run();//调用对应test进行run            else                $fatal("[ERRTEST],test name %s is invalid,please specity a valid name!0",name);            end  end    endmodule </code></pre><h2 id="2-3-仿真结果"><a href="#2-3-仿真结果" class="headerlink" title="2.3 仿真结果"></a>2.3 仿真结果</h2><p>进行相同dst_chnl通道测试，执行命令：</p><blockquote><p>make rung TESTNAME=rt_two_ch_same_chout_test &amp;</p></blockquote><p>randmize失败（所有src、dst均为0），父类与子类的约束冲突</p><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211231541927.png" width="80%" height="80%"></div><h2 id="2-4-解决方法"><a href="#2-4-解决方法" class="headerlink" title="2.4 解决方法"></a>2.4 解决方法</h2><p>关掉父类约束，部分代码如下：</p><pre class=" language-systemverilog"><code class="language-systemverilog">    ......    class rt_two_ch_test extends rt_base_test;        rand bit signed [3:0] src[2];        rand bit signed [3:0] dst[2];        rand int unsigned pkt_count =10;        constraint test_cstr {            soft pkt_count inside {[5:10]};            foreach (src[i]) src[i] inside {[0 : 15]};            foreach (src[i]) dst[i] inside {[0 : 15]};            unique {src};//随机过程过程中每个src、dst不一样            unique {dst};            }        function new(virtual rt_interface intf,string name = "rt_two_ch_test");            super.new(intf,name);        endfunction                    task run();            rt_packet p;            super.run();//调用父类的run，即执行env.run()，进行组件的例化等操作            this.randomize(); //randmoize self to get constrained data            for ( int cnt=0; cnt < pkt_count; cnt++) begin//随机10次                foreach (src[i]) begin                p = new( );                p.randomize() with {src == local::src[i]; dst == local::dst[i]; };                env.gen.put_pkt(p);                end            end            set_trans_done();        endtask    endclass        class rt_two_ch_same_chout_test extends rt_two_ch_test;//子类可以继承父类的run，此处不需要再添加，只需添加约束即可            rand bit [3:0]same_dst;            constraint two_ch_same_chout_cstr{            foreach(dst[i]) dst[i] == same_dst;//保证dst_chnl相同            same_dst inside {[0:15]};            soft pkt_count inside {[5:10]};            unique {src};//随机过程过程中每个src不一样            }            function new(virtual rt_interface intf,string name = "rt_two_ch_same_chout_test");                super.new(intf,name);                super.test_cstr.constraint_mode (0);//关掉父类约束            endfunction        endclas    ......</code></pre><h2 id="2-5-仿真结果"><a href="#2-5-仿真结果" class="headerlink" title="2.5 仿真结果"></a>2.5 仿真结果</h2><p>进行相同dst_chnl通道测试，执行命令：</p><blockquote><p>make rung TESTNAME=rt_two_ch_same_chout_test &amp;</p></blockquote><blockquote><p>TOTAL COMPARING 5 times<br>TEST [rt_two_ch_same_chout_test]FAILED!<br>TOTAL ERROR 5 times<br>$finish called from file “rt_test_pkg.sv”, line 370.<br>$finish at simulation time            210765000<br>Simulation complete, time is 210765000 ps.</p></blockquote><p>可以实现约束（12和3通道同时发往0通道），但是checker会比较错误，因为DUT不支持同时像dst chnl发送数据</p><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211231617389.png" width="100%" height="100%"></div><h1 id="3-完善各test父类与子类的关系"><a href="#3-完善各test父类与子类的关系" class="headerlink" title="3. 完善各test父类与子类的关系"></a>3. 完善各test父类与子类的关系</h1><h2 id="3-1-各test父类子类结构图"><a href="#3-1-各test父类子类结构图" class="headerlink" title="3.1 各test父类子类结构图"></a>3.1 各test父类子类结构图</h2><div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211232222901.png " width="60%" height="60%"></div><h2 id="3-2-改进后的rt-test-pkg-sv"><a href="#3-2-改进后的rt-test-pkg-sv" class="headerlink" title="3.2 改进后的rt_test_pkg.sv"></a>3.2 改进后的rt_test_pkg.sv</h2><pre class=" language-systemverilog"><code class="language-systemverilog">package rt_test_pkg;class rt_packet;  rand bit [3:0] src;  rand bit [3:0] dst;  rand bit [7:0] data [];  constraint pkg_cstr{    soft data.size inside{[1:32]};    foreach(data[i])        soft data[i] == (src << 4) + i;    }  function new();  endfunction  function void set_members(bit [3:0]src, bit [3:0]dst, bit[7:0]data []);    this.src = src;    this.dst = dst;    this.data = data;  endfunction  function string sprint();//打印packet信息的函数    sprint = {sprint , $sformatf("src = %0d\n",src)};    sprint = {sprint , $sformatf("dst = %0d\n",dst)};    sprint = {sprint , $sformatf("data_length = %0d\n",data.size())};    foreach(data[i])        sprint = {sprint , $sformatf("data[%0d] = 'h%0x\n", i, data[i])};  endfunction  function bit compare(rt_packet p);//输入exp_pkt        if(dst == p.dst && data == p.data)            compare = 1;        else             compare = 0;  endfunctionendclass//********************************** stimulator **********************************//class rt_stimulator;    virtual rt_interface intf;//class里的接口不能用端口的方式描述，需要添加virtual关键字，在类里面用接口的指针//for debug purpose from waveform//定义检测状态的变量  typedef enum {DRV_RESET,DRV_IDLE,DRV_ADDR,DRV_PAD,DRV_DATA} drv_state_t;  drv_state_t dbg_state;    byte unsigned dbg_din_chnl0_data;   semaphore src_chnl_status[16];//16个chnl的钥匙  mailbox #(rt_packet) gen_pkts;  mailbox #(rt_packet) ch_pkts[16];//从generator收到的数据按照chnl编号分发到16个mailbox里      function new();  //pkts = new(1);//设定mailbox上限为1    foreach(src_chnl_status[i])        src_chnl_status[i] = new(1);        foreach (ch_pkts[i])            ch_pkts[i] = new(1);  endfunction//generator传送p给stimulatortask run();    fork        drive_reset(); //reset动作        distribute_packets();//分发数据        get_packet_and_drive(); //drive_chnl动作，发送数据    join_noneendtask//分发数据task distribute_packets();//从generator收到的数据按照chnl编号分发到16个mailbox里    rt_packet p;    forever begin        gen_pkts.get(p);//从stimulator中的mailbox中取出数据        ch_pkts[p.src].put(p);//将数据写入分发的对应chnl的mailbox中    endendtasktask drive_reset();//reset    forever begin        @(negedge intf.reset_n);        dbg_state <= DRV_RESET;        intf.din <= 0;        intf.frame_n <= '1;//等效16'hFFFF        intf.valid_n <= '1;    endendtask// 发送数据task get_packet_and_drive();    @(negedge intf.reset_n);    repeat (10)@(posedge intf.clock);    foreach(ch_pkts[i])begin    automatic int id = i;    automatic rt_packet p;        fork            forever begin            ch_pkts[id].get(p);//从对应chnl的mailbox中取出数据            drive_chnl(p);//drive数据            end        join_none    endendtasktask  drive_chnl(rt_packet p);  $display("@%0t:[DRV] src_chnl[%0d] & dest_chnl[%0d] data trans started with packet: \n%s",$time,p.src,p.dst,p.sprint());    // drive address phase 输入地址位阶段for(int i=0;i<4;i++)begin  //4 clock  @(posedge intf.clock);  dbg_state <=DRV_ADDR;  intf.din[p.src] <= p.dst[i];  intf.valid_n[p.src] <= $urandom_range(0,1);//valid_n在din的地址输入时间段可为任意值x  intf.frame_n[p.src] <= 1'b0;//frame_n需要为低end    // drive pad phase //隔离阶段  for (int i=0;i<5;i++)begin  //5 clock    @(posedge intf.clock);    dbg_state <=DRV_PAD;    intf.din[p.src] <= 1'b1;    intf.valid_n[p.src] <= 1'b1;//valid_n需为高电平    intf.frame_n[p.src] <= 1'b0; //frame_n需为低电平  end    // drive data phase 传输数据阶段  foreach(p.data[id])begin    for(int i=0;i<8;i++)begin     @(posedge intf.clock);      dbg_state <=DRV_DATA;      dbg_din_chnl0_data <= p.data[id];      intf.din[p.src] <= p.data[id][i];      intf.valid_n[p.src] <=1'b0;      intf.frame_n[p.src] <= (id == p.data.size()-1 && i == 7) ? 1'b1 : 1'b0;//packet最后一位输出数据时frameo_n为高    end  end// drive idle phase 闲置（没有数据传输）阶段  @(posedge intf.clock);  dbg_state <=DRV_IDLE;  dbg_din_chnl0_data <= 0;  intf.din[p.src] <= 1'b0;  intf.valid_n[p.src] <= 1'b1;  intf.frame_n[p.src] <= 1'b1;  $display("@%0t: [DRV]src_chnl[%0d],dest_chnl[%0d] data trans finished",$time,p.src,p.dst);endtaskendclass//********************************** generator **********************************//class rt_generator;//generator产生数据交给stimulator  mailbox #(rt_packet) pkts;//定义队列        function new();        pkts = new(1);//设定mailbox上限为1    endfunction      task put_pkt(input rt_packet p);    pkts.put(p);  endtask    task get_pkt(output rt_packet p);    pkts.get(p);  endtask  //generate a random packet  function void gen_pkt(int src = -1, int dst = -1);  endfunction    task run();        //TODO  endtask    endclass//********************************** monitor **********************************//class rt_monitor;virtual rt_interface intf;    rt_packet in_pkts[16][$];    rt_packet out_pkts[16][$];    task run();    fork        mon_chnls();    join_noneendtask    task mon_chnls;    foreach(in_pkts[i]) begin        automatic int chid = i;        fork        mon_chnl_in(chid);//每个输入端口均调用mon_chnl_in任务，监测数据输入        mon_chnl_out(chid);//每个输出端口均调用mon_chnl_out任务，监测数据输入        join_none    endendtask    task  mon_chnl_in (bit[3:0]id);//监测数据输入的任务    rt_packet pkt;//定义结构体变量    forever begin    //clear content for the same struct variable。清除pkt    pkt = new();    pkt.src = id;//第id个输入端口    //monitor specific channel-in data and put it into the queue    // monitor address phase    @(negedge intf.frame_n[id]);//监测frame_n下降沿(frame_n由时钟驱动)    for(int i=0; i<4; i++)begin        @(negedge intf.clock);//frame_n下降沿后监测4个clk negedge        pkt.dst[i]= intf.din[id];        end        $display ("@%0t: [MON] src_chn1[%0d] & dest_chn1[%0d] data trans started",$time,pkt.src,pkt.dst);    //pass pad phase 不考虑pad阶段是否满足协议要求    repeat(5) @(negedge intf.clock);    do begin        pkt.data = new [pkt.data.size + 1](pkt.data);//创建动态数组并复制pkt.data        for ( int i=0; i<8; i++) begin            @(negedge intf.clock); //在8个clk negedge监测8bit数据            pkt.data[pkt.data.size-1][i] = intf.din[id];        end    end while(!intf.frame_n[id]);    in_pkts[id].push_back(pkt);//将monitor拿到的数据放入in_pkts    $display("@%0t:[MON] CH_IN src_chnl[%0d] &dest_chnl[%0d ] finished with packet: \n%s",$time,pkt.src,pkt.dst,pkt.sprint());    endendtasktask  mon_chnl_out(bit[ 3:0]id);//监测数据输出的任务    rt_packet pkt;    forever begin        //clear content for the same struct variable        pkt = new();        pkt.dst = id;        @(negedge intf.frameo_n[id]);        $display( "@%0t: [MON] CH_OUT dest_chn1[%0d] data trans started",$time,pkt.dst);        do begin        pkt.data = new [ pkt.data.size + 1](pkt.data);        for(int i=0;i<8; i++) begin            @(negedge intf.clock iff !intf.valido_n[id]);//clock与valido_n信号同时为低            pkt.data[pkt.data.size-1][i]= intf.dout [id];        end    end while(!intf.frameo_n[id]);    // NOTE : src is from data format (user defined)    pkt.src = pkt.data[0][7:4];//高4位    out_pkts[id].push_back(pkt);    $display("@%0t: [MON] CH_OUT dest_chn1[%0d] data finished woth packet : \n %s",$time,pkt.dst,pkt.sprint());    //monitor specific channel-out data and put it into the queue    endendtaskendclass//********************************** checker **********************************//class rt_checker;    int unsigned compare_count;    int unsigned error_count;        function new();//赋初值，可有可无，整形变量默认初始值为0        compare_count = 0;        error_count = 0;    endfunction        rt_packet exp_out_pkts[16][$];    rt_monitor mon;        task run();    foreach(exp_out_pkts[i])begin        automatic int chid = i;        fork            do_routing(chid);            do_compare(chid);        join_none        end    endtask        task do_routing(bit[3:0] id);//将monitor中采样到的输入数据放入期望的输出端队列中        rt_packet pkt;        forever begin            wait(mon.in_pkts[id].size > 0);            pkt = mon.in_pkts[id].pop_front();//从monitor中拿到in_pkts队列数据放入pkt            exp_out_pkts[pkt.dst].push_back(pkt);//将pkt数据放入对应期望的dest_chnl            end    endtask         task do_compare(bit[3:0] id);//比较采集的实际输出与期望输出        rt_packet exp_pkt, act_pkt;        forever begin            wait(mon.out_pkts[id].size > 0 && exp_out_pkts[id].size > 0);//实际采样数据与期望数据都有值            act_pkt = mon.out_pkts[id].pop_front();//实际数据为monitor采样的输出数据            exp_pkt = exp_out_pkts[id].pop_front();//期望数据为monitor采样到的输入数据            if(act_pkt.compare(exp_pkt))begin//如果exp_pkt与act_pkt比较成功，返回1                $display("[CHK] data compare success with packet : \n%s",exp_pkt.sprint());            end            else begin                $display("[CHK] data compare failure with actual packet : \n%s \nexpected packet : \n%s", act_pkt.sprint(), exp_pkt.sprint());                error_count++;            end                compare_count++;        end    endtask         function void report(string name);        $display("TOTAL COMPARING %0d times",compare_count);        if(!error_count && check_data_buffer())//判断无误且二者有数据            $display("TEST [%s] PASSED!",name);        else begin            $display("TEST [%s]FAILED!",name);            $display("TOTAL ERROR %0d times", error_count);        end    endfunction        function bit check_data_buffer();        check_data_buffer = 1;        foreach(exp_out_pkts[id])begin             if(exp_out_pkts[id].size != 0)begin//exp_out_pkts必须有数据                check_data_buffer = 0;                $display("exp_out_pkts[%0d] buffer size is not 0(still with %0d data)",id,exp_out_pkts[id].size);            end            if(mon.out_pkts[id].size != 0)begin//mon.out_pkts必须有数据                check_data_buffer = 0;                $display("mon.out_pkts[%0d] buffer size is not 0(still with %0d data)",id,mon.out_pkts[id].size);            end        end    endfunction    endclass//********************************** Optional tests **********************************//class rt_env;//rt_env包含各个组件    rt_stimulator stim;    rt_monitor mon;    rt_generator gen;    rt_checker chk;            function new(virtual rt_interface intf);        //build stage,例化        stim = new();        gen = new();        mon = new();        chk = new();        //connect stage，连接        stim.intf = intf;        mon.intf = intf;        chk.mon = mon;//check拿monitor句柄，即拿monitor中in_pkts与out_pkts队列        stim.gen_pkts = gen.pkts;//将generaor的句柄赋值给stimlutor，数据从gen传到stim    endfunction         task run();        rt_packet p;        //run stage，run        fork            stim.run();//class里面的函数不会自动调用，需要手动调用            gen.run();            mon.run();            chk.run();        join_none    endtask        function void report(string name);        chk.report(name);    endfunction    endclassclass rt_base_test;//rt_base_test包含rt_env，rt_env包含各个组件    rt_env env;    bit gen_trans_done = 0;//表示数据传输未开始    int unsigned test_drain_time_us = 200;//数据传输完后等待报告的时间    string name;        function new(virtual rt_interface intf,string name = "rt_base_test");        env = new(intf);        this.name = name;    endfunction        virtual task run();    $display("TEST %s started",name);        fork            env.run();            report();//调用report        join_none    endtask        task report();        wait(gen_trans_done == 1);        #(test_drain_time_us * 1us);        env.report(name);//调用env里的chk.report()进行report        $finish();//terminates the current test    endtask  function void set_trans_done(bit done = 1);//将set_trans_done信号置为1，表示数据传输已完成        gen_trans_done = done;    endfunctionendclass    class rt_single_ch_test extends rt_base_test;//单个通道测试        rand bit signed [4:0] src;        rand bit signed [4:0] dst;        rand int unsigned pkt_count =10;        constraint test_cstr {            soft pkt_count inside {[20:30]};            src inside {[0 : 15]};            dst inside {[0 : 15]};            }        function new(virtual rt_interface intf,string name = "rt_single_ch_test");            super.new(intf,name);        endfunction                    task run();            rt_packet p;            super.run();//调用父类的run，即执行env.run()，进行组件的例化等操作            this.randomize(); //randmoize self to get constrained data            for ( int cnt=0; cnt < pkt_count; cnt++) begin//随机10次                p = new( );                p.randomize() with {src == local::src; dst == local::dst; };                env.gen.put_pkt(p);            end            set_trans_done();        endtask    endclass        class rt_multi_ch_test extends rt_base_test;//多通道测试        rand bit [3:0]ch_num;        rand bit [3:0]src[];        rand bit [3:0]dst[];        rand int unsigned pkt_count = 10;        constraint multi_ch_cstr {            soft pkt_count inside {[5:10]};            src.size == ch_num;            dst.size == ch_num;            foreach(src[i]) src[i] inside {[0:15]};            foreach(dst[i]) dst[i] inside {[0:15]};        }        constraint unique_cstr{            unique {src};            unique {dst};        }//单独声明约束，方便rt_two_ch_same_chout_test里关掉                function new(virtual rt_interface intf,string name = "rt_multi_ch_test");            super.new(intf,name);        endfunction                task run();            rt_packet p;            super.run();//调用父类的run，即执行env.run()，进行组件的例化等操作            this.randomize(); //randmoize self to get constrained data            for ( int cnt=0; cnt < pkt_count; cnt++) begin//随机10次                foreach (src[i]) begin                    p = new( );                    p.randomize() with {src == local::src[i]; dst == local::dst[i]; };                    env.gen.put_pkt(p);                end            end            set_trans_done();        endtask    endclass        class rt_two_ch_test extends rt_multi_ch_test;        constraint two_ch_cstr {                ch_num == 2;//2通道测试            }        function new(virtual rt_interface intf,string name = "rt_two_ch_test");            super.new(intf,name);        endfunction    endclass            class rt_two_ch_same_chout_test extends rt_two_ch_test;//子类可以继承父类的run，此处不需要再添加，只需添加约束即可            rand bit [3:0]same_dst;            constraint two_ch_same_chout_cstr{            foreach(dst[i]) dst[i] == same_dst;//保证dst_chnl相同            same_dst inside {[0:15]};            unique {src};//随机过程过程中每个src不一样            }            function new(virtual rt_interface intf,string name = "rt_two_ch_same_chout_test");                super.new(intf,name);                unique_cstr.constraint_mode (0);//关掉父类约束            endfunction        endclass        class rt_full_ch_test extends rt_multi_ch_test;            function new(virtual rt_interface intf,string name = "rt_full_ch_test");                super.new(intf,name);            endfunction        endclassendpackage</code></pre><h2 id="3-3-仿真结果"><a href="#3-3-仿真结果" class="headerlink" title="3.3 仿真结果"></a>3.3 仿真结果</h2><p>进行相同dst_chnl通道测试，执行命令：</p><blockquote><p>make rung TESTNAME=rt_two_ch_same_chout_test &amp;</p></blockquote><p>结果同上</p><h1 id="4-完善rt-full-ch-test"><a href="#4-完善rt-full-ch-test" class="headerlink" title="4. 完善rt_full_ch_test"></a>4. 完善rt_full_ch_test</h1><h2 id="4-1-Makefile"><a href="#4-1-Makefile" class="headerlink" title="4.1 Makefile"></a>4.1 Makefile</h2><pre class=" language-c"><code class="language-c">###########################<span class="token macro property"># User variables</span>###########################TB       <span class="token operator">=</span> tbSEED  <span class="token operator">=</span> <span class="token number">1</span>TESTNAME <span class="token operator">?</span><span class="token operator">=</span> rt_single_ch_testFILES    <span class="token operator">=</span> router<span class="token punctuation">.</span>v rt_test_pkg<span class="token punctuation">.</span>sv lab8tb<span class="token punctuation">.</span>sv #User Defination###########################<span class="token macro property"># Environment variables</span>###########################COMP <span class="token operator">=</span> vcs <span class="token operator">-</span>full64 <span class="token operator">-</span>sverilog <span class="token operator">-</span>debug_access<span class="token operator">+</span>all <span class="token operator">-</span>timescale<span class="token operator">=</span>1ns<span class="token operator">/</span>1ps <span class="token operator">-</span>l comp<span class="token punctuation">.</span>log $<span class="token punctuation">(</span>FILES<span class="token punctuation">)</span>RUN <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token operator">/</span>$<span class="token punctuation">(</span>TB<span class="token punctuation">)</span><span class="token punctuation">.</span>simv <span class="token operator">-</span>l run<span class="token punctuation">.</span>log <span class="token operator">-</span>sml <span class="token operator">+</span>ntb_random_seed<span class="token operator">=</span>$<span class="token punctuation">(</span>SEED<span class="token punctuation">)</span> <span class="token operator">+</span>TESTNAME<span class="token operator">=</span>$<span class="token punctuation">(</span>TESTNAME<span class="token punctuation">)</span>comp<span class="token punctuation">:</span>    $<span class="token punctuation">(</span>COMP<span class="token punctuation">)</span> <span class="token operator">-</span>top $<span class="token punctuation">(</span>TB<span class="token punctuation">)</span> <span class="token operator">-</span>o $<span class="token punctuation">(</span>TB<span class="token punctuation">)</span><span class="token punctuation">.</span>simvrun<span class="token punctuation">:</span>    $<span class="token punctuation">(</span>RUN<span class="token punctuation">)</span>rung<span class="token punctuation">:</span>    $<span class="token punctuation">(</span>RUN<span class="token punctuation">)</span> <span class="token operator">-</span>gui</code></pre><h2 id="4-2-lab10tb-sv"><a href="#4-2-lab10tb-sv" class="headerlink" title="4.2 lab10tb.sv"></a>4.2 lab10tb.sv</h2><pre class=" language-systemverilog"><code class="language-systemverilog">//********************************** rt_interface **********************************//interface rt_interface();    logic clock;    logic reset_n;    logic [15:0] din;    logic [15:0] frame_n;    logic [15:0] valid_n;    logic [15:0] dout;    logic [15:0] valido_n;    logic [15:0] busy_n;    logic [15:0] frameo_n;endinterface//********************************** tb **********************************//module tb;  import rt_test_pkg ::*;        bit clk,rstn;    logic [15:0] din, frame_n, valid_n;    logic [15:0] dout, valido_n, busy_n, frameo_n;// 产生时钟，周期为10nsinitial     forever #5ns clk <= !clk;// 产生复位信号  initial begin    #2ns rstn <= 1;    #10ns rstn <= 0;    #10ns rstn <= 1;  end//例化router为DUTrouter dut(             .reset_n(rstn),  .clock(clk),  .frame_n(intf.frame_n),  .valid_n(intf.valid_n),  .din(intf.din),  .dout(intf.dout),  .busy_n(intf.busy_n),  .valido_n(intf.valido_n),  .frameo_n(intf.frameo_n));rt_interface intf();//例化接口    assign intf.reset_n = rstn;    assign intf.clock = clk;    rt_single_ch_test  single_ch_test;    rt_two_ch_test   two_ch_test;    rt_multi_ch_test   multi_ch_test;    rt_two_ch_same_chout_test two_ch_same_chout_test;    rt_full_ch_test full_ch_test;        rt_base_test tests[string];//父类记得添加virtual，否则存放的是父类句柄，执行父类的run        initial begin : Select_the_test        string name;        single_ch_test = new(intf);        two_ch_test  = new(intf);        multi_ch_test  = new(intf);        two_ch_same_chout_test  = new(intf);        full_ch_test  = new(intf);                tests["rt_single_ch_test"] = single_ch_test;        tests["rt_two_ch_test"   ] = two_ch_test;        tests["rt_multi_ch_test" ] = multi_ch_test ;        tests["rt_two_ch_same_chout_test"] = two_ch_same_chout_test;        tests["rt_full_ch_test"] = full_ch_test;                if($value$plusargs("TESTNAME=%s",name))begin//$value$plusargs作用：运行仿真时输入参数            if(tests.exists(name))        tests[name].run();//调用对应test进行run            else                $fatal("[ERRTEST],test name %s is invalid,please specity a valid name!0",name);            end  end    endmodule </code></pre><h2 id="4-3-rt-test-pkg-sv"><a href="#4-3-rt-test-pkg-sv" class="headerlink" title="4.3 rt_test_pkg.sv"></a>4.3 rt_test_pkg.sv</h2><pre class=" language-systemverilog"><code class="language-systemverilog">package rt_test_pkg;class rt_packet;  rand bit [3:0] src;  rand bit [3:0] dst;  rand bit [7:0] data [];  constraint pkg_cstr{    soft data.size inside{[1:32]};    foreach(data[i])        soft data[i] == (src << 4) + i;    }  function new();  endfunction  function void set_members(bit [3:0]src, bit [3:0]dst, bit[7:0]data []);    this.src = src;    this.dst = dst;    this.data = data;  endfunction  function string sprint();//打印packet信息的函数    sprint = {sprint , $sformatf("src = %0d\n",src)};    sprint = {sprint , $sformatf("dst = %0d\n",dst)};    sprint = {sprint , $sformatf("data_length = %0d\n",data.size())};    foreach(data[i])        sprint = {sprint , $sformatf("data[%0d] = 'h%0x\n", i, data[i])};  endfunction  function bit compare(rt_packet p);//输入exp_pkt        if(dst == p.dst && data == p.data)            compare = 1;        else             compare = 0;  endfunctionendclass//********************************** stimulator **********************************//class rt_stimulator;    virtual rt_interface intf;//class里的接口不能用端口的方式描述，需要添加virtual关键字，在类里面用接口的指针//for debug purpose from waveform//定义检测状态的变量  typedef enum {DRV_RESET,DRV_IDLE,DRV_ADDR,DRV_PAD,DRV_DATA} drv_state_t;  drv_state_t dbg_state;    byte unsigned dbg_din_chnl0_data;   semaphore src_chnl_status[16];//16个chnl的钥匙  mailbox #(rt_packet) gen_pkts;  mailbox #(rt_packet) ch_pkts[16];//从generator收到的数据按照chnl编号分发到16个mailbox里      function new();  //pkts = new(1);//设定mailbox上限为1    foreach(src_chnl_status[i])        src_chnl_status[i] = new(1);        foreach (ch_pkts[i])            ch_pkts[i] = new(1);  endfunction//generator传送p给stimulatortask run();    fork        drive_reset(); //reset动作        distribute_packets();//分发数据        get_packet_and_drive(); //drive_chnl动作，发送数据    join_noneendtask//分发数据task distribute_packets();//从generator收到的数据按照chnl编号分发到16个mailbox里    rt_packet p;    forever begin        gen_pkts.get(p);//从stimulator中的mailbox中取出数据        ch_pkts[p.src].put(p);//将数据写入分发的对应chnl的mailbox中    endendtasktask drive_reset();//reset    forever begin        @(negedge intf.reset_n);        dbg_state <= DRV_RESET;        intf.din <= 0;        intf.frame_n <= '1;//等效16'hFFFF        intf.valid_n <= '1;    endendtask// 发送数据task get_packet_and_drive();    @(negedge intf.reset_n);    repeat (10)@(posedge intf.clock);    foreach(ch_pkts[i])begin    automatic int id = i;    automatic rt_packet p;        fork            forever begin            ch_pkts[id].get(p);//从对应chnl的mailbox中取出数据            drive_chnl(p);//drive数据            end        join_none    endendtasktask  drive_chnl(rt_packet p);  $display("@%0t:[DRV] src_chnl[%0d] & dest_chnl[%0d] data trans started with packet: \n%s",$time,p.src,p.dst,p.sprint());    // drive address phase 输入地址位阶段for(int i=0;i<4;i++)begin  //4 clock  @(posedge intf.clock);  dbg_state <=DRV_ADDR;  intf.din[p.src] <= p.dst[i];  intf.valid_n[p.src] <= $urandom_range(0,1);//valid_n在din的地址输入时间段可为任意值x  intf.frame_n[p.src] <= 1'b0;//frame_n需要为低end    // drive pad phase //隔离阶段  for (int i=0;i<5;i++)begin  //5 clock    @(posedge intf.clock);    dbg_state <=DRV_PAD;    intf.din[p.src] <= 1'b1;    intf.valid_n[p.src] <= 1'b1;//valid_n需为高电平    intf.frame_n[p.src] <= 1'b0; //frame_n需为低电平  end    // drive data phase 传输数据阶段  foreach(p.data[id])begin    for(int i=0;i<8;i++)begin     @(posedge intf.clock);      dbg_state <=DRV_DATA;      dbg_din_chnl0_data <= p.data[id];      intf.din[p.src] <= p.data[id][i];      intf.valid_n[p.src] <=1'b0;      intf.frame_n[p.src] <= (id == p.data.size()-1 && i == 7) ? 1'b1 : 1'b0;//packet最后一位输出数据时frameo_n为高    end  end// drive idle phase 闲置（没有数据传输）阶段  @(posedge intf.clock);  dbg_state <=DRV_IDLE;  dbg_din_chnl0_data <= 0;  intf.din[p.src] <= 1'b0;  intf.valid_n[p.src] <= 1'b1;  intf.frame_n[p.src] <= 1'b1;  $display("@%0t: [DRV]src_chnl[%0d],dest_chnl[%0d] data trans finished",$time,p.src,p.dst);endtaskendclass//********************************** generator **********************************//class rt_generator;//generator产生数据交给stimulator  mailbox #(rt_packet) pkts;//定义队列        function new();        pkts = new(1);//设定mailbox上限为1    endfunction      task put_pkt(input rt_packet p);    pkts.put(p);  endtask    task get_pkt(output rt_packet p);    pkts.get(p);  endtask  //generate a random packet  function void gen_pkt(int src = -1, int dst = -1);  endfunction    task run();        //TODO  endtask    endclass//********************************** monitor **********************************//class rt_monitor;virtual rt_interface intf;    rt_packet in_pkts[16][$];    rt_packet out_pkts[16][$];    task run();    fork        mon_chnls();    join_noneendtask    task mon_chnls;    foreach(in_pkts[i]) begin        automatic int chid = i;        fork        mon_chnl_in(chid);//每个输入端口均调用mon_chnl_in任务，监测数据输入        mon_chnl_out(chid);//每个输出端口均调用mon_chnl_out任务，监测数据输入        join_none    endendtask    task  mon_chnl_in (bit[3:0]id);//监测数据输入的任务    rt_packet pkt;//定义结构体变量    forever begin    //clear content for the same struct variable。清除pkt    pkt = new();    pkt.src = id;//第id个输入端口    //monitor specific channel-in data and put it into the queue    // monitor address phase    @(negedge intf.frame_n[id]);//监测frame_n下降沿(frame_n由时钟驱动)    for(int i=0; i<4; i++)begin        @(negedge intf.clock);//frame_n下降沿后监测4个clk negedge        pkt.dst[i]= intf.din[id];        end        $display ("@%0t: [MON] src_chn1[%0d] & dest_chn1[%0d] data trans started",$time,pkt.src,pkt.dst);    //pass pad phase 不考虑pad阶段是否满足协议要求    repeat(5) @(negedge intf.clock);    do begin        pkt.data = new [pkt.data.size + 1](pkt.data);//创建动态数组并复制pkt.data        for ( int i=0; i<8; i++) begin            @(negedge intf.clock); //在8个clk negedge监测8bit数据            pkt.data[pkt.data.size-1][i] = intf.din[id];        end    end while(!intf.frame_n[id]);    in_pkts[id].push_back(pkt);//将monitor拿到的数据放入in_pkts    $display("@%0t:[MON] CH_IN src_chnl[%0d] &dest_chnl[%0d ] finished with packet: \n%s",$time,pkt.src,pkt.dst,pkt.sprint());    endendtasktask  mon_chnl_out(bit[ 3:0]id);//监测数据输出的任务    rt_packet pkt;    forever begin        //clear content for the same struct variable        pkt = new();        pkt.dst = id;        @(negedge intf.frameo_n[id]);        $display( "@%0t: [MON] CH_OUT dest_chn1[%0d] data trans started",$time,pkt.dst);        do begin        pkt.data = new [ pkt.data.size + 1](pkt.data);        for(int i=0;i<8; i++) begin            @(negedge intf.clock iff !intf.valido_n[id]);//clock与valido_n信号同时为低            pkt.data[pkt.data.size-1][i]= intf.dout [id];        end    end while(!intf.frameo_n[id]);    // NOTE : src is from data format (user defined)    pkt.src = pkt.data[0][7:4];//高4位    out_pkts[id].push_back(pkt);    $display("@%0t: [MON] CH_OUT dest_chn1[%0d] data finished woth packet : \n %s",$time,pkt.dst,pkt.sprint());    //monitor specific channel-out data and put it into the queue    endendtaskendclass//********************************** checker **********************************//class rt_checker;    int unsigned compare_count;    int unsigned error_count;        function new();//赋初值，可有可无，整形变量默认初始值为0        compare_count = 0;        error_count = 0;    endfunction        rt_packet exp_out_pkts[16][$];    rt_monitor mon;        task run();    foreach(exp_out_pkts[i])begin        automatic int chid = i;        fork            do_routing(chid);            do_compare(chid);        join_none        end    endtask        task do_routing(bit[3:0] id);//将monitor中采样到的输入数据放入期望的输出端队列中        rt_packet pkt;        forever begin            wait(mon.in_pkts[id].size > 0);            pkt = mon.in_pkts[id].pop_front();//从monitor中拿到in_pkts队列数据放入pkt            exp_out_pkts[pkt.dst].push_back(pkt);//将pkt数据放入对应期望的dest_chnl            end    endtask         task do_compare(bit[3:0] id);//比较采集的实际输出与期望输出        rt_packet exp_pkt, act_pkt;        forever begin            wait(mon.out_pkts[id].size > 0 && exp_out_pkts[id].size > 0);//实际采样数据与期望数据都有值            act_pkt = mon.out_pkts[id].pop_front();//实际数据为monitor采样的输出数据            exp_pkt = exp_out_pkts[id].pop_front();//期望数据为monitor采样到的输入数据            if(act_pkt.compare(exp_pkt))begin//如果exp_pkt与act_pkt比较成功，返回1                $display("[CHK] data compare success with packet : \n%s",exp_pkt.sprint());            end            else begin                $display("[CHK] data compare failure with actual packet : \n%s \nexpected packet : \n%s", act_pkt.sprint(), exp_pkt.sprint());                error_count++;            end                compare_count++;        end    endtask         function void report(string name);        $display("TOTAL COMPARING %0d times",compare_count);        if(!error_count && check_data_buffer())//判断无误且二者有数据            $display("TEST [%s] PASSED!",name);        else begin            $display("TEST [%s]FAILED!",name);            $display("TOTAL ERROR %0d times", error_count);        end    endfunction        function bit check_data_buffer();        check_data_buffer = 1;        foreach(exp_out_pkts[id])begin             if(exp_out_pkts[id].size != 0)begin//exp_out_pkts必须有数据                check_data_buffer = 0;                $display("exp_out_pkts[%0d] buffer size is not 0(still with %0d data)",id,exp_out_pkts[id].size);            end            if(mon.out_pkts[id].size != 0)begin//mon.out_pkts必须有数据                check_data_buffer = 0;                $display("mon.out_pkts[%0d] buffer size is not 0(still with %0d data)",id,mon.out_pkts[id].size);            end        end    endfunction    endclass//********************************** Optional tests **********************************//class rt_env;//rt_env包含各个组件    rt_stimulator stim;    rt_monitor mon;    rt_generator gen;    rt_checker chk;            function new(virtual rt_interface intf);        //build stage,例化        stim = new();        gen = new();        mon = new();        chk = new();        //connect stage，连接        stim.intf = intf;        mon.intf = intf;        chk.mon = mon;//check拿monitor句柄，即拿monitor中in_pkts与out_pkts队列        stim.gen_pkts = gen.pkts;//将generaor的句柄赋值给stimlutor，数据从gen传到stim    endfunction         task run();        rt_packet p;        //run stage，run        fork            stim.run();//class里面的函数不会自动调用，需要手动调用            gen.run();            mon.run();            chk.run();        join_none    endtask        function void report(string name);        chk.report(name);    endfunction    endclassclass rt_base_test;//rt_base_test包含rt_env，rt_env包含各个组件    rt_env env;    bit gen_trans_done = 0;//表示数据传输未开始    int unsigned test_drain_time_us = 10;//数据传输完后等待报告的时间    string name;        function new(virtual rt_interface intf,string name = "rt_base_test");        env = new(intf);        this.name = name;    endfunction        virtual task run();    $display("TEST %s started",name);        fork            env.run();            report();//调用report        join_none    endtask        task report();        wait(gen_trans_done == 1);        #(test_drain_time_us * 1us);        env.report(name);//调用env里的chk.report()进行report        $finish();//terminates the current test    endtask  function void set_trans_done(bit done = 1);//将set_trans_done信号置为1，表示数据传输已完成        gen_trans_done = done;    endfunctionendclass    class rt_single_ch_test extends rt_base_test;//单个通道测试        rand bit signed [4:0] src;        rand bit signed [4:0] dst;        rand int unsigned pkt_count =10;        constraint test_cstr {            soft pkt_count inside {[20:30]};            src inside {[0 : 15]};            dst inside {[0 : 15]};            }        function new(virtual rt_interface intf,string name = "rt_single_ch_test");            super.new(intf,name);        endfunction                    task run();            rt_packet p;            super.run();//调用父类的run，即执行env.run()，进行组件的例化等操作            this.randomize(); //randmoize self to get constrained data            for ( int cnt=0; cnt < pkt_count; cnt++) begin//随机10次                p = new( );                p.randomize() with {src == local::src; dst == local::dst; };                env.gen.put_pkt(p);            end            set_trans_done();        endtask    endclass        class rt_multi_ch_test extends rt_base_test;//多通道测试        rand int ch_num;        rand bit [3:0]src[];        rand bit [3:0]dst[];        rand int unsigned pkt_count = 10;        constraint multi_ch_cstr {            soft pkt_count inside {[5:10]};            ch_num inside {[1:16]};            src.size == ch_num;            dst.size == ch_num;            foreach(src[i]) src[i] inside {[0:15]};            foreach(dst[i]) dst[i] inside {[0:15]};        }        constraint unique_cstr{            unique {src};            unique {dst};        }//单独声明约束，方便rt_two_ch_same_chout_test里关掉                function new(virtual rt_interface intf,string name = "rt_multi_ch_test");            super.new(intf,name);        endfunction                task run();            rt_packet p;            super.run();//调用父类的run，即执行env.run()，进行组件的例化等操作            this.randomize(); //randmoize self to get constrained data            for ( int cnt=0; cnt < pkt_count; cnt++) begin//随机10次                foreach (src[i]) begin                    p = new( );                    p.randomize() with {src == local::src[i]; dst == local::dst[i]; };                    env.gen.put_pkt(p);                end            end            set_trans_done();        endtask    endclass        class rt_two_ch_test extends rt_multi_ch_test;        constraint two_ch_cstr {                ch_num == 2;//2通道测试            }        function new(virtual rt_interface intf,string name = "rt_two_ch_test");            super.new(intf,name);        endfunction    endclass            class rt_two_ch_same_chout_test extends rt_two_ch_test;//子类可以继承父类的run，此处不需要再添加，只需添加约束即可            rand bit [3:0]same_dst;            constraint two_ch_same_chout_cstr{            foreach(dst[i]) dst[i] == same_dst;//保证dst_chnl相同            same_dst inside {[0:15]};            unique {src};//随机过程过程中每个src不一样            }            function new(virtual rt_interface intf,string name = "rt_two_ch_same_chout_test");                super.new(intf,name);                unique_cstr.constraint_mode (0);//关掉父类约束            endfunction        endclass        class rt_full_ch_test extends rt_multi_ch_test;            constraint full_ch_cstr {            ch_num == 16;//通道数量为16        }            function new(virtual rt_interface intf,string name = "rt_full_ch_test");                super.new(intf,name);            endfunction        endclassendpackage</code></pre><h2 id="4-4-仿真结果"><a href="#4-4-仿真结果" class="headerlink" title="4.4 仿真结果"></a>4.4 仿真结果</h2><p>执行命令</p><blockquote><p>make rung TESTNAME=rt_full_ch_test &amp;</p></blockquote><div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211231658181.png " width="100%" height="100%"></div>]]></content>
      
      
      <categories>
          
          <category> 数字IC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字前端 </tag>
            
            <tag> SystemVerilog验证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SystemVerilog课程笔记(九)</title>
      <link href="/2022/11/22/systemverilog-ke-cheng-bi-ji-jiu/"/>
      <url>/2022/11/22/systemverilog-ke-cheng-bi-ji-jiu/</url>
      
        <content type="html"><![CDATA[<h1 id="1-将generator、monitor中的队列改为mailbox"><a href="#1-将generator、monitor中的队列改为mailbox" class="headerlink" title="1. 将generator、monitor中的队列改为mailbox"></a>1. 将generator、monitor中的队列改为mailbox</h1><blockquote><p>mailbox #(rt_packet) pkts;</p></blockquote><h1 id="2-将generator、monitor中的mailbox设置上限为1"><a href="#2-将generator、monitor中的mailbox设置上限为1" class="headerlink" title="2. 将generator、monitor中的mailbox设置上限为1"></a>2. 将generator、monitor中的mailbox设置上限为1</h1><h2 id="2-1-改造后的rt-test-pkg"><a href="#2-1-改造后的rt-test-pkg" class="headerlink" title="2.1 改造后的rt_test_pkg"></a>2.1 改造后的rt_test_pkg</h2><pre class=" language-systemverilog"><code class="language-systemverilog">package rt_test_pkg;class rt_packet;  rand bit [3:0] src;  rand bit [3:0] dst;  rand bit [7:0] data [];  constraint pkg_cstr{    soft data.size inside{[1:32]};    foreach(data[i])        soft data[i] == (src << 4) + i;    }  function new();  endfunction  function void set_members(bit [3:0]src, bit [3:0]dst, bit[7:0]data []);    this.src = src;    this.dst = dst;    this.data = data;  endfunction  function string sprint();//打印packet信息的函数    sprint = {sprint , $sformatf("src = %0d\n",src)};    sprint = {sprint , $sformatf("dst = %0d\n",dst)};    sprint = {sprint , $sformatf("data_length = %0d\n",data.size())};    foreach(data[i])        sprint = {sprint , $sformatf("data[%0d] = 'h%0x\n", i, data[i])};  endfunction  function bit compare(rt_packet p);//输入exp_pkt        if(dst == p.dst && data == p.data)            compare = 1;        else             compare = 0;  endfunctionendclass//********************************** stimulator **********************************//class rt_stimulator;    virtual rt_interface intf;//class里的接口不能用端口的方式描述，需要添加virtual关键字，在类里面用接口的指针//for debug purpose from waveform//定义检测状态的变量  typedef enum {DRV_RESET,DRV_IDLE,DRV_ADDR,DRV_PAD,DRV_DATA} drv_state_t;  drv_state_t dbg_state;    byte unsigned dbg_din_chnl0_data;   semaphore src_chnl_status[16];//16个chnl的钥匙  mailbox #(rt_packet) pkts;      function new();  pkts = new(1);//设定mailbox上限为1    foreach(src_chnl_status[i])        src_chnl_status[i] = new(1);  endfunction//generator传送p给stimulator  task put_pkt(input rt_packet p);    pkts.put(p);  endtasktask run();    fork        drive_reset(); //reset动作        get_packet_and_drive(); //drive_chnl动作    join_noneendtask    task drive_reset();//reset    forever begin        @(negedge intf.reset_n);        dbg_state <= DRV_RESET;        intf.din <= 0;        intf.frame_n <= '1;//等效16'hFFFF        intf.valid_n <= '1;    endendtask// 发送数据task get_packet_and_drive();//drive_chnl  @(negedge intf.reset_n);  repeat(10) @(posedge intf.clock);//延迟10个时钟周期  forever begin    automatic rt_packet p;//声明一个动态的    pkts.get(p);    fork//后台触发线程，触发线程在后台运行，继续执行剩下内容        begin            wait_src_chnl_avail(p);//判断src chnl是否被占用，是否需要等待            drive_chnl(p);//从P中拿到发送端口，目标端口，发送数据            set_src_chnl_avail(p);        end    join    //join_none    endendtasktask  wait_src_chnl_avail(rt_packet p);//判断src chnl是否被占用，是否需要等待    src_chnl_status[p.src].get(1);//拿到钥匙endtaskfunction  set_src_chnl_avail(rt_packet p);    src_chnl_status[p.src].put(1);//还钥匙endfunctiontask  drive_chnl(rt_packet p);  $display("@%0t:[DRV] src_chnl[%0d] & dest_chnl[%0d] data trans started with packet: \n%s",$time,p.src,p.dst,p.sprint());    // drive address phase 输入地址位阶段for(int i=0;i<4;i++)begin  //4 clock  @(posedge intf.clock);  dbg_state <=DRV_ADDR;  intf.din[p.src] <= p.dst[i];  intf.valid_n[p.src] <= $urandom_range(0,1);//valid_n在din的地址输入时间段可为任意值x  intf.frame_n[p.src] <= 1'b0;//frame_n需要为低end    // drive pad phase //隔离阶段  for (int i=0;i<5;i++)begin  //5 clock    @(posedge intf.clock);    dbg_state <=DRV_PAD;    intf.din[p.src] <= 1'b1;    intf.valid_n[p.src] <= 1'b1;//valid_n需为高电平    intf.frame_n[p.src] <= 1'b0; //frame_n需为低电平  end    // drive data phase 传输数据阶段  foreach(p.data[id])begin    for(int i=0;i<8;i++)begin     @(posedge intf.clock);      dbg_state <=DRV_DATA;      dbg_din_chnl0_data <= p.data[id];      intf.din[p.src] <= p.data[id][i];      intf.valid_n[p.src] <=1'b0;      intf.frame_n[p.src] <= (id == p.data.size()-1 && i == 7) ? 1'b1 : 1'b0;//packet最后一位输出数据时frameo_n为高    end  end// drive idle phase 闲置（没有数据传输）阶段  @(posedge intf.clock);  dbg_state <=DRV_IDLE;  dbg_din_chnl0_data <= 0;  intf.din[p.src] <= 1'b0;  intf.valid_n[p.src] <= 1'b1;  intf.frame_n[p.src] <= 1'b1;  $display("@%0t: [DRV]src_chnl[%0d],dest_chnl[%0d] data trans finished",$time,p.src,p.dst);endtaskendclass//********************************** generator **********************************//class rt_generator;//generator产生数据交给stimulator  mailbox #(rt_packet) pkts;//定义队列        function new();        pkts = new(1);//设定mailbox上限为1    endfunction      task put_pkt(input rt_packet p);    pkts.put(p);  endtask    task get_pkt(output rt_packet p);    pkts.get(p);  endtask  //generate a random packet  function void gen_pkt(int src = -1, int dst = -1);  endfunction    task run();        //TODO  endtask    endclass//********************************** monitor **********************************//class rt_monitor;virtual rt_interface intf;    rt_packet in_pkts[16][$];    rt_packet out_pkts[16][$];    task run();    fork        mon_chnls();    join_noneendtask    task mon_chnls;    foreach(in_pkts[i]) begin        automatic int chid = i;        fork        mon_chnl_in(chid);//每个输入端口均调用mon_chnl_in任务，监测数据输入        mon_chnl_out(chid);//每个输出端口均调用mon_chnl_out任务，监测数据输入        join_none    endendtask    task  mon_chnl_in (bit[3:0]id);//监测数据输入的任务    rt_packet pkt;//定义结构体变量    forever begin    //clear content for the same struct variable。清除pkt    pkt = new();    pkt.src = id;//第id个输入端口    //monitor specific channel-in data and put it into the queue    // monitor address phase    @(negedge intf.frame_n[id]);//监测frame_n下降沿(frame_n由时钟驱动)    for(int i=0; i<4; i++)begin        @(negedge intf.clock);//frame_n下降沿后监测4个clk negedge        pkt.dst[i]= intf.din[id];        end        $display ("@%0t: [MON] src_chn1[%0d] & dest_chn1[%0d] data trans started",$time,pkt.src,pkt.dst);    //pass pad phase 不考虑pad阶段是否满足协议要求    repeat(5) @(negedge intf.clock);    do begin        pkt.data = new [pkt.data.size + 1](pkt.data);//创建动态数组并复制pkt.data        for ( int i=0; i<8; i++) begin            @(negedge intf.clock); //在8个clk negedge监测8bit数据            pkt.data[pkt.data.size-1][i] = intf.din[id];        end    end while(!intf.frame_n[id]);    in_pkts[id].push_back(pkt);//将monitor拿到的数据放入in_pkts    $display("@%0t:[MON] CH_IN src_chnl[%0d] &dest_chnl[%0d ] finished with packet: \n%s",$time,pkt.src,pkt.dst,pkt.sprint());    endendtasktask  mon_chnl_out(bit[ 3:0]id);//监测数据输出的任务    rt_packet pkt;    forever begin        //clear content for the same struct variable        pkt = new();        pkt.dst = id;        @(negedge intf.frameo_n[id]);        $display( "@%0t: [MON] CH_OUT dest_chn1[%0d] data trans started",$time,pkt.dst);        do begin        pkt.data = new [ pkt.data.size + 1](pkt.data);        for(int i=0;i<8; i++) begin            @(negedge intf.clock iff !intf.valido_n[id]);//clock与valido_n信号同时为低            pkt.data[pkt.data.size-1][i]= intf.dout [id];        end    end while(!intf.frameo_n[id]);    // NOTE : src is from data format (user defined)    pkt.src = pkt.data[0][7:4];//高4位    out_pkts[id].push_back(pkt);    $display("@%0t: [MON] CH_OUT dest_chn1[%0d] data finished woth packet : \n %s",$time,pkt.dst,pkt.sprint());    //monitor specific channel-out data and put it into the queue    endendtaskendclass//********************************** checker **********************************//class rt_checker;    int unsigned compare_count;    int unsigned error_count;        function new();//赋初值，可有可无，整形变量默认初始值为0        compare_count = 0;        error_count = 0;    endfunction        rt_packet exp_out_pkts[16][$];    rt_monitor mon;        task run();    foreach(exp_out_pkts[i])begin        automatic int chid = i;        fork            do_routing(chid);            do_compare(chid);        join_none        end    endtask        task do_routing(bit[3:0] id);//将monitor中采样到的输入数据放入期望的输出端队列中        rt_packet pkt;        forever begin            wait(mon.in_pkts[id].size > 0);            pkt = mon.in_pkts[id].pop_front();//从monitor中拿到in_pkts队列数据放入pkt            exp_out_pkts[pkt.dst].push_back(pkt);//将pkt数据放入对应期望的dest_chnl            end    endtask         task do_compare(bit[3:0] id);//比较采集的实际输出与期望输出        rt_packet exp_pkt, act_pkt;        forever begin            wait(mon.out_pkts[id].size > 0 && exp_out_pkts[id].size > 0);//实际采样数据与期望数据都有值            act_pkt = mon.out_pkts[id].pop_front();//实际数据为monitor采样的输出数据            exp_pkt = exp_out_pkts[id].pop_front();//期望数据为monitor采样到的输入数据            if(act_pkt.compare(exp_pkt))begin//如果exp_pkt与act_pkt比较成功，返回1                $display("[CHK] data compare success with packet : \n%s",exp_pkt.sprint());            end            else begin                $display("[CHK] data compare failure with actual packet : \n%s \nexpected packet : \n%s", act_pkt.sprint(), exp_pkt.sprint());                error_count++;            end                compare_count++;        end    endtask         function void report(string name);        $display("TOTAL COMPARING %0d times",compare_count);        if(!error_count && check_data_buffer())//判断无误且二者有数据            $display("TEST [%s] PASSED!",name);        else begin            $display("TEST [%s]FAILED!",name);            $display("TOTAL ERROR %0d times", error_count);        end    endfunction        function bit check_data_buffer();        check_data_buffer = 1;        foreach(exp_out_pkts[id])begin             if(exp_out_pkts[id].size != 0)begin//exp_out_pkts必须有数据                check_data_buffer = 0;                $display("exp_out_pkts[%0d] buffer size is not 0(still with %0d data)",id,exp_out_pkts[id].size);            end            if(mon.out_pkts[id].size != 0)begin//mon.out_pkts必须有数据                check_data_buffer = 0;                $display("mon.out_pkts[%0d] buffer size is not 0(still with %0d data)",id,mon.out_pkts[id].size);            end        end    endfunction    endclass//********************************** Optional tests **********************************//class rt_env;//rt_env包含各个组件    rt_stimulator stim;    rt_monitor mon;    rt_generator gen;    rt_checker chk;            function new(virtual rt_interface intf);        //build stage,例化        stim = new();        gen = new();        mon = new();        chk = new();        //connect stage，连接        stim.intf = intf;        mon.intf = intf;        chk.mon = mon;//check拿monitor句柄，即拿monitor中in_pkts与out_pkts队列    endfunction         task run();        rt_packet p;        //run stage，run        fork            stim.run();//class里面的函数不会自动调用，需要手动调用            gen.run();            mon.run();            chk.run();            begin:genarator_to_stimulator_proc//取出genarator中的数据给stimulator                 forever begin//此处不需要延迟0，执行task run的时候默认function new已执行                    gen.get_pkt(p);//get句柄                    stim.put_pkt(p);//put句柄                end            end        join_none    endtask        function void report(string name);        chk.report(name);    endfunction    endclassclass rt_base_test;//rt_base_test包含rt_env，rt_env包含各个组件    rt_env env;    bit gen_trans_done = 0;//表示数据传输未开始    int unsigned test_drain_time_us = 200;//数据传输完后等待报告的时间    string name;        function new(virtual rt_interface intf,string name = "rt_base_test");        env = new(intf);        this.name = name;    endfunction        task run();    $display("TEST %s started",name);        fork            env.run();            report();//调用report        join_none    endtask        task report();        wait(gen_trans_done == 1);        #(test_drain_time_us * 1us);        env.report(name);//调用env里的chk.report()进行report        $finish();//terminates the current test    endtask  function void set_trans_done(bit done = 1);//将set_trans_done信号置为1，表示数据传输已完成        gen_trans_done = done;    endfunctionendclass    class rt_single_ch_test extends rt_base_test;//单个通道测试        rand bit signed [4:0] src;        rand bit signed [4:0] dst;        rand int unsigned pkt_count =10;        constraint test_cstr {            soft pkt_count inside {[1:20]};      pkt_count == 1000;            src inside {[0 : 15]};            dst inside {[0 : 15]};            }        function new(virtual rt_interface intf,string name = "rt_single_ch_test");            super.new(intf,name);        endfunction                    task run();            rt_packet p;            super.run();//调用父类的run，即执行env.run()，进行组件的例化等操作            this.randomize(); //randmoize self to get constrained data            for ( int cnt=0; cnt < pkt_count; cnt++) begin//随机10次                p = new( );                p.randomize() with {src == local::src; dst == local::dst; };                env.gen.put_pkt(p);            end            set_trans_done();        endtask            endclass    class rt_two_ch_test extends rt_base_test;        function new(virtual rt_interface intf,string name = "rt_two_ch_test");            super.new(intf,name);        endfunction    endclass        class rt_two_ch_same_chout_test extends rt_two_ch_test;            function new(virtual rt_interface intf,string name = "rt_two_ch_same_chout_test");                super.new(intf,name);            endfunction        endclass    class rt_multi_ch_test extends rt_base_test;//多通道测试        function new(virtual rt_interface intf,string name = "rt_multi_ch_test");            super.new(intf,name);        endfunction                task run();            rt_packet p;            super.run();            p = new();            p.set_members(0,3,'{8'h33,8'h77});            env.gen.put_pkt(p);            p = new();//每次put_pkt都需要new一下            p.set_members(0,5,'{8'h55,8'h66});            env.gen.put_pkt(p);            p = new();            p.set_members(3,6,'{8'h77,8'h88,8'h22});            env.gen.put_pkt(p);            p = new();            p.set_members(4,7,'{8'haa,8'hcc,8'h33});            env.gen.put_pkt(p);            set_trans_done();        endtask    endclass        class rt_full_ch_test extends rt_multi_ch_test;            function new(virtual rt_interface intf,string name = "rt_full_ch_test");                super.new(intf,name);            endfunction        endclassendpackage</code></pre><h2 id="2-2-仿真结果"><a href="#2-2-仿真结果" class="headerlink" title="2.2 仿真结果"></a>2.2 仿真结果</h2><blockquote><p>TOTAL COMPARING1000 timesTEST [rt_single_ch_test] PASSED!<br>$finish called from file “rt_test_pkg.sv”, line 377.<br>$finish at simulation time<br>1647385000<br>Simulation complete, time is 1647385000 ps.</p></blockquote><h1 id="3-将数据从genarator到stimulator的传递改为mailbox句柄的传递"><a href="#3-将数据从genarator到stimulator的传递改为mailbox句柄的传递" class="headerlink" title="3. 将数据从genarator到stimulator的传递改为mailbox句柄的传递"></a>3. 将数据从genarator到stimulator的传递改为mailbox句柄的传递</h1><h2 id="3-1-改造"><a href="#3-1-改造" class="headerlink" title="3.1 改造"></a>3.1 改造</h2><pre class=" language-systemverilog"><code class="language-systemverilog">begin:genarator_to_stimulator_proc//取出genarator中的数据给stimulator     forever begin//此处不需要延迟0，执行task run的时候默认function new已执行        gen.get_pkt(p);//get句柄        stim.put_pkt(p);//put句柄    end</code></pre><p>将数据从genarator到stimulator的传递改为mailbox句柄的传递</p><pre class=" language-systemverilog"><code class="language-systemverilog">stim.pkts = gen.pkts;//将generaor的句柄赋值给stimlutor</code></pre><h2 id="3-2-改进后的lab9tb-sv"><a href="#3-2-改进后的lab9tb-sv" class="headerlink" title="3.2 改进后的lab9tb.sv"></a>3.2 改进后的lab9tb.sv</h2><pre class=" language-systemverilog"><code class="language-systemverilog">//********************************** rt_interface **********************************//interface rt_interface();    logic clock;    logic reset_n;    logic [15:0] din;    logic [15:0] frame_n;    logic [15:0] valid_n;    logic [15:0] dout;    logic [15:0] valido_n;    logic [15:0] busy_n;    logic [15:0] frameo_n;endinterface//********************************** tb **********************************//module tb;  import rt_test_pkg ::*;        bit clk,rstn;    logic [15:0] din, frame_n, valid_n;    logic [15:0] dout, valido_n, busy_n, frameo_n;// 产生时钟，周期为10nsinitial     forever #5ns clk <= !clk;// 产生复位信号  initial begin    #2ns rstn <= 1;    #10ns rstn <= 0;    #10ns rstn <= 1;  end//例化router为DUTrouter dut(             .reset_n(rstn),  .clock(clk),  .frame_n(intf.frame_n),  .valid_n(intf.valid_n),  .din(intf.din),  .dout(intf.dout),  .busy_n(intf.busy_n),  .valido_n(intf.valido_n),  .frameo_n(intf.frameo_n));rt_interface intf();//例化接口    assign intf.reset_n = rstn;    assign intf.clock = clk;    rt_single_ch_test  single_ch_test;    rt_multi_ch_test   multi_ch_test;            initial begin : Select_the_test    string name;    single_ch_test = new(intf);    multi_ch_test  = new(intf);      //single_ch_test.run();      //multi_ch_test.run();      if($value$plusargs("TESTNAME=%s",name))begin//$value$plusargs作用：运行仿真时输入参数        case(name)            "rt_single_ch_test" : single_ch_test.run();//输入rt_single_ch_test，调用对应run，执行输入rt_single_ch_test                "rt_multi_ch_test" :multi_ch_test.run();            default:$fatal("[ERRTEST],test name %s is invalid,please specity a valid name!0",name);        endcase        end    end    endmodule </code></pre><h2 id="3-3-改进后的rt-test-pkg"><a href="#3-3-改进后的rt-test-pkg" class="headerlink" title="3.3 改进后的rt_test_pkg"></a>3.3 改进后的rt_test_pkg</h2><pre class=" language-systemverilog"><code class="language-systemverilog">package rt_test_pkg;class rt_packet;  rand bit [3:0] src;  rand bit [3:0] dst;  rand bit [7:0] data [];  constraint pkg_cstr{    soft data.size inside{[1:32]};    foreach(data[i])        soft data[i] == (src << 4) + i;    }  function new();  endfunction  function void set_members(bit [3:0]src, bit [3:0]dst, bit[7:0]data []);    this.src = src;    this.dst = dst;    this.data = data;  endfunction  function string sprint();//打印packet信息的函数    sprint = {sprint , $sformatf("src = %0d\n",src)};    sprint = {sprint , $sformatf("dst = %0d\n",dst)};    sprint = {sprint , $sformatf("data_length = %0d\n",data.size())};    foreach(data[i])        sprint = {sprint , $sformatf("data[%0d] = 'h%0x\n", i, data[i])};  endfunction  function bit compare(rt_packet p);//输入exp_pkt        if(dst == p.dst && data == p.data)            compare = 1;        else             compare = 0;  endfunctionendclass//********************************** stimulator **********************************//class rt_stimulator;    virtual rt_interface intf;//class里的接口不能用端口的方式描述，需要添加virtual关键字，在类里面用接口的指针//for debug purpose from waveform//定义检测状态的变量  typedef enum {DRV_RESET,DRV_IDLE,DRV_ADDR,DRV_PAD,DRV_DATA} drv_state_t;  drv_state_t dbg_state;    byte unsigned dbg_din_chnl0_data;   semaphore src_chnl_status[16];//16个chnl的钥匙  mailbox #(rt_packet) pkts;      function new();  //pkts = new(1);//设定mailbox上限为1    foreach(src_chnl_status[i])        src_chnl_status[i] = new(1);  endfunction//generator传送p给stimulator  task put_pkt(input rt_packet p);    pkts.put(p);  endtasktask run();    fork        drive_reset(); //reset动作        get_packet_and_drive(); //drive_chnl动作    join_noneendtask    task drive_reset();//reset    forever begin        @(negedge intf.reset_n);        dbg_state <= DRV_RESET;        intf.din <= 0;        intf.frame_n <= '1;//等效16'hFFFF        intf.valid_n <= '1;    endendtask// 发送数据task get_packet_and_drive();//drive_chnl  @(negedge intf.reset_n);  repeat(10) @(posedge intf.clock);//延迟10个时钟周期  forever begin    automatic rt_packet p;//声明一个动态的    pkts.get(p);    fork//后台触发线程，触发线程在后台运行，继续执行剩下内容        begin            wait_src_chnl_avail(p);//判断src chnl是否被占用，是否需要等待            drive_chnl(p);//从P中拿到发送端口，目标端口，发送数据            set_src_chnl_avail(p);        end    join    //join_none    endendtasktask  wait_src_chnl_avail(rt_packet p);//判断src chnl是否被占用，是否需要等待    src_chnl_status[p.src].get(1);//拿到钥匙endtaskfunction  set_src_chnl_avail(rt_packet p);    src_chnl_status[p.src].put(1);//还钥匙endfunctiontask  drive_chnl(rt_packet p);  $display("@%0t:[DRV] src_chnl[%0d] & dest_chnl[%0d] data trans started with packet: \n%s",$time,p.src,p.dst,p.sprint());    // drive address phase 输入地址位阶段for(int i=0;i<4;i++)begin  //4 clock  @(posedge intf.clock);  dbg_state <=DRV_ADDR;  intf.din[p.src] <= p.dst[i];  intf.valid_n[p.src] <= $urandom_range(0,1);//valid_n在din的地址输入时间段可为任意值x  intf.frame_n[p.src] <= 1'b0;//frame_n需要为低end    // drive pad phase //隔离阶段  for (int i=0;i<5;i++)begin  //5 clock    @(posedge intf.clock);    dbg_state <=DRV_PAD;    intf.din[p.src] <= 1'b1;    intf.valid_n[p.src] <= 1'b1;//valid_n需为高电平    intf.frame_n[p.src] <= 1'b0; //frame_n需为低电平  end    // drive data phase 传输数据阶段  foreach(p.data[id])begin    for(int i=0;i<8;i++)begin     @(posedge intf.clock);      dbg_state <=DRV_DATA;      dbg_din_chnl0_data <= p.data[id];      intf.din[p.src] <= p.data[id][i];      intf.valid_n[p.src] <=1'b0;      intf.frame_n[p.src] <= (id == p.data.size()-1 && i == 7) ? 1'b1 : 1'b0;//packet最后一位输出数据时frameo_n为高    end  end// drive idle phase 闲置（没有数据传输）阶段  @(posedge intf.clock);  dbg_state <=DRV_IDLE;  dbg_din_chnl0_data <= 0;  intf.din[p.src] <= 1'b0;  intf.valid_n[p.src] <= 1'b1;  intf.frame_n[p.src] <= 1'b1;  $display("@%0t: [DRV]src_chnl[%0d],dest_chnl[%0d] data trans finished",$time,p.src,p.dst);endtaskendclass//********************************** generator **********************************//class rt_generator;//generator产生数据交给stimulator  mailbox #(rt_packet) pkts;//定义队列        function new();        pkts = new(1);//设定mailbox上限为1    endfunction      task put_pkt(input rt_packet p);    pkts.put(p);  endtask    task get_pkt(output rt_packet p);    pkts.get(p);  endtask  //generate a random packet  function void gen_pkt(int src = -1, int dst = -1);  endfunction    task run();        //TODO  endtask    endclass//********************************** monitor **********************************//class rt_monitor;virtual rt_interface intf;    rt_packet in_pkts[16][$];    rt_packet out_pkts[16][$];    task run();    fork        mon_chnls();    join_noneendtask    task mon_chnls;    foreach(in_pkts[i]) begin        automatic int chid = i;        fork        mon_chnl_in(chid);//每个输入端口均调用mon_chnl_in任务，监测数据输入        mon_chnl_out(chid);//每个输出端口均调用mon_chnl_out任务，监测数据输入        join_none    endendtask    task  mon_chnl_in (bit[3:0]id);//监测数据输入的任务    rt_packet pkt;//定义结构体变量    forever begin    //clear content for the same struct variable。清除pkt    pkt = new();    pkt.src = id;//第id个输入端口    //monitor specific channel-in data and put it into the queue    // monitor address phase    @(negedge intf.frame_n[id]);//监测frame_n下降沿(frame_n由时钟驱动)    for(int i=0; i<4; i++)begin        @(negedge intf.clock);//frame_n下降沿后监测4个clk negedge        pkt.dst[i]= intf.din[id];        end        $display ("@%0t: [MON] src_chn1[%0d] & dest_chn1[%0d] data trans started",$time,pkt.src,pkt.dst);    //pass pad phase 不考虑pad阶段是否满足协议要求    repeat(5) @(negedge intf.clock);    do begin        pkt.data = new [pkt.data.size + 1](pkt.data);//创建动态数组并复制pkt.data        for ( int i=0; i<8; i++) begin            @(negedge intf.clock); //在8个clk negedge监测8bit数据            pkt.data[pkt.data.size-1][i] = intf.din[id];        end    end while(!intf.frame_n[id]);    in_pkts[id].push_back(pkt);//将monitor拿到的数据放入in_pkts    $display("@%0t:[MON] CH_IN src_chnl[%0d] &dest_chnl[%0d ] finished with packet: \n%s",$time,pkt.src,pkt.dst,pkt.sprint());    endendtasktask  mon_chnl_out(bit[ 3:0]id);//监测数据输出的任务    rt_packet pkt;    forever begin        //clear content for the same struct variable        pkt = new();        pkt.dst = id;        @(negedge intf.frameo_n[id]);        $display( "@%0t: [MON] CH_OUT dest_chn1[%0d] data trans started",$time,pkt.dst);        do begin        pkt.data = new [ pkt.data.size + 1](pkt.data);        for(int i=0;i<8; i++) begin            @(negedge intf.clock iff !intf.valido_n[id]);//clock与valido_n信号同时为低            pkt.data[pkt.data.size-1][i]= intf.dout [id];        end    end while(!intf.frameo_n[id]);    // NOTE : src is from data format (user defined)    pkt.src = pkt.data[0][7:4];//高4位    out_pkts[id].push_back(pkt);    $display("@%0t: [MON] CH_OUT dest_chn1[%0d] data finished woth packet : \n %s",$time,pkt.dst,pkt.sprint());    //monitor specific channel-out data and put it into the queue    endendtaskendclass//********************************** checker **********************************//class rt_checker;    int unsigned compare_count;    int unsigned error_count;        function new();//赋初值，可有可无，整形变量默认初始值为0        compare_count = 0;        error_count = 0;    endfunction        rt_packet exp_out_pkts[16][$];    rt_monitor mon;        task run();    foreach(exp_out_pkts[i])begin        automatic int chid = i;        fork            do_routing(chid);            do_compare(chid);        join_none        end    endtask        task do_routing(bit[3:0] id);//将monitor中采样到的输入数据放入期望的输出端队列中        rt_packet pkt;        forever begin            wait(mon.in_pkts[id].size > 0);            pkt = mon.in_pkts[id].pop_front();//从monitor中拿到in_pkts队列数据放入pkt            exp_out_pkts[pkt.dst].push_back(pkt);//将pkt数据放入对应期望的dest_chnl            end    endtask         task do_compare(bit[3:0] id);//比较采集的实际输出与期望输出        rt_packet exp_pkt, act_pkt;        forever begin            wait(mon.out_pkts[id].size > 0 && exp_out_pkts[id].size > 0);//实际采样数据与期望数据都有值            act_pkt = mon.out_pkts[id].pop_front();//实际数据为monitor采样的输出数据            exp_pkt = exp_out_pkts[id].pop_front();//期望数据为monitor采样到的输入数据            if(act_pkt.compare(exp_pkt))begin//如果exp_pkt与act_pkt比较成功，返回1                $display("[CHK] data compare success with packet : \n%s",exp_pkt.sprint());            end            else begin                $display("[CHK] data compare failure with actual packet : \n%s \nexpected packet : \n%s", act_pkt.sprint(), exp_pkt.sprint());                error_count++;            end                compare_count++;        end    endtask         function void report(string name);        $display("TOTAL COMPARING %0d times",compare_count);        if(!error_count && check_data_buffer())//判断无误且二者有数据            $display("TEST [%s] PASSED!",name);        else begin            $display("TEST [%s]FAILED!",name);            $display("TOTAL ERROR %0d times", error_count);        end    endfunction        function bit check_data_buffer();        check_data_buffer = 1;        foreach(exp_out_pkts[id])begin             if(exp_out_pkts[id].size != 0)begin//exp_out_pkts必须有数据                check_data_buffer = 0;                $display("exp_out_pkts[%0d] buffer size is not 0(still with %0d data)",id,exp_out_pkts[id].size);            end            if(mon.out_pkts[id].size != 0)begin//mon.out_pkts必须有数据                check_data_buffer = 0;                $display("mon.out_pkts[%0d] buffer size is not 0(still with %0d data)",id,mon.out_pkts[id].size);            end        end    endfunction    endclass//********************************** Optional tests **********************************//class rt_env;//rt_env包含各个组件    rt_stimulator stim;    rt_monitor mon;    rt_generator gen;    rt_checker chk;            function new(virtual rt_interface intf);        //build stage,例化        stim = new();        gen = new();        mon = new();        chk = new();        //connect stage，连接        stim.intf = intf;        mon.intf = intf;        chk.mon = mon;//check拿monitor句柄，即拿monitor中in_pkts与out_pkts队列        stim.pkts = gen.pkts;    endfunction         task run();        rt_packet p;        //run stage，run        fork            stim.run();//class里面的函数不会自动调用，需要手动调用            gen.run();            mon.run();            chk.run();        join_none    endtask        function void report(string name);        chk.report(name);    endfunction    endclassclass rt_base_test;//rt_base_test包含rt_env，rt_env包含各个组件    rt_env env;    bit gen_trans_done = 0;//表示数据传输未开始    int unsigned test_drain_time_us = 200;//数据传输完后等待报告的时间    string name;        function new(virtual rt_interface intf,string name = "rt_base_test");        env = new(intf);        this.name = name;    endfunction        task run();    $display("TEST %s started",name);        fork            env.run();            report();//调用report        join_none    endtask        task report();        wait(gen_trans_done == 1);        #(test_drain_time_us * 1us);        env.report(name);//调用env里的chk.report()进行report        $finish();//terminates the current test    endtask  function void set_trans_done(bit done = 1);//将set_trans_done信号置为1，表示数据传输已完成        gen_trans_done = done;    endfunctionendclass    class rt_single_ch_test extends rt_base_test;//单个通道测试        rand bit signed [4:0] src;        rand bit signed [4:0] dst;        rand int unsigned pkt_count =10;        constraint test_cstr {            soft pkt_count inside {[20:30]};            src inside {[0 : 15]};            dst inside {[0 : 15]};            }        function new(virtual rt_interface intf,string name = "rt_single_ch_test");            super.new(intf,name);        endfunction                    task run();            rt_packet p;            super.run();//调用父类的run，即执行env.run()，进行组件的例化等操作            this.randomize(); //randmoize self to get constrained data            for ( int cnt=0; cnt < pkt_count; cnt++) begin//随机10次                p = new( );                p.randomize() with {src == local::src; dst == local::dst; };                env.gen.put_pkt(p);            end            set_trans_done();        endtask            endclass    class rt_two_ch_test extends rt_base_test;        function new(virtual rt_interface intf,string name = "rt_two_ch_test");            super.new(intf,name);        endfunction    endclass        class rt_two_ch_same_chout_test extends rt_two_ch_test;            function new(virtual rt_interface intf,string name = "rt_two_ch_same_chout_test");                super.new(intf,name);            endfunction        endclass    class rt_multi_ch_test extends rt_base_test;//多通道测试        function new(virtual rt_interface intf,string name = "rt_multi_ch_test");            super.new(intf,name);        endfunction                task run();            rt_packet p;            super.run();            p = new();            p.set_members(0,3,'{8'h33,8'h77});            env.gen.put_pkt(p);            p = new();//每次put_pkt都需要new一下            p.set_members(0,5,'{8'h55,8'h66});            env.gen.put_pkt(p);            p = new();            p.set_members(3,6,'{8'h77,8'h88,8'h22});            env.gen.put_pkt(p);            p = new();            p.set_members(4,7,'{8'haa,8'hcc,8'h33});            env.gen.put_pkt(p);            set_trans_done();        endtask    endclass        class rt_full_ch_test extends rt_multi_ch_test;            function new(virtual rt_interface intf,string name = "rt_full_ch_test");                super.new(intf,name);            endfunction        endclassendpackage</code></pre><h2 id="3-4-仿真结果"><a href="#3-4-仿真结果" class="headerlink" title="3.4 仿真结果"></a>3.4 仿真结果</h2><p>同上</p><h1 id="4-使用关联数组进行test用例的选择"><a href="#4-使用关联数组进行test用例的选择" class="headerlink" title="4. 使用关联数组进行test用例的选择"></a>4. 使用关联数组进行test用例的选择</h1><h2 id="4-1改造"><a href="#4-1改造" class="headerlink" title="4.1改造"></a>4.1改造</h2><pre class=" language-systemverilog"><code class="language-systemverilog">rt_interface intf();//例化接口    assign intf.reset_n = rstn;    assign intf.clock = clk;    rt_single_ch_test  single_ch_test;    rt_two_ch_test   two_ch_test;    rt_multi_ch_test   multi_ch_test;        rt_base_test tests[string];//父类记得添加virtual，否则存放的是父类句柄，执行父类的run        initial begin : Select_the_test        string name;        single_ch_test = new(intf);        two_ch_test  = new(intf);        multi_ch_test  = new(intf);        tests["rt_single_ch_test"] = single_ch_test;        tests["rt_two_ch_test"   ] = two_ch_test;        tests["rt_multi_ch_test" ] = multi_ch_test ;        if($value$plusargs("TESTNAME=%s",name))begin//$value$plusargs作用：运行仿真时输入参数            if(tests.exists(name))        tests[name].run();//调用对应test进行run            else                $fatal("[ERRTEST],test name %s is invalid,please specity a valid name!0",name);            end  end</code></pre><h2 id="4-2-虚方法的使用"><a href="#4-2-虚方法的使用" class="headerlink" title="4.2 虚方法的使用"></a>4.2 虚方法的使用</h2><p>注意，要在父类的run任务里面<span style="background:rgba(240, 200, 0, 0.2)">添加virtual，优先调用子类里面的run</span><br>虚方法的使用详见<a href="http://daipeihong.top/2022/11/06/systemverilog-xue-xi-bi-ji-jiu/">SystemVerilog课程笔记(九)#4.2 虚方法的使用</a></p><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211230951057.png" width="100%" height="100%"></div><h2 id="4-3-改造后的lab9tb-sv"><a href="#4-3-改造后的lab9tb-sv" class="headerlink" title="4.3  改造后的lab9tb.sv"></a>4.3  改造后的lab9tb.sv</h2><pre class=" language-systemverilog"><code class="language-systemverilog">//********************************** rt_interface **********************************//interface rt_interface();    logic clock;    logic reset_n;    logic [15:0] din;    logic [15:0] frame_n;    logic [15:0] valid_n;    logic [15:0] dout;    logic [15:0] valido_n;    logic [15:0] busy_n;    logic [15:0] frameo_n;endinterface//********************************** tb **********************************//module tb;  import rt_test_pkg ::*;        bit clk,rstn;    logic [15:0] din, frame_n, valid_n;    logic [15:0] dout, valido_n, busy_n, frameo_n;// 产生时钟，周期为10nsinitial     forever #5ns clk <= !clk;// 产生复位信号  initial begin    #2ns rstn <= 1;    #10ns rstn <= 0;    #10ns rstn <= 1;  end//例化router为DUTrouter dut(             .reset_n(rstn),  .clock(clk),  .frame_n(intf.frame_n),  .valid_n(intf.valid_n),  .din(intf.din),  .dout(intf.dout),  .busy_n(intf.busy_n),  .valido_n(intf.valido_n),  .frameo_n(intf.frameo_n));rt_interface intf();//例化接口    assign intf.reset_n = rstn;    assign intf.clock = clk;    rt_single_ch_test  single_ch_test;    rt_two_ch_test   two_ch_test;    rt_multi_ch_test   multi_ch_test;        rt_base_test tests[string];//父类记得添加virtual，否则存放的是父类句柄，执行父类的run        initial begin : Select_the_test        string name;        single_ch_test = new(intf);        two_ch_test  = new(intf);        multi_ch_test  = new(intf);        tests["rt_single_ch_test"] = single_ch_test;        tests["rt_two_ch_test"   ] = two_ch_test;        tests["rt_multi_ch_test" ] = multi_ch_test ;        if($value$plusargs("TESTNAME=%s",name))begin//$value$plusargs作用：运行仿真时输入参数            if(tests.exists(name))        tests[name].run();//调用对应test进行run            else                $fatal("[ERRTEST],test name %s is invalid,please specity a valid name!0",name);            end  end    endmodule </code></pre><h2 id="4-4-改造后的rt-test-pkg"><a href="#4-4-改造后的rt-test-pkg" class="headerlink" title="4.4 改造后的rt_test_pkg"></a>4.4 改造后的rt_test_pkg</h2><pre class=" language-systemverilog"><code class="language-systemverilog">package rt_test_pkg;class rt_packet;  rand bit [3:0] src;  rand bit [3:0] dst;  rand bit [7:0] data [];  constraint pkg_cstr{    soft data.size inside{[1:32]};    foreach(data[i])        soft data[i] == (src << 4) + i;    }  function new();  endfunction  function void set_members(bit [3:0]src, bit [3:0]dst, bit[7:0]data []);    this.src = src;    this.dst = dst;    this.data = data;  endfunction  function string sprint();//打印packet信息的函数    sprint = {sprint , $sformatf("src = %0d\n",src)};    sprint = {sprint , $sformatf("dst = %0d\n",dst)};    sprint = {sprint , $sformatf("data_length = %0d\n",data.size())};    foreach(data[i])        sprint = {sprint , $sformatf("data[%0d] = 'h%0x\n", i, data[i])};  endfunction  function bit compare(rt_packet p);//输入exp_pkt        if(dst == p.dst && data == p.data)            compare = 1;        else             compare = 0;  endfunctionendclass//********************************** stimulator **********************************//class rt_stimulator;    virtual rt_interface intf;//class里的接口不能用端口的方式描述，需要添加virtual关键字，在类里面用接口的指针//for debug purpose from waveform//定义检测状态的变量  typedef enum {DRV_RESET,DRV_IDLE,DRV_ADDR,DRV_PAD,DRV_DATA} drv_state_t;  drv_state_t dbg_state;    byte unsigned dbg_din_chnl0_data;   semaphore src_chnl_status[16];//16个chnl的钥匙  mailbox #(rt_packet) pkts;      function new();  //pkts = new(1);//设定mailbox上限为1    foreach(src_chnl_status[i])        src_chnl_status[i] = new(1);  endfunction//generator传送p给stimulator  task put_pkt(input rt_packet p);    pkts.put(p);  endtasktask run();    fork        drive_reset(); //reset动作        get_packet_and_drive(); //drive_chnl动作    join_noneendtask    task drive_reset();//reset    forever begin        @(negedge intf.reset_n);        dbg_state <= DRV_RESET;        intf.din <= 0;        intf.frame_n <= '1;//等效16'hFFFF        intf.valid_n <= '1;    endendtask// 发送数据task get_packet_and_drive();//drive_chnl  @(negedge intf.reset_n);  repeat(10) @(posedge intf.clock);//延迟10个时钟周期  forever begin    automatic rt_packet p;//声明一个动态的    pkts.get(p);    fork//后台触发线程，触发线程在后台运行，继续执行剩下内容        begin            wait_src_chnl_avail(p);//判断src chnl是否被占用，是否需要等待            drive_chnl(p);//从P中拿到发送端口，目标端口，发送数据            set_src_chnl_avail(p);        end    join    //join_none    endendtasktask  wait_src_chnl_avail(rt_packet p);//判断src chnl是否被占用，是否需要等待    src_chnl_status[p.src].get(1);//拿到钥匙endtaskfunction  set_src_chnl_avail(rt_packet p);    src_chnl_status[p.src].put(1);//还钥匙endfunctiontask  drive_chnl(rt_packet p);  $display("@%0t:[DRV] src_chnl[%0d] & dest_chnl[%0d] data trans started with packet: \n%s",$time,p.src,p.dst,p.sprint());    // drive address phase 输入地址位阶段for(int i=0;i<4;i++)begin  //4 clock  @(posedge intf.clock);  dbg_state <=DRV_ADDR;  intf.din[p.src] <= p.dst[i];  intf.valid_n[p.src] <= $urandom_range(0,1);//valid_n在din的地址输入时间段可为任意值x  intf.frame_n[p.src] <= 1'b0;//frame_n需要为低end    // drive pad phase //隔离阶段  for (int i=0;i<5;i++)begin  //5 clock    @(posedge intf.clock);    dbg_state <=DRV_PAD;    intf.din[p.src] <= 1'b1;    intf.valid_n[p.src] <= 1'b1;//valid_n需为高电平    intf.frame_n[p.src] <= 1'b0; //frame_n需为低电平  end    // drive data phase 传输数据阶段  foreach(p.data[id])begin    for(int i=0;i<8;i++)begin     @(posedge intf.clock);      dbg_state <=DRV_DATA;      dbg_din_chnl0_data <= p.data[id];      intf.din[p.src] <= p.data[id][i];      intf.valid_n[p.src] <=1'b0;      intf.frame_n[p.src] <= (id == p.data.size()-1 && i == 7) ? 1'b1 : 1'b0;//packet最后一位输出数据时frameo_n为高    end  end// drive idle phase 闲置（没有数据传输）阶段  @(posedge intf.clock);  dbg_state <=DRV_IDLE;  dbg_din_chnl0_data <= 0;  intf.din[p.src] <= 1'b0;  intf.valid_n[p.src] <= 1'b1;  intf.frame_n[p.src] <= 1'b1;  $display("@%0t: [DRV]src_chnl[%0d],dest_chnl[%0d] data trans finished",$time,p.src,p.dst);endtaskendclass//********************************** generator **********************************//class rt_generator;//generator产生数据交给stimulator  mailbox #(rt_packet) pkts;//定义队列        function new();        pkts = new(1);//设定mailbox上限为1    endfunction      task put_pkt(input rt_packet p);    pkts.put(p);  endtask    task get_pkt(output rt_packet p);    pkts.get(p);  endtask  //generate a random packet  function void gen_pkt(int src = -1, int dst = -1);  endfunction    task run();        //TODO  endtask    endclass//********************************** monitor **********************************//class rt_monitor;virtual rt_interface intf;    rt_packet in_pkts[16][$];    rt_packet out_pkts[16][$];    task run();    fork        mon_chnls();    join_noneendtask    task mon_chnls;    foreach(in_pkts[i]) begin        automatic int chid = i;        fork        mon_chnl_in(chid);//每个输入端口均调用mon_chnl_in任务，监测数据输入        mon_chnl_out(chid);//每个输出端口均调用mon_chnl_out任务，监测数据输入        join_none    endendtask    task  mon_chnl_in (bit[3:0]id);//监测数据输入的任务    rt_packet pkt;//定义结构体变量    forever begin    //clear content for the same struct variable。清除pkt    pkt = new();    pkt.src = id;//第id个输入端口    //monitor specific channel-in data and put it into the queue    // monitor address phase    @(negedge intf.frame_n[id]);//监测frame_n下降沿(frame_n由时钟驱动)    for(int i=0; i<4; i++)begin        @(negedge intf.clock);//frame_n下降沿后监测4个clk negedge        pkt.dst[i]= intf.din[id];        end        $display ("@%0t: [MON] src_chn1[%0d] & dest_chn1[%0d] data trans started",$time,pkt.src,pkt.dst);    //pass pad phase 不考虑pad阶段是否满足协议要求    repeat(5) @(negedge intf.clock);    do begin        pkt.data = new [pkt.data.size + 1](pkt.data);//创建动态数组并复制pkt.data        for ( int i=0; i<8; i++) begin            @(negedge intf.clock); //在8个clk negedge监测8bit数据            pkt.data[pkt.data.size-1][i] = intf.din[id];        end    end while(!intf.frame_n[id]);    in_pkts[id].push_back(pkt);//将monitor拿到的数据放入in_pkts    $display("@%0t:[MON] CH_IN src_chnl[%0d] &dest_chnl[%0d ] finished with packet: \n%s",$time,pkt.src,pkt.dst,pkt.sprint());    endendtasktask  mon_chnl_out(bit[ 3:0]id);//监测数据输出的任务    rt_packet pkt;    forever begin        //clear content for the same struct variable        pkt = new();        pkt.dst = id;        @(negedge intf.frameo_n[id]);        $display( "@%0t: [MON] CH_OUT dest_chn1[%0d] data trans started",$time,pkt.dst);        do begin        pkt.data = new [ pkt.data.size + 1](pkt.data);        for(int i=0;i<8; i++) begin            @(negedge intf.clock iff !intf.valido_n[id]);//clock与valido_n信号同时为低            pkt.data[pkt.data.size-1][i]= intf.dout [id];        end    end while(!intf.frameo_n[id]);    // NOTE : src is from data format (user defined)    pkt.src = pkt.data[0][7:4];//高4位    out_pkts[id].push_back(pkt);    $display("@%0t: [MON] CH_OUT dest_chn1[%0d] data finished woth packet : \n %s",$time,pkt.dst,pkt.sprint());    //monitor specific channel-out data and put it into the queue    endendtaskendclass//********************************** checker **********************************//class rt_checker;    int unsigned compare_count;    int unsigned error_count;        function new();//赋初值，可有可无，整形变量默认初始值为0        compare_count = 0;        error_count = 0;    endfunction        rt_packet exp_out_pkts[16][$];    rt_monitor mon;        task run();    foreach(exp_out_pkts[i])begin        automatic int chid = i;        fork            do_routing(chid);            do_compare(chid);        join_none        end    endtask        task do_routing(bit[3:0] id);//将monitor中采样到的输入数据放入期望的输出端队列中        rt_packet pkt;        forever begin            wait(mon.in_pkts[id].size > 0);            pkt = mon.in_pkts[id].pop_front();//从monitor中拿到in_pkts队列数据放入pkt            exp_out_pkts[pkt.dst].push_back(pkt);//将pkt数据放入对应期望的dest_chnl            end    endtask         task do_compare(bit[3:0] id);//比较采集的实际输出与期望输出        rt_packet exp_pkt, act_pkt;        forever begin            wait(mon.out_pkts[id].size > 0 && exp_out_pkts[id].size > 0);//实际采样数据与期望数据都有值            act_pkt = mon.out_pkts[id].pop_front();//实际数据为monitor采样的输出数据            exp_pkt = exp_out_pkts[id].pop_front();//期望数据为monitor采样到的输入数据            if(act_pkt.compare(exp_pkt))begin//如果exp_pkt与act_pkt比较成功，返回1                $display("[CHK] data compare success with packet : \n%s",exp_pkt.sprint());            end            else begin                $display("[CHK] data compare failure with actual packet : \n%s \nexpected packet : \n%s", act_pkt.sprint(), exp_pkt.sprint());                error_count++;            end                compare_count++;        end    endtask         function void report(string name);        $display("TOTAL COMPARING %0d times",compare_count);        if(!error_count && check_data_buffer())//判断无误且二者有数据            $display("TEST [%s] PASSED!",name);        else begin            $display("TEST [%s]FAILED!",name);            $display("TOTAL ERROR %0d times", error_count);        end    endfunction        function bit check_data_buffer();        check_data_buffer = 1;        foreach(exp_out_pkts[id])begin             if(exp_out_pkts[id].size != 0)begin//exp_out_pkts必须有数据                check_data_buffer = 0;                $display("exp_out_pkts[%0d] buffer size is not 0(still with %0d data)",id,exp_out_pkts[id].size);            end            if(mon.out_pkts[id].size != 0)begin//mon.out_pkts必须有数据                check_data_buffer = 0;                $display("mon.out_pkts[%0d] buffer size is not 0(still with %0d data)",id,mon.out_pkts[id].size);            end        end    endfunction    endclass//********************************** Optional tests **********************************//class rt_env;//rt_env包含各个组件    rt_stimulator stim;    rt_monitor mon;    rt_generator gen;    rt_checker chk;            function new(virtual rt_interface intf);        //build stage,例化        stim = new();        gen = new();        mon = new();        chk = new();        //connect stage，连接        stim.intf = intf;        mon.intf = intf;        chk.mon = mon;//check拿monitor句柄，即拿monitor中in_pkts与out_pkts队列        stim.pkts = gen.pkts;    endfunction         task run();        rt_packet p;        //run stage，run        fork            stim.run();//class里面的函数不会自动调用，需要手动调用            gen.run();            mon.run();            chk.run();        join_none    endtask        function void report(string name);        chk.report(name);    endfunction    endclassclass rt_base_test;//rt_base_test包含rt_env，rt_env包含各个组件    rt_env env;    bit gen_trans_done = 0;//表示数据传输未开始    int unsigned test_drain_time_us = 200;//数据传输完后等待报告的时间    string name;        function new(virtual rt_interface intf,string name = "rt_base_test");        env = new(intf);        this.name = name;    endfunction        virtual task run();    $display("TEST %s started",name);        fork            env.run();            report();//调用report        join_none    endtask        task report();        wait(gen_trans_done == 1);        #(test_drain_time_us * 1us);        env.report(name);//调用env里的chk.report()进行report        $finish();//terminates the current test    endtask  function void set_trans_done(bit done = 1);//将set_trans_done信号置为1，表示数据传输已完成        gen_trans_done = done;    endfunctionendclass    class rt_single_ch_test extends rt_base_test;//单个通道测试        rand bit signed [4:0] src;        rand bit signed [4:0] dst;        rand int unsigned pkt_count =10;        constraint test_cstr {            soft pkt_count inside {[20:30]};            src inside {[0 : 15]};            dst inside {[0 : 15]};            }        function new(virtual rt_interface intf,string name = "rt_single_ch_test");            super.new(intf,name);        endfunction                    task run();            rt_packet p;            super.run();//调用父类的run，即执行env.run()，进行组件的例化等操作            this.randomize(); //randmoize self to get constrained data            for ( int cnt=0; cnt < pkt_count; cnt++) begin//随机10次                p = new( );                p.randomize() with {src == local::src; dst == local::dst; };                env.gen.put_pkt(p);            end            set_trans_done();        endtask            endclass    class rt_two_ch_test extends rt_base_test;        function new(virtual rt_interface intf,string name = "rt_two_ch_test");            super.new(intf,name);        endfunction    endclass        class rt_two_ch_same_chout_test extends rt_two_ch_test;            function new(virtual rt_interface intf,string name = "rt_two_ch_same_chout_test");                super.new(intf,name);            endfunction        endclass    class rt_multi_ch_test extends rt_base_test;//多通道测试        function new(virtual rt_interface intf,string name = "rt_multi_ch_test");            super.new(intf,name);        endfunction                task run();            rt_packet p;            super.run();            p = new();            p.set_members(0,3,'{8'h33,8'h77});            env.gen.put_pkt(p);            p = new();//每次put_pkt都需要new一下            p.set_members(0,5,'{8'h55,8'h66});            env.gen.put_pkt(p);            p = new();            p.set_members(3,6,'{8'h77,8'h88,8'h22});            env.gen.put_pkt(p);            p = new();            p.set_members(4,7,'{8'haa,8'hcc,8'h33});            env.gen.put_pkt(p);            set_trans_done();        endtask    endclass        class rt_full_ch_test extends rt_multi_ch_test;            function new(virtual rt_interface intf,string name = "rt_full_ch_test");                super.new(intf,name);            endfunction        endclassendpackage</code></pre><h2 id="4-5-仿真结果"><a href="#4-5-仿真结果" class="headerlink" title="4.5 仿真结果"></a>4.5 仿真结果</h2><p>执行two_ch_test命令：</p><blockquote><p>make rung TESTNAME=rt_two_ch_test</p></blockquote><p>同上，但存在交替发送的问题</p><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211231139467.png" width="100%" height="100%"></div>]]></content>
      
      
      <categories>
          
          <category> 数字IC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字前端 </tag>
            
            <tag> SystemVerilog验证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Verilog数字系统设计第(三)章总结</title>
      <link href="/2022/11/17/verilog-shu-zi-xi-tong-she-ji-di-san-zhang-zong-jie/"/>
      <url>/2022/11/17/verilog-shu-zi-xi-tong-she-ji-di-san-zhang-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="3-1-模块的结构"><a href="#3-1-模块的结构" class="headerlink" title="3.1 模块的结构"></a>3.1 模块的结构</h1><p>Verilog 的基本设计单元是“模块”( block)。一个模块是由两部分组成的：<u>一部分描述接口</u>，<u>另一部分描述逻辑功能，即定义输入是如何影响输出的。</u><br>Verilog 模块结构位于在 module和 endmodule声明语句之间。每个Verilog程序包括4个主要部分：<u>端口定义、I/O说明、内部信号声明、功能定义</u>。</p><h2 id="3-1-1-模块的端口定义"><a href="#3-1-1-模块的端口定义" class="headerlink" title="3.1.1 模块的端口定义"></a>3.1.1 模块的端口定义</h2><p>模块的端口声明了模块的输入输出口。其格式如下:</p><pre class=" language-verilog"><code class="language-verilog"><span class="token keyword">module</span>模块名<span class="token punctuation">(</span>口<span class="token number">1</span><span class="token punctuation">,</span>口<span class="token number">2</span><span class="token punctuation">,</span>口<span class="token number">3</span><span class="token punctuation">,</span>口<span class="token number">4</span><span class="token punctuation">,</span>…<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span></code></pre><p>在引用模块时其端口有两种方式连接:<br>一种是<strong>位置关联</strong></p><pre class=" language-verilog"><code class="language-verilog">模块名<span class="token punctuation">(</span>连接端口<span class="token number">1</span>信号名<span class="token punctuation">,</span>连接端口⒉信号名<span class="token punctuation">,</span>连接端口<span class="token number">3</span>信号名<span class="token punctuation">,</span>……<span class="token punctuation">)</span> <span class="token punctuation">;</span></code></pre><p>一种是<strong>名称关联</strong></p><pre class=" language-verilog"><code class="language-verilog">模块名<span class="token punctuation">(</span><span class="token punctuation">.</span>端口<span class="token number">1</span>名<span class="token punctuation">(</span>连接信号<span class="token number">1</span>名<span class="token punctuation">)</span><span class="token punctuation">,</span>端口<span class="token number">2</span>名<span class="token punctuation">(</span>连接信号<span class="token number">2</span>名<span class="token punctuation">)</span><span class="token punctuation">,</span>……<span class="token punctuation">)</span> <span class="token punctuation">;</span></code></pre><h2 id="3-1-2-模块内容"><a href="#3-1-2-模块内容" class="headerlink" title="3.1.2 模块内容"></a>3.1.2 模块内容</h2><p>模块的内容包括I/O说明、内部信号声明、功能定义。</p><ol><li><strong>I/O说明的格式</strong></li></ol><pre class=" language-verilog"><code class="language-verilog">输入口<span class="token punctuation">:</span><span class="token keyword">input</span><span class="token punctuation">[</span>信号位宽<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>端口名<span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">input</span><span class="token punctuation">[</span>信号位宽<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>端口名<span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">input</span><span class="token punctuation">[</span>信号位宽<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>端口名i<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//(共有i个输人口)</span>输出口<span class="token punctuation">:</span><span class="token keyword">output</span><span class="token punctuation">[</span>信号位宽<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>端口名<span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">output</span><span class="token punctuation">[</span>信号位宽<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>端口名<span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">output</span><span class="token punctuation">[</span>信号位宽<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>端口名j<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//(共有j个输出口)</span>输人<span class="token operator">/</span>输出口<span class="token punctuation">:</span><span class="token keyword">inout</span><span class="token punctuation">[</span>信号位宽<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>端口名<span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">inout</span><span class="token punctuation">[</span>信号位<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>端口名<span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">inout</span><span class="token punctuation">[</span>信号位宽<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>端口名k<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//(共有k个双向总线端口)</span></code></pre><ol start="2"><li><strong>内部信号声明</strong><br>wire和 reg类型变量的声明:</li></ol><pre class=" language-verilog"><code class="language-verilog"><span class="token keyword">reg</span>  <span class="token punctuation">[</span>width<span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">]</span>R变量<span class="token number">1</span><span class="token punctuation">,</span>R变量<span class="token number">2</span>……<span class="token punctuation">;</span><span class="token keyword">wire</span> <span class="token punctuation">[</span>width<span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">]</span>W变量l<span class="token punctuation">,</span>W变量<span class="token number">2</span>……<span class="token punctuation">;</span></code></pre><ol start="3"><li><strong>功能定义</strong><br>模块中最重要的部分是逻辑功能定义部分，有以下3种方法可在模块中产生逻辑。<br>(1)assign声明语句<br>如:</li></ol><pre class=" language-verilog"><code class="language-verilog"><span class="token keyword">assign</span> a<span class="token operator">=</span>b <span class="token operator">&amp;</span>c<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//两输入与门</span></code></pre><p>(2)实例元件<br>如:</p><pre class=" language-verilog"><code class="language-verilog"><span class="token keyword">and</span> <span class="token number">#2</span> <span class="token function">ul</span><span class="token punctuation">(</span> q，a，b <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//两输入与门</span></code></pre><p>(3))always块<br>如:</p><pre class=" language-verilog"><code class="language-verilog"><span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">posedge</span> clr<span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token keyword">begin</span>    <span class="token function">if</span><span class="token punctuation">(</span>clr<span class="token punctuation">)</span>q<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>en<span class="token punctuation">)</span>q<span class="token operator">&lt;=</span> d<span class="token punctuation">;</span><span class="token keyword">end</span></code></pre><p>采用assign语句是描述组合逻辑最常用的方法之一，而 always块既可用于描述组合逻辑,也可描述时序逻辑。</p><p><strong>always语句的执行顺序：</strong></p><ul><li>在<u>“always”模块内，逻辑是按照指定的顺序执行的</u>。“always”块中的语句称为“顺序语句”，因为它们是顺序执行的。所以, “ always”块也称为“<strong>过程块</strong>”。</li><li>两个或更多的“always”模块都是同时执行的，而模块内部的语句是顺序执行的。</li></ul><p><strong>与C语言的不同：</strong></p><ul><li><u>在Verilog模块中所有过程块(如:initial 块,always块),连续赋值语句,实例引用都是并行的</u>。</li><li>它们表示的是一种通过变量名互相连接的关系。</li><li>在同一模块中，assign语句、实例元件、always块语句这三者出现的先后顺序没有关系。</li><li><u>只有连续赋值语句assign和实例引用语句可以独立于过程块而存在于模块的功能定义部分</u>。</li></ul><h1 id="3-2-数据类型及其常量和变量"><a href="#3-2-数据类型及其常量和变量" class="headerlink" title="3.2 数据类型及其常量和变量"></a>3.2 数据类型及其常量和变量</h1>]]></content>
      
      
      <categories>
          
          <category> 数字IC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SystemVerilog学习笔记(十)</title>
      <link href="/2022/11/15/systemverilog-xue-xi-bi-ji-shi/"/>
      <url>/2022/11/15/systemverilog-xue-xi-bi-ji-shi/</url>
      
        <content type="html"><![CDATA[<div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211152049091.png " width="90%" height="90%"></div># 1. 覆盖率## 1.1 概述覆盖率是衡量验证完备性的一个通用词语，用来衡量设计中已经被测部分和未测部分的比例，通常被定义为已达到所需验证部分的百分比。## 1.2 分类### 按照覆盖率生成方法* 隐性生成* 显性生成### 按照覆盖率溯源* 从功能描述而来* 从设计实现而来功能覆盖率是显性的需要人为定义的覆盖率，而代码覆盖率则是隐性覆盖率这是因为仿真工具可以自动从RTL代码来生成。将上述两个分类的方式进行组合，那么可以将代码覆盖率、断言覆盖率以及功能覆盖率分别置入到不同的象限。<div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211151928901.png " width="40%" height="40%"></div>但是需要注意，目前有一个象限仍然处于研究阶段，没有隐性的可以从功能描述生成某种覆盖率的方法，这也是为什么功能覆盖率依然需要人为定义的原因。# 2. 两种主要覆盖率##  2.1 代码覆盖率* 跳转覆盖率：用来衡量寄存器跳转的次数(0→1,1→0)* 行覆盖率：用来衡量源代码哪些代码行被执行过，以此来指出哪些代码行没有被执行过* 分支覆盖率：分支覆盖率是用来对条件语句( if/else,case,?:)，指出其执行的分支轨迹。* 条件覆盖率：条件覆盖率是用来衡量一些布尔表达式中各个条件真伪判断的执行轨迹。* 状态机覆盖率：每个状态的进入次数，状态之间的跳转次数，以及多个状态的跳转顺序都可以由仿真工具记录下来。<h2 id="2-2-功能覆盖率"><a href="#2-2-功能覆盖率" class="headerlink" title="2.2 功能覆盖率"></a>2.2 功能覆盖率</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>我们无法通过代码覆盖率得知要求的功能是否被实现，需要显性地通过功能覆盖率与设计功能描述做映射，继而量化功能验证的进程。<br>创建功能覆盖率模型需要完成以下两个步骤:</p><ul><li>从功能描述文档提取拆分需要测试的功能点</li><li>将功能点量化为与设计实现对应的SV功能覆盖代码</li></ul><h3 id="覆盖组-covergroup"><a href="#覆盖组-covergroup" class="headerlink" title="覆盖组(covergroup)"></a>覆盖组(covergroup)</h3><ul><li>覆盖组与类相似，在一次定义以后便可以多次进行例化。</li><li>覆盖组含有覆盖点(coverpoint)、选项(option)、形式参数(argument)和可选触发(trigger event) </li><li>一个覆盖组包含了一个或者多个数据点，全都在同一时间采集。</li><li>覆盖组可以定义在类里，也可以定义在模块或者程序(program)中。</li></ul><pre class=" language-systemverilog"><code class="language-systemverilog">class xyz;    bit [3:0] m_;int m y;    bit m_z;    covergroup cov1 @m_z; ll embedded covergroup        coverpoint m_x;        coverpoint m_y;    endgroup    function new() ; cov1 = new ; endfunctionendclass</code></pre><ul><li>覆盖组可以采集任何可见的变量，比如程序或模块变量、接口信号或者设计中的任何信号</li><li>在类中的覆盖组也可以采集类的成员变量·覆盖组应该定义在适当的抽象层次上</li><li>对任何事务的采样都必须等到数据被待测设计接收到以后。</li><li>一个类也可以包含多个覆盖组，每个覆盖组可以根据需要将它们使能或者禁止</li></ul><pre class=" language-systemverilog"><code class="language-systemverilog">class MC;    logic [3:0] m_x;local logic m_z;bit m_e;    covergroup cv1 @(posedge clk); coverpoint m_x; endgroup     covergroup cv2 @m_e coverpoint m_z; endgroupendclass</code></pre><h3 id="覆盖点-coverpoint"><a href="#覆盖点-coverpoint" class="headerlink" title="覆盖点(coverpoint)"></a>覆盖点(coverpoint)</h3><h3 id="仓-bin"><a href="#仓-bin" class="headerlink" title="仓(bin)"></a>仓(bin)</h3><p>使用coverpoint 指定采样一个变量和表达式时，sv会创建很多的<strong>bin</strong>（仓）来记录每个数值被捕捉的次数。这些<strong>bin是衡量功能覆盖率的基本单位。</strong></p><h4 id="数值覆盖"><a href="#数值覆盖" class="headerlink" title="数值覆盖"></a>数值覆盖</h4><p>Covergroup的参数也可以被传递到bin的定义中</p><pre class=" language-systemverilog"><code class="language-systemverilog">covergroup cg (ref int ra,input int low, int high )@ (posedge clk) ;    coverpoint r {        bins good = { [low : high] };        bins bad[] = default;        }endgroup...int va, vb;cg c1 = new ( va, 0，50 ) ;cg c2 = new( vb,120,600 ) ;</code></pre><h4 id="值变化覆盖"><a href="#值变化覆盖" class="headerlink" title="值变化覆盖"></a>值变化覆盖</h4><p>除了可以覆盖数值，还可以覆盖数值的变化</p><pre class=" language-systemverilog"><code class="language-systemverilog">value1 =>value2value1 =>value3 =>value4 =>value5range_list1 =>range_list21,5 =>6,7trans__item [*repeat_range]</code></pre><p>除了使用=&gt;来表示相邻采样点的变化，也可以使用-&gt;来表示非相邻采样点的数值变化，在=&gt;序列后的下一个时序必须紧跟=&gt;序列的最后一个事件<br>3 [-&gt;3]<br>表示…=&gt;3…=&gt;3…=&gt;3<br>1=&gt;3 [-&gt;3]=&gt;5<br>表示1…=&gt;3…=&gt;3…=&gt;3 =&gt;5</p><p>与[-&gt; repeat range]类似的有[= repeatrange]也表示非连续的循环，只是与-&gt;有区别的在于，跟随-&gt;序列的下一次值变化可以发生在-&gt;结束后的任何时刻。<br>3 [= 2]<br>表示…=&gt;3…=&gt;3<br>1=&gt;3 [=2]=&gt;6<br>表示1…=&gt;3…=&gt;3…=&gt;6</p><h4 id="自动生成"><a href="#自动生成" class="headerlink" title="自动生成"></a>自动生成</h4><p>如果coverpoint没有指定任何bin，那么SV将会为其自动生成bin，遵循的原则是:</p><ul><li>如果变量是枚举类型，那么bin的数量是枚举类型的基数(所有枚举数值的合)</li><li>如果变量是整形(M位宽)，那么bin的类型将是2^M和auto_bin_max选项的较小值</li></ul><h4 id="通配应用"><a href="#通配应用" class="headerlink" title="通配应用"></a>通配应用</h4><ul><li>默认情况下，数值的变化可以针对四值类型变量进行覆盖，例如bin如果包含x或者z，则表示只有该变量对应位也为x或者z的时候，bin也才可以被采样到。</li><li>wildcard修饰符可以使得bin中包含x，z和?的数值都将用来表示0或者1，也就是通配符的意思</li></ul><pre class=" language-systemverilog"><code class="language-systemverilog">wildcard bins g12_15 = { 4 'b11??} ;g12_15可以用来表示12到15之间的值，即1100,1101,1110,1111</code></pre><h4 id="忽略类型和非法类型"><a href="#忽略类型和非法类型" class="headerlink" title="忽略类型和非法类型"></a>忽略类型和非法类型</h4><p>ignore_bins用来将其排除在有效统计的bin集合之外</p><pre class=" language-systemverilog"><code class="language-systemverilog">covergroup cg23;    coverpoint a {        ignore_bins ignore_vals = { 7,8} ;        ignore_bins ignore_trans = (1=>3=>5);        }endgroup</code></pre><p>illegal_bins用来指出采样到的数值为非法制，如果illegal_bins被采样到，那么仿真将报错</p><pre class=" language-systemverilog"><code class="language-systemverilog">covergroup cg3 ;    coverpoint b {    i1legal_bins bad_vals = { 1，2,3};    illegal_bins bad_trans = (4=>5=>6);    }endgroup</code></pre><h3 id="交叉覆盖率-cross"><a href="#交叉覆盖率-cross" class="headerlink" title="交叉覆盖率(cross)"></a>交叉覆盖率(cross)</h3><ul><li>covergroup可以在两个或者更多的coverpoint或者变量之间定义交叉覆盖率(cross coverage)</li><li>在对a和b产生交叉覆盖率之前，系统会先为它们隐性产生对应的coverpoint和bin，每个coverpoint都有16个自动产生的bin</li><li>两个coverpoint交叉以后将生成256个交叉的bin</li></ul><pre class=" language-systemverilog"><code class="language-systemverilog">bit [3:0] a, b;covergroup cov @(posedge clk) ;    axb : cross a, b;endgroup</code></pre><ul><li>除了系统会自动为交叉覆盖率生成bin以外，用户还可以自己定义交叉覆盖率的bin</li><li>binsof()的参数可以是coverpoint或者变量，表示对应的bin总和，可以利用binsof()对其结果做进—步的过滤</li></ul><pre class=" language-systemverilog"><code class="language-systemverilog">int i,j;    covergroup ct;        coverpoint i { bins i[]= { [O:1] } ; }        coverpoint j { bins j[] = { [0:1] } ; }        x1 : cross i,j;        x2 : cross i,j{        bins i_zero = binsof(i)intersect { o };        }endgroup</code></pre><h1 id="3-问答题"><a href="#3-问答题" class="headerlink" title="3. 问答题"></a>3. 问答题</h1><p><strong>请考虑对于目前的DUT (router)，要完成对它的功能测试，从接口时序、路由功能来看，需要考虑哪些功能和对应的测试场景?考虑路桑给出的接口插件文件(包含功能覆盖率定义和采样)，是否没有全部映射你给出的待测功能点?如果需要补全，你是否可以在给出的接口插件文件中，补全这部分功能覆盖率定义代码呢?请将补全的部分代码，粘贴到这里，并且在你的实验四的代码中，试运行去收集你关心的这部分功能覆盖率，在验收实验四的时候，给予必要的说明。</strong></p><p>答：需要考虑是否各个输入端口都能输入数据，各个输出端口是否都能接收到数据；以及不同输入端口并行发送数据、同一端口发送多个数据到不同输出端，同一输出端口接收来自不同输入端口发送的数据……</p><h1 id="可参考"><a href="#可参考" class="headerlink" title="可参考"></a>可参考</h1><p><a href="https://blog.csdn.net/m0_59670134/article/details/119606764?spm=1001.2101.3001.6650.3&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3-119606764-blog-123967971.pc_relevant_recovery_v2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3-119606764-blog-123967971.pc_relevant_recovery_v2&amp;utm_relevant_index=6">SV基础知识6—覆盖率收集_持续学习_ing的博客-CSDN博客_覆盖率收集</a></p>]]></content>
      
      
      <categories>
          
          <category> 数字IC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字前端 </tag>
            
            <tag> SystemVerilog验证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.31-11.13总结</title>
      <link href="/2022/11/13/10.31-11.13-zong-jie/"/>
      <url>/2022/11/13/10.31-11.13-zong-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="一、任务"><a href="#一、任务" class="headerlink" title="一、任务"></a>一、任务</h3><p>用ECC对 leon 系统里的SRAM进行加固</p><hr><h3 id="二、思路"><a href="#二、思路" class="headerlink" title="二、思路"></a>二、思路</h3><p>leon系统主要模块有<br>(1)Leon2 处理器核；(2)指令 SRAM 模块；(3)数据 SRAM 模块；(4)初始化指令 SRAM 模块</p><p>选取星载计算机系统中的数据 SRAM，将ECC电路加到数据SRAM上</p>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211131327595.png" width="500" height="300" title=" ">        <hr><h3 id="三、模块示意图"><a href="#三、模块示意图" class="headerlink" title="三、模块示意图"></a>三、模块示意图</h3>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211131414230.png" width="500" height="350" title=" ">        <hr><h3 id="四、仿真结果"><a href="#四、仿真结果" class="headerlink" title="四、仿真结果"></a>四、仿真结果</h3>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211131534173.png" width="1000" height="200" title=" ">                    <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211131544733.png" width="1200" height="100" title=" ">        ]]></content>
      
      
      <categories>
          
          <category> 数字IC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leon处理器 </tag>
            
            <tag> ECC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SystemVerilog学习笔记(九)</title>
      <link href="/2022/11/06/systemverilog-xue-xi-bi-ji-jiu/"/>
      <url>/2022/11/06/systemverilog-xue-xi-bi-ji-jiu/</url>
      
        <content type="html"><![CDATA[<p>本文思维导图如下：</p><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211071641178.png" width="90%" height="90%"></div><h1 id="1-线程控制"><a href="#1-线程控制" class="headerlink" title="1. 线程控制"></a>1. 线程控制</h1><h2 id="1-1-并行线程"><a href="#1-1-并行线程" class="headerlink" title="1.1 并行线程"></a>1.1 并行线程</h2><p>Verilog中与顺序线程begin…end相对的是并行线程fork…join。</p><h3 id="1-1-1创建线程"><a href="#1-1-1创建线程" class="headerlink" title="1.1.1创建线程"></a>1.1.1创建线程</h3><p>SV引入了两种新新的创建线程的方法，<u>fork…join_none</u>和<u>fork…join_any</u>。</p><ul><li><span style="background:rgba(136, 49, 204, 0.2)">fork…join</span><br>fork…join需要所有并行的线程都结束以后才会继续执行。</li><li><span style="background:rgba(136, 49, 204, 0.2)">fork…join_any</span><br>fork…join_any则会等到任何一个线程结束以后就继续执行。</li><li><span style="background:rgba(136, 49, 204, 0.2)">fork…join_none</span><br>fork…join_none则不会等待其子线程而继续执行。<div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211061457338.png " width="60%" height="60%"></div>实例<div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211061537443.png" width="60%" height="60%"></div></li></ul><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211061537770.png" width="60%" height="60%"></div><div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211061539318.png " width="60%" height="60%"></div><h3 id="1-1-2子程序等待-x2F-停止"><a href="#1-1-2子程序等待-x2F-停止" class="headerlink" title="1.1.2子程序等待/停止"></a>1.1.2子程序等待/停止</h3><p>需要注意的是，fork…join_any和fork. . .join_none继续执行后，其一些未完成的子程序仍将在后台运行。如果要等待这些子程序全部完成，或者停止这些子程序，可以使用<span style="background:rgba(3, 135, 102, 0.2)">wait fork</span>或者<span style="background:rgba(3, 135, 102, 0.2)">disable fork</span>。<br><strong>(1)wait fork</strong></p><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211061547271.png" width="60%" height="60%"></div>**(2)disable fork**<div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211061549290.png " width="60%" height="60%"></div>## 1.2 时序控制SV可以通过延迟控制或者事件等待来对过程块完成时序控制。### 1.2.1 延迟控制延迟控制即通过#来完成。&gt;#10 rega = regb;<h3 id="1-2-2-事件控制"><a href="#1-2-2-事件控制" class="headerlink" title="1.2.2 事件控制"></a>1.2.2 事件控制</h3><p>事件(event）控制即通过@来完成。</p><blockquote><p>@r rega = regb ;<br>@(posedge clock) rega = regb;</p></blockquote><h3 id="1-2-3-事件等待"><a href="#1-2-3-事件等待" class="headerlink" title="1.2.3 事件等待"></a>1.2.3 事件等待</h3><p>wait语句也可以与事件或者表达式结合来完成。</p><blockquote><p>real AOR[] ;<br>initial wait(AOR.size() &gt; 0) …. ;</p></blockquote><h1 id="2-进程间同步和通信"><a href="#2-进程间同步和通信" class="headerlink" title="2. 进程间同步和通信"></a>2. 进程间同步和通信</h1><p>测试平台中的所有线程都需要同步并交换数据。<br>一个线程等待另外一个，例如验证环境需要等待所有激励结束、比较结束才可以结束仿真。比如监测器需要将监测到的数据发送至比较器，比较器又需要从不同的缓存获取数据进行比较。</p><h2 id="2-1-事件"><a href="#2-1-事件" class="headerlink" title="2.1 事件"></a>2.1 事件</h2><ul><li>声明<br>可以通过event来声明一个命名event变量，并且去触发它。这个命名event可以用来控制进程的执行。</li><li>触发<br>可以通过-&gt;来触发事件。<br>其它等待该事件的进程可以通过@操作符或者wait()来检查event触发状态来完成。</li><li>等待<br>wait__order可以使得进程保持等待，直到在参数列表中的事件event按照顺序从左到右依次完成。如果参数列表中的事件被触发但是没有按照要求的顺序，那么会使得等待操作失败。<blockquote><p>wait_order ( a, b, c);</p><p>wait order( a, b, c ) else $display ( “Error: eventsout of order” );</p><p>bit success ;<br>wait order( a, b, c ) success = 1; else success = 0 ;</p></blockquote></li></ul><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211061714487.png" width="60%" height="60%"></div><h2 id="2-2-旗语"><a href="#2-2-旗语" class="headerlink" title="2.2 旗语"></a>2.2 旗语</h2><p>旗语从概念上讲，是一个容器。在创建旗语的时候，会为其分配固定的钥匙数量。使用旗语的进程必须先获得其钥匙，才可以继续执行。旗语的钥匙数量可以有多个，等待旗语钥匙的进程也可同时有多个。旗语通常用于互斥，对共享资源的访问控制，以及基本的同步</p><div align="center"><img src=" https://img-blog.csdnimg.cn/8bbdaa8efccc4e36b6ece797b80c605a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASSBDIGUgcg==,size_20,color_FFFFFF,t_70,g_se,x_16" width="60%" height="60%"></div>### 2.2.1用法* 创建旗语，并为其分配钥匙的方式如下:&gt;semaphore sm;&gt;sm = new ();<ul><li><p>创建一个具有固定钥匙数量的旗语:</p><blockquote><p>new (N = 0)</p></blockquote></li><li><p>从旗语那里获取一个或多个钥匙(阻塞型) : </p><blockquote><p>get (N = 1)</p></blockquote></li><li><p>将一个或多个钥匙返回到旗语中:</p><blockquote><p>put (N = 1)</p></blockquote></li><li><p>尝试获取一个或多个钥匙而不会阻塞(非阻塞型) : </p><blockquote><p>try_get (N = 1)</p></blockquote></li></ul><h3 id="2-2-2基本操作"><a href="#2-2-2基本操作" class="headerlink" title="2.2.2基本操作"></a>2.2.2基本操作</h3><h4 id="senmaphore-new"><a href="#senmaphore-new" class="headerlink" title="senmaphore: :new()"></a>senmaphore: :new()</h4><p>new ())的原型如下:</p><blockquote><p>function new (int keyCount = 0) ;</p></blockquote><p>keyCount指定最初分配给旗语的钥匙数目。keyCount的默认值为0。当更多钥匙放入旗语时，钥匙数目可以超出初始时的keyCount数量，而不是删除。</p><h4 id="semaphore-put"><a href="#semaphore-put" class="headerlink" title="semaphore: :put()"></a>semaphore: :put()</h4><p>put ()方法用于将钥匙数量返回给旗语。<br>put ()的原型如下:</p><blockquote><p>function void put (int keyCount = 1) ;</p></blockquote><p>keycount指定返回到旗语的钥匙数量。默认值为1。调用semaphore.put ()函数时，指定数量的钥匙将返回到旗语。如果其它进程已经在等待旗语，则该进程应在有足够数量钥匙的情况下返回。</p><h4 id="semaphore-get"><a href="#semaphore-get" class="headerlink" title="semaphore: :get()"></a>semaphore: :get()</h4><p>get ()方法用于从旗语中获取指定数量的钥匙。get ()的原型如下:</p><blockquote><p>task get (int keycount = 1) ;</p></blockquote><p>keyCount指定从旗语获取所需的钥匙数，默认值为1。<u>如果指定数量的钥匙可用，则该方法返回并继续执行。如果指定数量的钥匙不足，进程将阻塞，直到钥匙数目充足。</u>旗语的等待队列是<span style="background:rgba(240, 200, 0, 0.2)">先进先出(FIFO)</span>，即先排队等待旗语的将优先得到钥匙。</p><h4 id="semaphore-try-get"><a href="#semaphore-try-get" class="headerlink" title="semaphore : :try_get()"></a>semaphore : :try_get()</h4><p>try get ()方法用于从信号量中获取指定数量的钥匙，但不会被阻塞。try_get ()的原型如下:</p><blockquote><p>function int try_get (int keyCount = 1) ;</p></blockquote><p>keyCount指定从旗语处获取所需的钥匙数目，默认值为1。<u>如果指定数量的钥匙可用，则该方法返回正数并继续执行。如果指定数量的钥匙不足，则该方法返回0。</u></p><h3 id="2-2-3实例"><a href="#2-2-3实例" class="headerlink" title="2.2.3实例"></a>2.2.3实例</h3><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211061715075.png" width="100%" height="100%"></div><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211061715493.png" width="100%" height="100%"></div>## 2.3 信箱信箱mailbox可以使得进程之间的信息得以交换，数据可以由一个进程写入信箱，再由另外一个进程获得。<div align="center"><img src=" https://img-blog.csdnimg.cn/c6469e7241f04c10affb418009c08e36.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASSBDIGUgcg==,size_20,color_FFFFFF,t_70,g_se,x_16" width="60%" height="60%"></div>信箱在创建时可以限制其容量，或者不限制。<u>当信箱容量写满时，后续再写入的动作会被挂起，直到信箱的数据从中读取，使得信箱有空间以后才可以继续写入。</u>不限制容量的信箱则不会挂起写入信箱的动作。### 2.3.1 内建方法#### new()new()用于创建信箱。<u>可以在创建信箱的时候限定或者不限定其大小</u>。<u>默认情况下，如果不传入参数，bound默认值为0，表示不限定信箱大小，如果传入的数值大于0，那么表示信箱的最大容量</u>。bound应为正数，如果未负数的话，系统会提示警告和出现无法预期的行为。&gt;function new (int bound = 0) ;<h4 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h4><p>put()会将信息按照FIFO的顺序写入到信箱中，如果信箱此时已满，则put()任务会挂起，直到信箱有新的空间可以容纳消息。</p><h4 id="try-put"><a href="#try-put" class="headerlink" title="try_put()"></a>try_put()</h4><p>try put()试着写入信箱但不会阻塞。try put()也会按照FIFO顺序写入信箱，不会发生阻塞。如果信箱已满，则写入失败，返回0;如果信箱未满，则写入成功，返回1。</p><h4 id="get-x2F-peek"><a href="#get-x2F-peek" class="headerlink" title="get()/peek()"></a>get()/peek()</h4><p>获取信息: get()同时会取出数据，peek()不会取出数据。get()会将信息从信箱中取出，如果信箱此时为空，则get()任务会挂起，直到信箱中有消息可以读取，任务才会返回。该方法会将读取到的消息从信箱中移除。</p><h4 id="try-get-x2F-try-peek"><a href="#try-get-x2F-try-peek" class="headerlink" title="try_get()/try_peek()"></a>try_get()/try_peek()</h4><p>试着从信箱取出数据但不会阻塞。try get()也会将信息从信箱中取出，只是该函数不会发生阻塞。如果信箱为空，则读取失败，返回0;如果信箱不为空，则读取成功，返回1。该方法也会将读取到的消息从信箱中移除。</p><h4 id="num"><a href="#num" class="headerlink" title="num()"></a>num()</h4><p>num()会返回信箱目前的消息数目。可以结合num()与get()或者put()，防止get()/put()方法在信箱为空或者为满的时候被阻塞。</p><h3 id="2-3-2-实例"><a href="#2-3-2-实例" class="headerlink" title="2.3.2 实例"></a>2.3.2 实例</h3><p>mailbox <span style="background:rgba(240, 200, 0, 0.2)">#(int)</span> mb;//声明mailbox句柄，并且指明该mailbox中<span style="background:rgba(240, 200, 0, 0.2)">只能存放int类型</span>的数据</p><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211070937007.png" width="90%" height="90%"></div><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211070938538.png" width="90%" height="90%"></div><h2 id="2-4虚方法"><a href="#2-4虚方法" class="headerlink" title="2.4虚方法"></a>2.4虚方法</h2><p>给pringtB添加关键词virtual，P1扩大查找范围，扩大到子类对象里面。如果子类里面有同名的方法，若有，调用子类里面同名的方法（以子类的实现优先）。<br>子类不添加virtual无影响，父类添加即可。</p><div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211071005100.png " width="60%" height="60%"></div># 3. 类型转换## 3.1 静态转换静态转换操作符不对转换值进行检查。转换时指定目标类型，并在要转换的表达式前加上单引号即可。Verilog对整数和实数类型，或者不同位宽的向量之间进行隐式转换。&gt;int i;&gt;real r;&gt;i = int ' (10.0 - 0.1); //cast is optional&gt;r= real'(42);// cast is optional## 3.2 动态转换我们总是可以将子类的句柄赋值给父类的句柄。但是在我们将父类的句柄赋值给子类的句柄时，编译将会报错。$cast()系统函数<u>可以将父类句柄转换为子类句柄</u>，只要该父类句柄指向的是一个子类的对象。&gt;function int $cast( singular dest_var, singularsource_exp ) ;<p>或者</p><blockquote><p>task $cast( singular dest_var, singular source_exp );</p></blockquote><h1 id="4-问答题"><a href="#4-问答题" class="headerlink" title="4. 问答题"></a>4. 问答题</h1><p><strong>1. 用bit key =0来实现的类似旗语(semaphore)的功能，来保护对共享资源的访问，是否有不安全的地方?示例代码如下(包含自然语言表征)。如果有不安全的地方，请用文字表述，并且对以下代码进行修改，并且进行测试、编译和仿真打印消息。</strong></p><blockquote><p>bit key = 1;//创建钥匙<br>task get_key();<br>wait(key &gt; 0);<br>key = 0;//获得钥匙<br>…//省略对于共享资源的处理<br>key = 1; /还回钥匙<br>endtask</p></blockquote><p><span style="background:rgba(240, 200, 0, 0.2)">答</span>：当多个task并行执行时，只要key=1，满足wait(key&gt;0)即可执行，无法实现资源同时只能被指定个数的进程访问的目的。</p><p><strong>2. SV的原生旗语semaphore在例化以后，并不能从其获取哪一个对象（字符串stringID)获取了钥匙，那么请你将semaphore封装到一个类中，重新定义get()/put(方法，并且通过最后的一个打印函数来得知当前获取钥匙的string ID是谁?示例代码大致如下，请完成提示需要完成的地方，对你的代码进行编译和仿真，展示你的代码和仿真的打印消息。</strong><br><span style="background:rgba(240, 200, 0, 0.2)">答</span>：sv代码如下</p><pre class=" language-systemverilog"><code class="language-systemverilog">module tb;class smart_key;    semaphore s;//创建旗语    string holder;    function new(N= 1);        s = new(N);//分配1把钥匙    endfunction        task get(int N= 1,string str);//请添加需要的参数，并且实现该方法        s.get();//拿到钥匙        holder = str;        #1ns;        //$display("%0t: %s get the key",$time,str);    endtask    task put(int N= 1,string str);//请添加需要的参数，并且实现该方法        s.put();//放回钥匙        #1ns;        //$display("%0t: %s put the key",$time,str);    endtask    function void print_key_holders();//请事先该方法，使其能够打印出当前获得钥匙的ID        $display("%0t: now %s hold the key",$time,holder);    endfunction        endclass: smart_key    initial begin    smart_key skey = new();        string string1 = "A";    string string2 = "B";    string string3 = "C";        fork         begin             skey.get(1,string1);            skey.print_key_holders();            skey.put(1,string1);        end        begin             skey.get(1,string2);            skey.print_key_holders();            skey.put(1,string2);        end        begin             skey.get(1,string3);            skey.print_key_holders();            skey.put(1,string3);        end    joinend    endmodule: tb</code></pre><p><strong>仿真结果：</strong></p><blockquote><p>1000: now A hold the key<br>2000: now B hold the key<br>3000: now C hold the key</p></blockquote><p><strong>3. 我们在使用信箱mailbox时，如何可以限定其容量为8，并且只能存放string类型呢?那么，是否类似的方法也可以限定一个存放字符串的队列其最大容量为8呢?</strong><br><span style="background:rgba(240, 200, 0, 0.2)">答</span>：声明方法如下</p><blockquote><p>mailbox #(int) mb;<br>mb = new(8);</p></blockquote><p>队列空间是动态的，不能限定其最大容量。</p><p><strong>写的不错，可以参考</strong>：<a href="https://blog.csdn.net/qq_41337361/article/details/122723681?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-122723681-blog-78677789.pc_relevant_aa2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-122723681-blog-78677789.pc_relevant_aa2&amp;utm_relevant_index=2">SV学习笔记—线程之间的通信（事件event、信箱mailbox、旗语semaphore）_Verification_White的博客-CSDN博客_sv event</a></p>]]></content>
      
      
      <categories>
          
          <category> 数字IC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字前端 </tag>
            
            <tag> SystemVerilog验证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SystemVerilog实验(一)</title>
      <link href="/2022/11/05/systemverilog-shi-yan-yi/"/>
      <url>/2022/11/05/systemverilog-shi-yan-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="一、实验要求"><a href="#一、实验要求" class="headerlink" title="一、实验要求"></a>一、实验要求</h1><p><a href="https://shimo.im/docs/axk6MwD8D8IpFeqr/read">路科验证V0课程实验指导 (shimo.im)</a></p><h1 id="二、实验代码"><a href="#二、实验代码" class="headerlink" title="二、实验代码"></a>二、实验代码</h1><h2 id="router-io-sv"><a href="#router-io-sv" class="headerlink" title="router_io.sv"></a>router_io.sv</h2><pre class=" language-systemverilog"><code class="language-systemverilog">//定义接口，将复位信号(test.sv产生)送入DUT(router.v)interface router_io(input bit clock);    logic reset_n;    logic [15:0] din;    logic [15:0] frame_n;    logic [15:0] valid_n;    logic [15:0] dout;    logic [15:0] valido_n;    logic [15:0] busy_n;    logic [15:0] frameo_n;endinterface</code></pre><h2 id="test-sv"><a href="#test-sv" class="headerlink" title="test.sv"></a>test.sv</h2><pre class=" language-systemverilog"><code class="language-systemverilog">//产生复位信号,复位时，reset_n为低电平,frame_n和valid_n为高电平module test(router_io intf);    initial begin     #2 intf.reset_n = 1'b1;    #2 intf.reset_n = 1'b0;    #2 intf.reset_n <= 1'b1;//复位信号持续2  end  initial begin        reset();//调用reset产生复位信号    end        task reset();    //@(posedge intf.clk or negedge intf.reset_n);    @(negedge intf.reset_n);      intf.din <= 0;          intf.frame_n <= '1;          intf.valid_n <= '1;           repeat(15) @(intf.clock);//复位后至少等待15个时钟周期后发送数据    endtaskendmodule</code></pre><h2 id="router-test-top-sv"><a href="#router-test-top-sv" class="headerlink" title="router_test_top.sv"></a>router_test_top.sv</h2><pre class=" language-systemverilog"><code class="language-systemverilog">//产生时钟//例化另外三个文件`timescale 1ns/1psmodule router_test_top;        bit clk;  parameter cicle = 10;    initial begin        forever #(cicle/2) clk = !clk;//产生周期为10的时钟    end        router_io intf(                    .clock(clk)                    );//例化接口                        test tb(intf);//例化test，产生复位信号        router dut(                .clock   (intf.clock   ),                .reset_n (intf.reset_n ),                .din     (intf.din     ),                .frame_n (intf.frame_n ),                .valid_n (intf.valid_n ),                .dout    (intf.dout    ),                .valido_n(intf.valido_n),                .busy_n  (intf.busy_n  ),                .frameo_n(intf.frameo_n)                );//例化router为DUTendmodule</code></pre><h1 id="三、硬件层次"><a href="#三、硬件层次" class="headerlink" title="三、硬件层次"></a>三、硬件层次</h1><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211061008531.png"></p><h1 id="四、仿真结果"><a href="#四、仿真结果" class="headerlink" title="四、仿真结果"></a>四、仿真结果</h1><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211061003883.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数字IC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字前端 </tag>
            
            <tag> SystemVerilog验证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SystemVerilog课程进度总览（持续更新）</title>
      <link href="/2022/11/05/systemverilog-ke-cheng-jin-du-zong-lan-chi-xu-geng-xin/"/>
      <url>/2022/11/05/systemverilog-ke-cheng-jin-du-zong-lan-chi-xu-geng-xin/</url>
      
        <content type="html"><![CDATA[<p><a href="http://daipeihong.top/2022/10/04/systemverilog-ke-cheng-bi-ji-san/">一、初步初步使用module和initial实现初步激励</a><br>初步TestBench平台概览</p>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211052041415.png" width="500" height="300" title=" ">        <p><a href="http://daipeihong.top/2022/10/04/systemverilog-ke-cheng-bi-ji-si/">二、继续改进</a><br><span style="background:rgba(5, 117, 197, 0.2)">改进1</span>：将initial过程块改造为task、将前一次的两个initial begin end 语句封装进task任务中<br><span style="background:rgba(5, 117, 197, 0.2)">改进2</span>：任意source_channl向任意destination_channl发送数据</p><p>初步TestBench平台概览</p>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211052041415.png" width="500" height="300" title=" ">        <p><a href="http://daipeihong.top/2022/10/17/systemverilog-ke-cheng-bi-ji-wu/">三、构建generator</a><br><span style="background:rgba(5, 117, 197, 0.2)">改进1</span>：stimulator只发送数据，构建generator产生数据发送给stimulator<br><span style="background:rgba(5, 117, 197, 0.2)">改进2</span>：来自于不同的source chnl可以并行发送<br><span style="background:rgba(5, 117, 197, 0.2)">改进3</span>：增加接口(interface)<br><span style="background:rgba(5, 117, 197, 0.2)">改进4</span>：增加组件monitor，监测输入数据和输出数据 </p><p>初步TestBench平台概览</p>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211171916069.png" width="500" height="300" title=" ">        <p><a href="http://daipeihong.top/2022/10/24/systemverilog-ke-cheng-bi-ji-liu/">四、stimulator、generator、monitor改为类、增加checker组件</a><br><span style="background:rgba(5, 117, 197, 0.2)">改进1</span>：将数据传输从结构体改造为类<br><span style="background:rgba(5, 117, 197, 0.2)">改进2</span>：将drive_chnl任务的输入改为类<br><span style="background:rgba(5, 117, 197, 0.2)">改进3</span>：将stimulator、generator、monitor改为类<br><span style="background:rgba(5, 117, 197, 0.2)">改进4</span>：增加checker组件</p><p>TestBench平台概览</p>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211171924107.png" width="500" height="300" title=" ">        <p><a href="http://daipeihong.top/2022/10/29/systemverilog-ke-cheng-bi-ji-qi/">五、利用类的继承，将多种test包含进base test中</a><br><span style="background:rgba(5, 117, 197, 0.2)">改进1</span>：利用类的继承，将多种test包含进base test中<br><span style="background:rgba(5, 117, 197, 0.2)">改进2</span>：增加数据传输完成信号、checker的判断、test name<br><span style="background:rgba(5, 117, 197, 0.2)">改进3</span>：package封装与makefile的使用<br>TestBench平台概览</p>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211171924107.png" width="500" height="300" title=" ">        <p><a href="http://daipeihong.top/2022/11/01/systemverilog-ke-cheng-bi-ji-ba/">六、利用随机产生数据</a><br><span style="background:rgba(5, 117, 197, 0.2)">改进1</span>：改用samephore判断chnl是否被占用<br><span style="background:rgba(5, 117, 197, 0.2)">改进2</span>：对single chnl添加随机<br>TestBench平台概览同上</p><p><a href="http://daipeihong.top/2022/11/23/systemverilog-ke-cheng-bi-ji-shi/">七、mailbox的使用</a><br><span style="background:rgba(5, 117, 197, 0.2)">改进1</span>：将generator、monitor中的队列改为mailbox<br><span style="background:rgba(5, 117, 197, 0.2)">改进2</span>：将generator、monitor中的mailbox设置上限为1<br><span style="background:rgba(5, 117, 197, 0.2)">改进3</span>：将数据从genarator到stimulator的传递改为mailbox句柄的传递<br><span style="background:rgba(5, 117, 197, 0.2)">改进4</span>：使用关联数组进行test用例的选择<br>TestBench平台概览同上</p><p><a href="http://daipeihong.top/2022/11/22/systemverilog-ke-cheng-bi-ji-jiu/">八、改进测试用例</a><br><span style="background:rgba(5, 117, 197, 0.2)">改进1</span>：从generator收到的数据按照chnl编号分发到16个mailbox里<br><span style="background:rgba(5, 117, 197, 0.2)">改进2</span>：完善two_ch_same_chout_test、full_ch_test<br><span style="background:rgba(5, 117, 197, 0.2)">改进3</span>：完善各test父类与子类的关系<br><span style="background:rgba(5, 117, 197, 0.2)">改进4</span>：完善rt_full_ch_test<br>TestBench平台概览同上</p><p>TODO：<br>[[SystemVerilog课程笔记(十一)]]</p>]]></content>
      
      
      <categories>
          
          <category> 数字IC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字前端 </tag>
            
            <tag> SystemVerilog验证 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SystemVerilog课程笔记(八)</title>
      <link href="/2022/11/01/systemverilog-ke-cheng-bi-ji-ba/"/>
      <url>/2022/11/01/systemverilog-ke-cheng-bi-ji-ba/</url>
      
        <content type="html"><![CDATA[<h1 id="1-改用samephore判断chnl是否被占用"><a href="#1-改用samephore判断chnl是否被占用" class="headerlink" title="1. 改用samephore判断chnl是否被占用"></a>1. 改用samephore判断chnl是否被占用</h1><h1 id="2-对single-chnl添加随机"><a href="#2-对single-chnl添加随机" class="headerlink" title="2. 对single chnl添加随机"></a>2. 对single chnl添加随机</h1><h2 id="2-1-改造后的rt-test-pkg-sv"><a href="#2-1-改造后的rt-test-pkg-sv" class="headerlink" title="2.1 改造后的rt_test_pkg.sv"></a>2.1 改造后的rt_test_pkg.sv</h2><pre class=" language-systemverilog"><code class="language-systemverilog">package rt_test_pkg;class rt_packet;  rand bit [3:0] src;  rand bit [3:0] dst;  rand bit [7:0] data [];  constraint pkg_cstr{    soft data.size inside{[1:32]};    foreach(data[i])        soft data[i] == (src << 4) + i;    }  function new();  endfunction  function void set_members(bit [3:0]src, bit [3:0]dst, bit[7:0]data []);    this.src = src;    this.dst = dst;    this.data = data;  endfunction  function string sprint();//打印packet信息的函数    sprint = {sprint , $sformatf("src = %0d\n",src)};    sprint = {sprint , $sformatf("dst = %0d\n",dst)};    sprint = {sprint , $sformatf("data_length = %0d\n",data.size())};    foreach(data[i])        sprint = {sprint , $sformatf("data[%0d] = 'h%0x\n", i, data[i])};  endfunction  function bit compare(rt_packet p);//输入exp_pkt        if(dst == p.dst && data == p.data)            compare = 1;        else             compare = 0;  endfunctionendclass//********************************** stimulator **********************************//class rt_stimulator;    virtual rt_interface intf;//class里的接口不能用端口的方式描述，需要添加virtual关键字，在类里面用接口的指针//for debug purpose from waveform//定义检测状态的变量  typedef enum {DRV_RESET,DRV_IDLE,DRV_ADDR,DRV_PAD,DRV_DATA} drv_state_t;  drv_state_t dbg_state;    byte unsigned dbg_din_chnl0_data;   //int src_chnl_status[int];  //关联数组，后面int：src_chnl的number；前面int：dest_chnl的Number ？？  semaphore src_chnl_status[16];//16个chnl的钥匙    function new();    foreach(src_chnl_status[i])        src_chnl_status[i] = new(1);  endfunction//generator传送p给stimulator  rt_packet pkts[$];//定义stimulator中的的队列pkts  function void put_pkt(input rt_packet p);    pkts.push_back(p);//将generator中传过来的p放入stimulator的pkts中(在pkts队列尾插入p)  endfunctiontask run();    fork        drive_reset(); //reset动作        get_packet_and_drive(); //drive_chnl动作    join_noneendtask    task drive_reset();//reset    forever begin        @(negedge intf.reset_n);        dbg_state <= DRV_RESET;        intf.din <= 0;        intf.frame_n <= '1;//等效16'hFFFF        intf.valid_n <= '1;    endendtask// 发送数据task get_packet_and_drive();//drive_chnl    //rt_packet_t p;  @(negedge intf.reset_n);  repeat(10) @(posedge intf.clock);//延迟10个时钟周期  forever begin    automatic rt_packet p;//声明一个动态的    wait(pkts.size()>0);    p = pkts.pop_front();//将p从队列pkts里面取出    fork//后台触发线程，触发线程在后台运行，继续执行剩下内容        begin            wait_src_chnl_avail(p);//判断src chnl是否被占用，是否需要等待            drive_chnl(p);//从P中拿到发送端口，目标端口，发送数据            set_src_chnl_avail(p);        end    join_none    endendtasktask  wait_src_chnl_avail(rt_packet p);//判断src chnl是否被占用，是否需要等待    src_chnl_status[p.src].get(1);//拿到钥匙    //if(!src_chnl_status.exists(p.src))//src_chnl_status关联数组里面不含p.src，(表示未占用任何dest_chnl,一开始不满足）    //src_chnl_status[p.src] = p.dst;//表示当前正在使用src_chnl,对应dest_chnl就是p.dst（p.src端口在向p.dst端口发送数据）    //else if(src_chnl_status[p.src] >= 0)//如果在给0,1,2...dest_chnl发送数据（被占用），需要等待,，否则不需要等待    //wait(src_chnl_status[p.src] == -1);//直到src_chnl_status[p.src] == -1(自定义的dest_chnl端口数之外任意的数，表示未占用任何dest_chnl)endtaskfunction  set_src_chnl_avail(rt_packet p);    src_chnl_status[p.src].put(1);//还钥匙    //src_chnl_status[p.src] = -1;//如果chnl发送完后，把src_chnl置回来(自定义的dest_chnl端口数之外任意的数，表示未占用任何dest_chnl)endfunctiontask  drive_chnl(rt_packet p);  $display("@%0t:[DRV] src_chnl[%0d] & dest_chnl[%0d] data trans started with packet: \n%s",$time,p.src,p.dst,p.sprint());    // drive address phase 输入地址位阶段for(int i=0;i<4;i++)begin  //4 clock  @(posedge intf.clock);  dbg_state <=DRV_ADDR;  intf.din[p.src] <= p.dst[i];  intf.valid_n[p.src] <= $urandom_range(0,1);//valid_n在din的地址输入时间段可为任意值x  intf.frame_n[p.src] <= 1'b0;//frame_n需要为低end    // drive pad phase //隔离阶段  for (int i=0;i<5;i++)begin  //5 clock    @(posedge intf.clock);    dbg_state <=DRV_PAD;    intf.din[p.src] <= 1'b1;    intf.valid_n[p.src] <= 1'b1;//valid_n需为高电平    intf.frame_n[p.src] <= 1'b0; //frame_n需为低电平  end    // drive data phase 传输数据阶段  foreach(p.data[id])begin    for(int i=0;i<8;i++)begin     @(posedge intf.clock);      dbg_state <=DRV_DATA;      dbg_din_chnl0_data <= p.data[id];      intf.din[p.src] <= p.data[id][i];      intf.valid_n[p.src] <=1'b0;      intf.frame_n[p.src] <= (id == p.data.size()-1 && i == 7) ? 1'b1 : 1'b0;//packet最后一位输出数据时frameo_n为高    end  end// drive idle phase 闲置（没有数据传输）阶段  @(posedge intf.clock);  dbg_state <=DRV_IDLE;  dbg_din_chnl0_data <= 0;  intf.din[p.src] <= 1'b0;  intf.valid_n[p.src] <= 1'b1;  intf.frame_n[p.src] <= 1'b1;  $display("@%0t: [DRV]src_chnl[%0d],dest_chnl[%0d] data trans finished",$time,p.src,p.dst);endtaskendclass//********************************** generator **********************************//class rt_generator;//generator产生数据交给stimulator  rt_packet pkts[$];//定义队列  task put_pkt(input rt_packet p);    //wait(pkts.size()=0)        pkts.push_back(p);//将p放入队列pkts里面（在pkts队列尾插入p）  endtask    task get_pkt(output rt_packet p);    wait(pkts.size() >0 )//队列不为空      p = pkts.pop_front();//将p从队列pkts里面取出，提取队列首元素  endtask  //generate a random packet  function void gen_pkt(int src = -1, int dst = -1);  endfunction    task run();        //TODO  endtask    endclass//********************************** monitor **********************************//class rt_monitor;virtual rt_interface intf;    rt_packet in_pkts[16][$];    rt_packet out_pkts[16][$];    task run();    fork        mon_chnls();    join_noneendtask    task mon_chnls;    foreach(in_pkts[i]) begin        automatic int chid = i;        fork        mon_chnl_in(chid);//每个输入端口均调用mon_chnl_in任务，监测数据输入        mon_chnl_out(chid);//每个输出端口均调用mon_chnl_out任务，监测数据输入        join_none    endendtask    task  mon_chnl_in (bit[3:0]id);//监测数据输入的任务    rt_packet pkt;//定义结构体变量    forever begin    //clear content for the same struct variable。清除pkt    pkt = new();    pkt.src = id;//第id个输入端口    //monitor specific channel-in data and put it into the queue    // monitor address phase    @(negedge intf.frame_n[id]);//监测frame_n下降沿(frame_n由时钟驱动)    for(int i=0; i<4; i++)begin        @(negedge intf.clock);//frame_n下降沿后监测4个clk negedge        pkt.dst[i]= intf.din[id];        end        $display ("@%0t: [MON] src_chn1[%0d] & dest_chn1[%0d] data trans started",$time,pkt.src,pkt.dst);    //pass pad phase 不考虑pad阶段是否满足协议要求    repeat(5) @(negedge intf.clock);    do begin        pkt.data = new [pkt.data.size + 1](pkt.data);//创建动态数组并复制pkt.data        for ( int i=0; i<8; i++) begin            @(negedge intf.clock); //在8个clk negedge监测8bit数据            pkt.data[pkt.data.size-1][i] = intf.din[id];        end    end while(!intf.frame_n[id]);    in_pkts[id].push_back(pkt);//将monitor拿到的数据放入in_pkts    $display("@%0t:[MON] CH_IN src_chnl[%0d] &dest_chnl[%0d ] finished with packet: \n%s",$time,pkt.src,pkt.dst,pkt.sprint());    endendtasktask  mon_chnl_out(bit[ 3:0]id);//监测数据输出的任务    rt_packet pkt;    forever begin        //clear content for the same struct variable        pkt = new();        pkt.dst = id;        @(negedge intf.frameo_n[id]);        $display( "@%0t: [MON] CH_OUT dest_chn1[%0d] data trans started",$time,pkt.dst);        do begin        pkt.data = new [ pkt.data.size + 1](pkt.data);        for(int i=0;i<8; i++) begin            @(negedge intf.clock iff !intf.valido_n[id]);//clock与valido_n信号同时为低            pkt.data[pkt.data.size-1][i]= intf.dout [id];        end    end while(!intf.frameo_n[id]);    // NOTE : src is from data format (user defined)    pkt.src = pkt.data[0][7:4];//高4位    out_pkts[id].push_back(pkt);    $display("@%0t: [MON] CH_OUT dest_chn1[%0d] data finished woth packet : \n %s",$time,pkt.dst,pkt.sprint());    //monitor specific channel-out data and put it into the queue    endendtaskendclass//********************************** checker **********************************//class rt_checker;    int unsigned compare_count;    int unsigned error_count;        function new();//赋初值，可有可无，整形变量默认初始值为0        compare_count = 0;        error_count = 0;    endfunction        rt_packet exp_out_pkts[16][$];    rt_monitor mon;        task run();    foreach(exp_out_pkts[i])begin        automatic int chid = i;        fork            do_routing(chid);            do_compare(chid);        join_none        end    endtask        task do_routing(bit[3:0] id);//将monitor中采样到的输入数据放入期望的输出端队列中        rt_packet pkt;        forever begin            wait(mon.in_pkts[id].size > 0);            pkt = mon.in_pkts[id].pop_front();//从monitor中拿到in_pkts队列数据放入pkt            exp_out_pkts[pkt.dst].push_back(pkt);//将pkt数据放入对应期望的dest_chnl            end    endtask         task do_compare(bit[3:0] id);//比较采集的实际输出与期望输出        rt_packet exp_pkt, act_pkt;        forever begin            wait(mon.out_pkts[id].size > 0 && exp_out_pkts[id].size > 0);//实际采样数据与期望数据都有值            act_pkt = mon.out_pkts[id].pop_front();//实际数据为monitor采样的输出数据            exp_pkt = exp_out_pkts[id].pop_front();//期望数据为monitor采样到的输入数据            if(act_pkt.compare(exp_pkt))begin//如果exp_pkt与act_pkt比较成功，返回1                $display("[CHK] data compare success with packet : \n%s",exp_pkt.sprint());            end            else begin                $display("[CHK] data compare failure with actual packet : \n%s \nexpected packet : \n%s", act_pkt.sprint(), exp_pkt.sprint());                error_count++;            end                compare_count++;        end    endtask         function void report(string name);        $display("TOTAL COMPARING %0d times",compare_count);        if(!error_count && check_data_buffer())//判断无误且二者有数据            $display("TEST [%s] PASSED!",name);        else begin            $display("TEST [%s]FAILED!",name);            $display("TOTAL ERROR %0d times", error_count);        end    endfunction        function bit check_data_buffer();        check_data_buffer = 1;        foreach(exp_out_pkts[id])begin             if(exp_out_pkts[id].size != 0)begin//exp_out_pkts必须有数据                check_data_buffer = 0;                $display("exp_out_pkts[%0d] buffer size is not 0(still with %0d data)",id,exp_out_pkts[id].size);            end            if(mon.out_pkts[id].size != 0)begin//mon.out_pkts必须有数据                check_data_buffer = 0;                $display("mon.out_pkts[%0d] buffer size is not 0(still with %0d data)",id,mon.out_pkts[id].size);            end        end    endfunction    endclass//********************************** Optional tests **********************************//class rt_env;//rt_env包含各个组件    rt_stimulator stim;    rt_monitor mon;    rt_generator gen;    rt_checker chk;            function new(virtual rt_interface intf);        //build stage,例化        stim = new();        gen = new();        mon = new();        chk = new();        //connect stage，连接        stim.intf = intf;        mon.intf = intf;        chk.mon = mon;//check拿monitor句柄，即拿monitor中in_pkts与out_pkts队列    endfunction         task run();        rt_packet p;        //run stage，run        fork            stim.run();//class里面的函数不会自动调用，需要手动调用            gen.run();            mon.run();            chk.run();            begin:genarator_to_stimulator_proc//取出genarator中的数据给stimulator                 forever begin//此处不需要延迟0，执行task run的时候默认function new已执行                    gen.get_pkt(p);//get句柄                    stim.put_pkt(p);//put句柄                end            end        join_none    endtask        function void report(string name);        chk.report(name);    endfunction    endclassclass rt_base_test;//rt_base_test包含rt_env，rt_env包含各个组件    rt_env env;    bit gen_trans_done = 0;//表示数据传输未开始    int unsigned test_drain_time_us = 200;//数据传输完后等待报告的时间    string name;        function new(virtual rt_interface intf,string name = "rt_base_test");        env = new(intf);        this.name = name;    endfunction        task run();    $display("TEST %s started",name);        fork            env.run();            report();//调用report        join_none    endtask        task report();        wait(gen_trans_done == 1);        #(test_drain_time_us * 1us);        env.report(name);//调用env里的chk.report()进行report        $finish();//terminates the current test    endtask  function void set_trans_done(bit done = 1);//将set_trans_done信号置为1，表示数据传输已完成        gen_trans_done = done;    endfunctionendclass    class rt_single_ch_test extends rt_base_test;//单个通道测试        rand bit signed [4:0] src;        rand bit signed [4:0] dst;        rand int unsigned pkt_count =10;        constraint test_cstr {            soft pkt_count inside {[1:20]};            src inside {[0 : 15]};            dst inside {[0 : 15]};            }        function new(virtual rt_interface intf,string name = "rt_single_ch_test");            super.new(intf,name);        endfunction                    task run();            rt_packet p;            super.run();//调用父类的run，即执行env.run()，进行组件的例化等操作            this.randomize(); //randmoize self to get constrained data            for ( int cnt=0; cnt < pkt_count; cnt++) begin//随机10次                p = new( );                p.randomize() with {src == local::src; dst == local::dst; };                env.gen.put_pkt(p);            end            set_trans_done();        endtask            endclass    class rt_two_ch_test extends rt_base_test;        function new(virtual rt_interface intf,string name = "rt_two_ch_test");            super.new(intf,name);        endfunction    endclass        class rt_two_ch_same_chout_test extends rt_two_ch_test;            function new(virtual rt_interface intf,string name = "rt_two_ch_same_chout_test");                super.new(intf,name);            endfunction        endclass    class rt_multi_ch_test extends rt_base_test;//多通道测试        function new(virtual rt_interface intf,string name = "rt_multi_ch_test");            super.new(intf,name);        endfunction                task run();            rt_packet p;            super.run();            p = new();            p.set_members(0,3,'{8'h33,8'h77});            env.gen.put_pkt(p);            p = new();//每次put_pkt都需要new一下            p.set_members(0,5,'{8'h55,8'h66});            env.gen.put_pkt(p);            p = new();            p.set_members(3,6,'{8'h77,8'h88,8'h22});            env.gen.put_pkt(p);            p = new();            p.set_members(4,7,'{8'haa,8'hcc,8'h33});            env.gen.put_pkt(p);            set_trans_done();        endtask    endclass        class rt_full_ch_test extends rt_multi_ch_test;            function new(virtual rt_interface intf,string name = "rt_full_ch_test");                super.new(intf,name);            endfunction        endclassendpackage</code></pre><h2 id="2-2-改造后的lab8tb-sv"><a href="#2-2-改造后的lab8tb-sv" class="headerlink" title="2.2 改造后的lab8tb.sv"></a>2.2 改造后的lab8tb.sv</h2><pre class=" language-systemverilog"><code class="language-systemverilog">//********************************** rt_interface **********************************//interface rt_interface();    logic clock;    logic reset_n;    logic [15:0] din;    logic [15:0] frame_n;    logic [15:0] valid_n;    logic [15:0] dout;    logic [15:0] valido_n;    logic [15:0] busy_n;    logic [15:0] frameo_n;endinterface//********************************** tb **********************************//module tb;  import rt_test_pkg ::*;        bit clk,rstn;    logic [15:0] din, frame_n, valid_n;    logic [15:0] dout, valido_n, busy_n, frameo_n;// 产生时钟，周期为10nsinitial     forever #5ns clk <= !clk;// 产生复位信号  initial begin    #2ns rstn <= 1;    #10ns rstn <= 0;    #10ns rstn <= 1;  end//例化router为DUTrouter dut(             .reset_n(rstn),  .clock(clk),  .frame_n(intf.frame_n),  .valid_n(intf.valid_n),  .din(intf.din),  .dout(intf.dout),  .busy_n(intf.busy_n),  .valido_n(intf.valido_n),  .frameo_n(intf.frameo_n));rt_interface intf();//例化接口    assign intf.reset_n = rstn;    assign intf.clock = clk;    rt_single_ch_test  single_ch_test;    rt_multi_ch_test   multi_ch_test;            initial begin : Select_the_test    string name;    single_ch_test = new(intf);      multi_ch_test  = new(intf);      //single_ch_test.run();      //multi_ch_test.run();      if($value$plusargs("TESTNAME=%s",name))begin//$value$plusargs作用：运行仿真时输入参数        case(name)            "rt_single_ch_test" : single_ch_test.run();//输入rt_single_ch_test，调用对应run，执行输入rt_single_ch_test                "rt_multi_ch_test" :multi_ch_test.run();            default:$fatal("[ERRTEST],test name %s is invalid,please specity a valid name!0",name);        endcase        end    end    endmodule </code></pre><h2 id="2-3-makefile"><a href="#2-3-makefile" class="headerlink" title="2.3 makefile"></a>2.3 makefile</h2><pre class=" language-c"><code class="language-c">###########################<span class="token macro property"># User variables</span>###########################TB       <span class="token operator">=</span> tbSEED  <span class="token operator">=</span> <span class="token number">1</span>TESTNAME <span class="token operator">?</span><span class="token operator">=</span> rt_single_ch_testFILES    <span class="token operator">=</span> router<span class="token punctuation">.</span>v rt_test_pkg<span class="token punctuation">.</span>sv lab8tb<span class="token punctuation">.</span>sv #User Defination###########################<span class="token macro property"># Environment variables</span>###########################COMP <span class="token operator">=</span> vcs <span class="token operator">-</span>full64 <span class="token operator">-</span>sverilog <span class="token operator">-</span>debug_access<span class="token operator">+</span>all <span class="token operator">-</span>timescale<span class="token operator">=</span>1ns<span class="token operator">/</span>1ps <span class="token operator">-</span>l comp<span class="token punctuation">.</span>log $<span class="token punctuation">(</span>FILES<span class="token punctuation">)</span>RUN <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token operator">/</span>$<span class="token punctuation">(</span>TB<span class="token punctuation">)</span><span class="token punctuation">.</span>simv <span class="token operator">-</span>l run<span class="token punctuation">.</span>log <span class="token operator">-</span>sml <span class="token operator">+</span>ntb_random_seed<span class="token operator">=</span>$<span class="token punctuation">(</span>SEED<span class="token punctuation">)</span> <span class="token operator">+</span>TESTNAME<span class="token operator">=</span>$<span class="token punctuation">(</span>TESTNAME<span class="token punctuation">)</span>comp<span class="token punctuation">:</span>    $<span class="token punctuation">(</span>COMP<span class="token punctuation">)</span> <span class="token operator">-</span>top $<span class="token punctuation">(</span>TB<span class="token punctuation">)</span> <span class="token operator">-</span>o $<span class="token punctuation">(</span>TB<span class="token punctuation">)</span><span class="token punctuation">.</span>simvrun<span class="token punctuation">:</span>    $<span class="token punctuation">(</span>RUN<span class="token punctuation">)</span>rung<span class="token punctuation">:</span>    $<span class="token punctuation">(</span>RUN<span class="token punctuation">)</span> <span class="token operator">-</span>gui</code></pre><h1 id="3-仿真结果"><a href="#3-仿真结果" class="headerlink" title="3. 仿真结果"></a>3. 仿真结果</h1><p>DVE报告</p><blockquote><p>TEST rt_single_ch_test started<br>@105000:[DRV] src_chnl[10] &amp; dest_chnl[8] data trans started with packet:<br>src = 10<br>dst = 8<br>data_length = 15<br>data[0] = ‘ha0<br>data[1] = ‘ha1<br>data[2] = ‘ha2<br>data[3] = ‘ha3<br>data[4] = ‘ha4<br>data[5] = ‘ha5<br>data[6] = ‘ha6<br>data[7] = ‘ha7<br>data[8] = ‘ha8<br>data[9] = ‘ha9<br>data[10] = ‘haa<br>data[11] = ‘hab<br>data[12] = ‘hac<br>data[13] = ‘had<br>data[14] = ‘hae</p><p>@150000: [MON] src_chn1[10] &amp; dest_chn1[8] data trans started<br>@205000: [MON] CH_OUT dest_chn1[8] data trans started<br>@1400000:[MON] CH_IN src_chnl[10] &amp;dest_chnl[8 ] finished with packet:<br>src = 10<br>dst = 8<br>data_length = 15<br>data[0] = ‘ha0<br>data[1] = ‘ha1<br>data[2] = ‘ha2<br>data[3] = ‘ha3<br>data[4] = ‘ha4<br>data[5] = ‘ha5<br>data[6] = ‘ha6<br>data[7] = ‘ha7<br>data[8] = ‘ha8<br>data[9] = ‘ha9<br>data[10] = ‘haa<br>data[11] = ‘hab<br>data[12] = ‘hac<br>data[13] = ‘had<br>data[14] = ‘hae</p><p>@1405000: [DRV]src_chnl[10],dest_chnl[8] data trans finished<br>@1405000:[DRV] src_chnl[10] &amp; dest_chnl[8] data trans started with packet:<br>src = 10<br>dst = 8<br>data_length = 14<br>data[0] = ‘ha0<br>data[1] = ‘ha1<br>data[2] = ‘ha2<br>data[3] = ‘ha3<br>data[4] = ‘ha4<br>data[5] = ‘ha5<br>data[6] = ‘ha6<br>data[7] = ‘ha7<br>data[8] = ‘ha8<br>data[9] = ‘ha9<br>data[10] = ‘haa<br>data[11] = ‘hab<br>data[12] = ‘hac<br>data[13] = ‘had</p><p>@1420000: [MON] CH_OUT dest_chn1[8] data finished woth packet :<br>src = 10<br>dst = 8<br>data_length = 15<br>data[0] = ‘ha0<br>data[1] = ‘ha1<br>data[2] = ‘ha2<br>data[3] = ‘ha3<br>data[4] = ‘ha4<br>data[5] = ‘ha5<br>data[6] = ‘ha6<br>data[7] = ‘ha7<br>data[8] = ‘ha8<br>data[9] = ‘ha9<br>data[10] = ‘haa<br>data[11] = ‘hab<br>data[12] = ‘hac<br>data[13] = ‘had<br>data[14] = ‘hae</p><p>[CHK] data compare success with packet :<br>src = 10<br>dst = 8<br>data_length = 15<br>data[0] = ‘ha0<br>data[1] = ‘ha1<br>data[2] = ‘ha2<br>data[3] = ‘ha3<br>data[4] = ‘ha4<br>data[5] = ‘ha5<br>data[6] = ‘ha6<br>data[7] = ‘ha7<br>data[8] = ‘ha8<br>data[9] = ‘ha9<br>data[10] = ‘haa<br>data[11] = ‘hab<br>data[12] = ‘hac<br>data[13] = ‘had<br>data[14] = ‘hae</p><p>@1450000: [MON] src_chn1[10] &amp; dest_chn1[8] data trans started<br>@1505000: [MON] CH_OUT dest_chn1[8] data trans started<br>@2620000:[MON] CH_IN src_chnl[10] &amp;dest_chnl[8 ] finished with packet:<br>src = 10<br>dst = 8<br>data_length = 14<br>data[0] = ‘ha0<br>data[1] = ‘ha1<br>data[2] = ‘ha2<br>data[3] = ‘ha3<br>data[4] = ‘ha4<br>data[5] = ‘ha5<br>data[6] = ‘ha6<br>data[7] = ‘ha7<br>data[8] = ‘ha8<br>data[9] = ‘ha9<br>data[10] = ‘haa<br>data[11] = ‘hab<br>data[12] = ‘hac<br>data[13] = ‘had</p><p>@2625000: [DRV]src_chnl[10],dest_chnl[8] data trans finished<br>@2625000:[DRV] src_chnl[10] &amp; dest_chnl[8] data trans started with packet:<br>src = 10<br>dst = 8<br>data_length = 30<br>data[0] = ‘ha0<br>data[1] = ‘ha1<br>data[2] = ‘ha2<br>data[3] = ‘ha3<br>data[4] = ‘ha4<br>data[5] = ‘ha5<br>data[6] = ‘ha6<br>data[7] = ‘ha7<br>data[8] = ‘ha8<br>data[9] = ‘ha9<br>data[10] = ‘haa<br>data[11] = ‘hab<br>data[12] = ‘hac<br>data[13] = ‘had<br>data[14] = ‘hae<br>data[15] = ‘haf<br>data[16] = ‘hb0<br>data[17] = ‘hb1<br>data[18] = ‘hb2<br>data[19] = ‘hb3<br>data[20] = ‘hb4<br>data[21] = ‘hb5<br>data[22] = ‘hb6<br>data[23] = ‘hb7<br>data[24] = ‘hb8<br>data[25] = ‘hb9<br>data[26] = ‘hba<br>data[27] = ‘hbb<br>data[28] = ‘hbc<br>data[29] = ‘hbd</p><p>@2640000: [MON] CH_OUT dest_chn1[8] data finished woth packet :<br>src = 10<br>dst = 8<br>data_length = 14<br>data[0] = ‘ha0<br>data[1] = ‘ha1<br>data[2] = ‘ha2<br>data[3] = ‘ha3<br>data[4] = ‘ha4<br>data[5] = ‘ha5<br>data[6] = ‘ha6<br>data[7] = ‘ha7<br>data[8] = ‘ha8<br>data[9] = ‘ha9<br>data[10] = ‘haa<br>data[11] = ‘hab<br>data[12] = ‘hac<br>data[13] = ‘had</p><p>[CHK] data compare success with packet :<br>src = 10<br>dst = 8<br>data_length = 14<br>data[0] = ‘ha0<br>data[1] = ‘ha1<br>data[2] = ‘ha2<br>data[3] = ‘ha3<br>data[4] = ‘ha4<br>data[5] = ‘ha5<br>data[6] = ‘ha6<br>data[7] = ‘ha7<br>data[8] = ‘ha8<br>data[9] = ‘ha9<br>data[10] = ‘haa<br>data[11] = ‘hab<br>data[12] = ‘hac<br>data[13] = ‘had</p><p>@2670000: [MON] src_chn1[10] &amp; dest_chn1[8] data trans started<br>@2725000: [MON] CH_OUT dest_chn1[8] data trans started<br>@5120000:[MON] CH_IN src_chnl[10] &amp;dest_chnl[8 ] finished with packet:<br>src = 10<br>dst = 8<br>data_length = 30<br>data[0] = ‘ha0<br>data[1] = ‘ha1<br>data[2] = ‘ha2<br>data[3] = ‘ha3<br>data[4] = ‘ha4<br>data[5] = ‘ha5<br>data[6] = ‘ha6<br>data[7] = ‘ha7<br>data[8] = ‘ha8<br>data[9] = ‘ha9<br>data[10] = ‘haa<br>data[11] = ‘hab<br>data[12] = ‘hac<br>data[13] = ‘had<br>data[14] = ‘hae<br>data[15] = ‘haf<br>data[16] = ‘hb0<br>data[17] = ‘hb1<br>data[18] = ‘hb2<br>data[19] = ‘hb3<br>data[20] = ‘hb4<br>data[21] = ‘hb5<br>data[22] = ‘hb6<br>data[23] = ‘hb7<br>data[24] = ‘hb8<br>data[25] = ‘hb9<br>data[26] = ‘hba<br>data[27] = ‘hbb<br>data[28] = ‘hbc<br>data[29] = ‘hbd</p><p>@5125000: [DRV]src_chnl[10],dest_chnl[8] data trans finished<br>@5125000:[DRV] src_chnl[10] &amp; dest_chnl[8] data trans started with packet:<br>src = 10<br>dst = 8<br>data_length = 15<br>data[0] = ‘ha0<br>data[1] = ‘ha1<br>data[2] = ‘ha2<br>data[3] = ‘ha3<br>data[4] = ‘ha4<br>data[5] = ‘ha5<br>data[6] = ‘ha6<br>data[7] = ‘ha7<br>data[8] = ‘ha8<br>data[9] = ‘ha9<br>data[10] = ‘haa<br>data[11] = ‘hab<br>data[12] = ‘hac<br>data[13] = ‘had<br>data[14] = ‘hae</p><p>@5140000: [MON] CH_OUT dest_chn1[8] data finished woth packet :<br>src = 10<br>dst = 8<br>data_length = 30<br>data[0] = ‘ha0<br>data[1] = ‘ha1<br>data[2] = ‘ha2<br>data[3] = ‘ha3<br>data[4] = ‘ha4<br>data[5] = ‘ha5<br>data[6] = ‘ha6<br>data[7] = ‘ha7<br>data[8] = ‘ha8<br>data[9] = ‘ha9<br>data[10] = ‘haa<br>data[11] = ‘hab<br>data[12] = ‘hac<br>data[13] = ‘had<br>data[14] = ‘hae<br>data[15] = ‘haf<br>data[16] = ‘hb0<br>data[17] = ‘hb1<br>data[18] = ‘hb2<br>data[19] = ‘hb3<br>data[20] = ‘hb4<br>data[21] = ‘hb5<br>data[22] = ‘hb6<br>data[23] = ‘hb7<br>data[24] = ‘hb8<br>data[25] = ‘hb9<br>data[26] = ‘hba<br>data[27] = ‘hbb<br>data[28] = ‘hbc<br>data[29] = ‘hbd</p><p>[CHK] data compare success with packet :<br>src = 10<br>dst = 8<br>data_length = 30<br>data[0] = ‘ha0<br>data[1] = ‘ha1<br>data[2] = ‘ha2<br>data[3] = ‘ha3<br>data[4] = ‘ha4<br>data[5] = ‘ha5<br>data[6] = ‘ha6<br>data[7] = ‘ha7<br>data[8] = ‘ha8<br>data[9] = ‘ha9<br>data[10] = ‘haa<br>data[11] = ‘hab<br>data[12] = ‘hac<br>data[13] = ‘had<br>data[14] = ‘hae<br>data[15] = ‘haf<br>data[16] = ‘hb0<br>data[17] = ‘hb1<br>data[18] = ‘hb2<br>data[19] = ‘hb3<br>data[20] = ‘hb4<br>data[21] = ‘hb5<br>data[22] = ‘hb6<br>data[23] = ‘hb7<br>data[24] = ‘hb8<br>data[25] = ‘hb9<br>data[26] = ‘hba<br>data[27] = ‘hbb<br>data[28] = ‘hbc<br>data[29] = ‘hbd</p><p>@5170000: [MON] src_chn1[10] &amp; dest_chn1[8] data trans started<br>@5225000: [MON] CH_OUT dest_chn1[8] data trans started<br>@6420000:[MON] CH_IN src_chnl[10] &amp;dest_chnl[8 ] finished with packet:<br>src = 10<br>dst = 8<br>data_length = 15<br>data[0] = ‘ha0<br>data[1] = ‘ha1<br>data[2] = ‘ha2<br>data[3] = ‘ha3<br>data[4] = ‘ha4<br>data[5] = ‘ha5<br>data[6] = ‘ha6<br>data[7] = ‘ha7<br>data[8] = ‘ha8<br>data[9] = ‘ha9<br>data[10] = ‘haa<br>data[11] = ‘hab<br>data[12] = ‘hac<br>data[13] = ‘had<br>data[14] = ‘hae</p><p>@6425000: [DRV]src_chnl[10],dest_chnl[8] data trans finished<br>@6425000:[DRV] src_chnl[10] &amp; dest_chnl[8] data trans started with packet:<br>src = 10<br>dst = 8<br>data_length = 27<br>data[0] = ‘ha0<br>data[1] = ‘ha1<br>data[2] = ‘ha2<br>data[3] = ‘ha3<br>data[4] = ‘ha4<br>data[5] = ‘ha5<br>data[6] = ‘ha6<br>data[7] = ‘ha7<br>data[8] = ‘ha8<br>data[9] = ‘ha9<br>data[10] = ‘haa<br>data[11] = ‘hab<br>data[12] = ‘hac<br>data[13] = ‘had<br>data[14] = ‘hae<br>data[15] = ‘haf<br>data[16] = ‘hb0<br>data[17] = ‘hb1<br>data[18] = ‘hb2<br>data[19] = ‘hb3<br>data[20] = ‘hb4<br>data[21] = ‘hb5<br>data[22] = ‘hb6<br>data[23] = ‘hb7<br>data[24] = ‘hb8<br>data[25] = ‘hb9<br>data[26] = ‘hba</p><p>@6440000: [MON] CH_OUT dest_chn1[8] data finished woth packet :<br>src = 10<br>dst = 8<br>data_length = 15<br>data[0] = ‘ha0<br>data[1] = ‘ha1<br>data[2] = ‘ha2<br>data[3] = ‘ha3<br>data[4] = ‘ha4<br>data[5] = ‘ha5<br>data[6] = ‘ha6<br>data[7] = ‘ha7<br>data[8] = ‘ha8<br>data[9] = ‘ha9<br>data[10] = ‘haa<br>data[11] = ‘hab<br>data[12] = ‘hac<br>data[13] = ‘had<br>data[14] = ‘hae</p><p>[CHK] data compare success with packet :<br>src = 10<br>dst = 8<br>data_length = 15<br>data[0] = ‘ha0<br>data[1] = ‘ha1<br>data[2] = ‘ha2<br>data[3] = ‘ha3<br>data[4] = ‘ha4<br>data[5] = ‘ha5<br>data[6] = ‘ha6<br>data[7] = ‘ha7<br>data[8] = ‘ha8<br>data[9] = ‘ha9<br>data[10] = ‘haa<br>data[11] = ‘hab<br>data[12] = ‘hac<br>data[13] = ‘had<br>data[14] = ‘hae</p><p>@6470000: [MON] src_chn1[10] &amp; dest_chn1[8] data trans started<br>@6525000: [MON] CH_OUT dest_chn1[8] data trans started<br>@8680000:[MON] CH_IN src_chnl[10] &amp;dest_chnl[8 ] finished with packet:<br>src = 10<br>dst = 8<br>data_length = 27<br>data[0] = ‘ha0<br>data[1] = ‘ha1<br>data[2] = ‘ha2<br>data[3] = ‘ha3<br>data[4] = ‘ha4<br>data[5] = ‘ha5<br>data[6] = ‘ha6<br>data[7] = ‘ha7<br>data[8] = ‘ha8<br>data[9] = ‘ha9<br>data[10] = ‘haa<br>data[11] = ‘hab<br>data[12] = ‘hac<br>data[13] = ‘had<br>data[14] = ‘hae<br>data[15] = ‘haf<br>data[16] = ‘hb0<br>data[17] = ‘hb1<br>data[18] = ‘hb2<br>data[19] = ‘hb3<br>data[20] = ‘hb4<br>data[21] = ‘hb5<br>data[22] = ‘hb6<br>data[23] = ‘hb7<br>data[24] = ‘hb8<br>data[25] = ‘hb9<br>data[26] = ‘hba</p><p>@8685000: [DRV]src_chnl[10],dest_chnl[8] data trans finished<br>@8700000: [MON] CH_OUT dest_chn1[8] data finished woth packet :<br>src = 10<br>dst = 8<br>data_length = 27<br>data[0] = ‘ha0<br>data[1] = ‘ha1<br>data[2] = ‘ha2<br>data[3] = ‘ha3<br>data[4] = ‘ha4<br>data[5] = ‘ha5<br>data[6] = ‘ha6<br>data[7] = ‘ha7<br>data[8] = ‘ha8<br>data[9] = ‘ha9<br>data[10] = ‘haa<br>data[11] = ‘hab<br>data[12] = ‘hac<br>data[13] = ‘had<br>data[14] = ‘hae<br>data[15] = ‘haf<br>data[16] = ‘hb0<br>data[17] = ‘hb1<br>data[18] = ‘hb2<br>data[19] = ‘hb3<br>data[20] = ‘hb4<br>data[21] = ‘hb5<br>data[22] = ‘hb6<br>data[23] = ‘hb7<br>data[24] = ‘hb8<br>data[25] = ‘hb9<br>data[26] = ‘hba</p><p>[CHK] data compare success with packet :<br>src = 10<br>dst = 8<br>data_length = 27<br>data[0] = ‘ha0<br>data[1] = ‘ha1<br>data[2] = ‘ha2<br>data[3] = ‘ha3<br>data[4] = ‘ha4<br>data[5] = ‘ha5<br>data[6] = ‘ha6<br>data[7] = ‘ha7<br>data[8] = ‘ha8<br>data[9] = ‘ha9<br>data[10] = ‘haa<br>data[11] = ‘hab<br>data[12] = ‘hac<br>data[13] = ‘had<br>data[14] = ‘hae<br>data[15] = ‘haf<br>data[16] = ‘hb0<br>data[17] = ‘hb1<br>data[18] = ‘hb2<br>data[19] = ‘hb3<br>data[20] = ‘hb4<br>data[21] = ‘hb5<br>data[22] = ‘hb6<br>data[23] = ‘hb7<br>data[24] = ‘hb8<br>data[25] = ‘hb9<br>data[26] = ‘hba</p><p>TOTAL COMPARING 5 times<br>TEST [rt_single_ch_test] PASSED!</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数字IC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字前端 </tag>
            
            <tag> SystemVerilog验证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SystemVerilog学习笔记(八)</title>
      <link href="/2022/11/01/systemverilog-xue-xi-bi-ji-ba/"/>
      <url>/2022/11/01/systemverilog-xue-xi-bi-ji-ba/</url>
      
        <content type="html"><![CDATA[<div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211022245932.png" width="60%" height="60%"></div><h2 id="1-如何简单产生一个随机常数"><a href="#1-如何简单产生一个随机常数" class="headerlink" title="1. 如何简单产生一个随机常数"></a>1. 如何简单产生一个随机常数</h2><h3 id="1-1-randomize"><a href="#1-1-randomize" class="headerlink" title="1.1 $randomize"></a>1.1 $randomize</h3><h3 id="1-2-urandom"><a href="#1-2-urandom" class="headerlink" title="1.2 $urandom"></a>1.2 $urandom</h3><p>$urandom()，可以生成一个32位的无符号随机数。<br>$urandom_range(maxval, minval=0)，可以生成间与maxval与minval之间的数。</p><blockquote><p>val = $urandom_range(7,0)； //结果是[0,7]<br>val = $urandom_range(0,7);   //如果mixval比minval小，参数列表会自动反向<br>val = $urandom_range(7);       //如果minval没有指定，默认为0</p></blockquote><h2 id="2-系统而有机地组织随机变量"><a href="#2-系统而有机地组织随机变量" class="headerlink" title="2. 系统而有机地组织随机变量"></a>2. 系统而有机地组织随机变量</h2><h3 id="2-1-约束"><a href="#2-1-约束" class="headerlink" title="2.1 约束"></a>2.1 约束</h3><p>以上独立地生成一些随机数，在面向DUT的随机激励发生过程中，为了符合协议、满足测试需求，还需要添加一些”约束”。这些”约束”会使得变量朝着希望他们变化的方向去随机。不但如此，这些约束也会对变量与变量之间的关系生效。</p><h3 id="2-2-约束的载体"><a href="#2-2-约束的载体" class="headerlink" title="2.2 约束的载体"></a>2.2 约束的载体</h3><p>因此，我们需要一个”载体”去容纳这些变量以及它们之间的约束。这个”载体”即是类，而类的成员变量均可声明为”随机”属性，用rand或者randc来表示。</p><h3 id="2-3-随机变量"><a href="#2-3-随机变量" class="headerlink" title="2.3 随机变量"></a>2.3 随机变量</h3><p>任何类中的<span style="background:#d3f8b6">整形(bit/byte/int)变量</span>都可以声明为rand/randc。<br><span style="background:#d3f8b6">定长数组、动态数组、关联数组和队列</span>都可以声明为rand/randc，可以对动态数组和队列的长度加以约束。<br><span style="background:#d3f8b6">指向对象的句柄成员</span>，也可以声明为rand(不能被声明为randc) ，随机时该句柄指向对象中的随机变量也会一并被随机。</p><h3 id="2-4-实例"><a href="#2-4-实例" class="headerlink" title="2.4 实例"></a>2.4 实例</h3><div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211011751369.png " width="80%" height="80%"></div><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211022220922.png" width="80%" height="80%"></div><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211022221417.png" width="80%" height="80%"></div><div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211022222796.png " width="80%" height="80%"></div><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211022222514.png" width="80%" height="80%"></div><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211011754978.png" width="80%" height="80%"></div><h2 id="2-5-约束块"><a href="#2-5-约束块" class="headerlink" title="2.5 约束块"></a>2.5 约束块</h2><p>有用的激励不仅仅是随机值，<span style="background:rgba(240, 200, 0, 0.2)">变量之间也有着相互关系</span>。没有约束的随机变量会包含许多无效的和非法的值，这会使得有效激励的产生</p><h3 id="2-5-1-设置取值范围"><a href="#2-5-1-设置取值范围" class="headerlink" title="2.5.1 设置取值范围"></a>2.5.1 设置取值范围</h3><p>约束块支持整形通过set操作符来设置它们的可取值范围。</p><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211011759261.png" width="60%" height="60%"></div><h3 id="2-5-2-权重"><a href="#2-5-2-权重" class="headerlink" title="2.5.2 权重"></a>2.5.2 权重</h3><p>除了成员集合设置，约束块也支持设置可取值的同时也为其设置随机时的权重。<br> <span style="background:rgba(240, 200, 0, 0.2)">:=</span>  操作符：表示每一个值的权重是相同的。<br> <span style="background:rgba(240, 200, 0, 0.2)"> :/ </span> 操作符：表示权重会平均分配到每一个值。</p><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211011802842.png" width="60%" height="60%"></div><h3 id="2-5-3-唯一标识"><a href="#2-5-3-唯一标识" class="headerlink" title="2.5.3 唯一标识"></a>2.5.3 唯一标识</h3><p>unique可以用来约束一组变量，<span style="background:rgba(240, 200, 0, 0.2)">使得其在随机后变量之间不会有相同的数值。</span></p><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211011807987.png" width="60%" height="60%"></div><h3 id="2-5-4-条件约束"><a href="#2-5-4-条件约束" class="headerlink" title="2.5.4 条件约束"></a>2.5.4 条件约束</h3><p>使用if-else或者-&gt;操作符来表示条件约束。</p><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211011808349.png" width="50%" height="50%"></div><h3 id="2-5-5-迭代约束"><a href="#2-5-5-迭代约束" class="headerlink" title="2.5.5 迭代约束"></a>2.5.5 迭代约束</h3><p>foreach可以用来迭代约束数组中的元素，这些数组可以是定长数组、动态数组、关联数组或者队列。<br>也可以使用数组的缩减方法做迭代约束。</p><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211011824469.png" width="50%" height="50%"></div><hr><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211011825775.png" width="50%" height="50%"></div><h3 id="2-5-6-函数调用"><a href="#2-5-6-函数调用" class="headerlink" title="2.5.6 函数调用"></a>2.5.6 函数调用</h3><h3 id="2-5-7-软约束"><a href="#2-5-7-软约束" class="headerlink" title="2.5.7 软约束"></a>2.5.7 软约束</h3><p>在没有soft描述时的约束，我们称之为硬约束，而带有soft描述的则是软约束。软约束用来指定变量的默认值和权重。如果用户在使用时，指定了外部约束对同一个变量做二次约束，或者用户定义了子类，也对同一个变量做二次约束时，那么<span style="background:rgba(240, 200, 0, 0.2)">硬约束可以”覆盖”软约束</span>，并且不会导致随机数产生的失败。</p><div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211012017431.png " width="90%" height="90%"></div><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211012017414.png" width="80%" height="80%"></div><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211012017120.png" width="90%" height="90%"></div><h3 id="2-5-8-实例"><a href="#2-5-8-实例" class="headerlink" title="2.5.8 实例"></a>2.5.8 实例</h3><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211012042971.png" width="80%" height="80%"></div><h3 id="2-5-9-内嵌约束（指向模糊）"><a href="#2-5-9-内嵌约束（指向模糊）" class="headerlink" title="2.5.9 内嵌约束（指向模糊）"></a>2.5.9 内嵌约束（指向模糊）</h3><p>此处x是加给f的约束，就近句柄f指向类c1，优先找这个类里面有无x<br>若要指向task参数中的x，使用 <span style="background:#fff88f">local::x</span></p><div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211012052456.png " width="60%" height="60%"></div><h3 id="2-5-10-内嵌约束（指向明确）"><a href="#2-5-10-内嵌约束（指向明确）" class="headerlink" title="2.5.10 内嵌约束（指向明确）"></a>2.5.10 内嵌约束（指向明确）</h3><h3 id="2-5-11-local域指向"><a href="#2-5-11-local域指向" class="headerlink" title="2.5.11 local域指向"></a>2.5.11 local域指向</h3><p>之前在使用内嵌约束随机时，对于同名的变量处在不同的域中，可能会出现指向模糊的情况，之前我们已经给出了一种方法。接下来我们可以通过<span style="background:#fff88f">local::</span> 的域索引方式来明确随机变量的指向，即<u> <span style="background:#fff88f">local::</span> 指向的变量会在包含randomize()方法的对象中</u>。</p><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211021543318.png" width="60%" height="60%"></div><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211012109025.png" width="60%" height="60%"></div><div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211012106238.png " width="60%" height="60%"></div><h3 id="2-5-12-随机控制"><a href="#2-5-12-随机控制" class="headerlink" title="2.5.12 随机控制"></a>2.5.12 随机控制</h3><p>rand_mode可以用来使能或者禁止随机变量。<br>当随机数被禁止时，它会同为声明为随机变量的普通变量一样，不会参与到随机化过程当中。<br>从以下两个函数声明可以看到，可以就单个随机变量调用其rand_mode，或者对整个对象调用rand_mode来控制其中所有的随机变量。</p><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211012124495.png" width="60%" height="60%"></div><h3 id="2-5-13-约束控制"><a href="#2-5-13-约束控制" class="headerlink" title="2.5.13 约束控制"></a>2.5.13 约束控制</h3><p>类似于随机控制，一些约束块或者某个类的约束块集合都可以单个控制或者集体控制。</p><blockquote><p>task object[.constraint_identifier] : :constraint_mode (bit on_off );funetion int object.constraint_identifier : : constraint_mode() ;</p></blockquote><p>可以通过约束控制函数来使能或者关闭某些约束块。</p><div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211012126652.png " width="50%" height="50%"></div><h3 id="2-5-14-内嵌变量控制"><a href="#2-5-14-内嵌变量控制" class="headerlink" title="2.5.14 内嵌变量控制"></a>2.5.14 内嵌变量控制</h3><p>在使用类的随机化函数randomize()时，如果伴有参数，那么只会随机化这些变量，而其余变量无论是否之前被声明为rand/randc，都将不会参与到随机化当中。</p><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211012130326.png" width="50%" height="50%"></div><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211012226039.png" width="60%" height="60%"></div><h1 id="3-问答题"><a href="#3-问答题" class="headerlink" title="3. 问答题"></a>3. 问答题</h1><p><strong>1.随机测试相比于定向测试，就你目前的认识，你认为有哪些优缺点?</strong><br>答：当一个项目的功能成倍增加时，编写足够多的定向测试几乎不可能。而且，定向测试很难满足检查功能完整性的要求，随机测试能够产生更加完整复杂的激励场景，去对设计进行测试。缺点：随机测试会使验证环境的复杂度提高，从环境组件上考虑不再只需要发送激励的组件，而且还包括监测器、比较<br>器等。</p><p><strong>2.产生一个随机数有哪些方法呢?请提交代码文本和仿真打印结果。</strong><br><strong>使用randomize</strong></p><pre class=" language-systemverilog"><code class="language-systemverilog">module randnum;  bit [3:0] a;  bit [3:0] b;    initial begin    $display("before randomized a = %0d b = %0d",a,b);    std::randomize (a,b);    $display("after  randomized a = %0d b = %0d",a,b);  endendmodule</code></pre><p>仿真结果：</p><blockquote><p>before randomized a =0 b=0<br>after    randomized a= 4 b = 14</p></blockquote><p><strong>使用系统函数$urandom</strong></p><pre class=" language-systemverilog"><code class="language-systemverilog">module randnum;  bit [3:0] a;  bit [3:0] b;   initial begin    $display("before randomized a = %0d b = %0d",a,b);     b = $urandom();     a = $urandom_range(0,10);    $display("after  randomized a = %0d b = %0d",a,b);  endendmodule</code></pre><p>仿真结果</p><blockquote><p>before randomized a = 0 b = 0<br>after    randomized a = 6 b = 6</p></blockquote><p><strong>3.如何用rand bit [15:0]向量产生一个随机实数?请提交代码文本和仿真打印结果。</strong></p><p><strong>4.如何用rand bit[7:0] arr[8]通过约束块(不用unique来约束)产生一个元素各不相同的数组?请提交代码文本和仿真打印结果。</strong></p><p><strong>5.请仿真以下代码并且解释仿真结果。</strong></p><pre class=" language-systemverilog"><code class="language-systemverilog">module tb;    class randnum;        rand bit[3:0] x, y;    endclassinitial begin    randnum rn = new();    int x = 5, y=7;    for(int loop = 0; loop < 10; loop++) begin    rn.randomize() with {x < y;};    $display("LOOP-%0d:: CONSTRAINT{x<y;}\n rn.x = %0d, rn.y = %0d", loop, rn.x, rn.y);    rn.randomize() with {x < this.y;};    $display("LOOP-%0d: CONSTRAINT {x<this.y;}\n rn.x = %0d, rn.y = %0d", loop, rn.x, rn.y);    rn.randomize() with {x < local::y;};    $display("LOOP-%0d:: CONSTRAINT{x<local::y;}\n rn.x = %0d, rn.y = %0d", loop, rn.x,rn.y);    endendendmodule</code></pre><p><strong>分析：</strong><br>y——指向rand bit[3:0] y中的y（就近原则，rn指向randnum这个类，此处y指向randnum这个要被随机化的类里面的y），所以每次随机后的x小于每次随机后的y即可。<br>this.y——同上<br>local::y——指向y=7（local::指向的变量y会在包含randomize()方法的对象rn中），所以每次随机后x小于7即可。</p><blockquote><p>仿真结果<br>LOOP-0:: CONSTRAINT{x&lt;y;}<br>rn.x = 4, rn.y = 6<br>LOOP-0: CONSTRAINT {x&lt;this.y;}<br>rn.x = 5, rn.y = 15<br>LOOP-0:: CONSTRAINT{x&lt;local::y;}<br>rn.x = 5, rn.y = 1</p><p>LOOP-1:: CONSTRAINT{x&lt;y;}<br>rn.x = 2, rn.y = 11<br>LOOP-1: CONSTRAINT {x&lt;this.y;}<br>rn.x = 0, rn.y = 4<br>LOOP-1:: CONSTRAINT{x&lt;local::y;}<br>rn.x = 4, rn.y = 7</p><p>LOOP-2:: CONSTRAINT{x&lt;y;}<br>rn.x = 8, rn.y = 13<br>LOOP-2: CONSTRAINT {x&lt;this.y;}<br>rn.x = 7, rn.y = 8<br>LOOP-2:: CONSTRAINT{x&lt;local::y;}<br>rn.x = 6, rn.y = 13</p><p>LOOP-3:: CONSTRAINT{x&lt;y;}<br>rn.x = 2, rn.y = 15<br>LOOP-3: CONSTRAINT {x&lt;this.y;}<br>rn.x = 4, rn.y = 6<br>LOOP-3:: CONSTRAINT{x&lt;local::y;}<br>rn.x = 0, rn.y = 15</p><p>LOOP-4:: CONSTRAINT{x&lt;y;}<br>rn.x = 11, rn.y = 15<br>LOOP-4: CONSTRAINT {x&lt;this.y;}<br>rn.x = 2, rn.y = 5<br>LOOP-4:: CONSTRAINT{x&lt;local::y;}<br>rn.x = 4, rn.y = 10</p><p>LOOP-5:: CONSTRAINT{x&lt;y;}<br>rn.x = 6, rn.y = 10<br>LOOP-5: CONSTRAINT {x&lt;this.y;}<br>rn.x = 7, rn.y = 10<br>LOOP-5:: CONSTRAINT{x&lt;local::y;}<br>rn.x = 3, rn.y = 3</p><p>LOOP-6:: CONSTRAINT{x&lt;y;}<br>rn.x = 0, rn.y = 12<br>LOOP-6: CONSTRAINT {x&lt;this.y;}<br>rn.x = 9, rn.y = 13<br>LOOP-6:: CONSTRAINT{x&lt;local::y;}<br>rn.x = 3, rn.y = 0</p><p>LOOP-7:: CONSTRAINT{x&lt;y;}<br>rn.x = 0, rn.y = 1<br>LOOP-7: CONSTRAINT {x&lt;this.y;}<br>rn.x = 4, rn.y = 6<br>LOOP-7:: CONSTRAINT{x&lt;local::y;}<br>rn.x = 5, rn.y = 13</p><p>LOOP-8:: CONSTRAINT{x&lt;y;}<br>rn.x = 0, rn.y = 12<br>LOOP-8: CONSTRAINT {x&lt;this.y;}<br>rn.x = 11, rn.y = 14<br>LOOP-8:: CONSTRAINT{x&lt;local::y;}<br>rn.x = 0, rn.y = 15</p><p>LOOP-9:: CONSTRAINT{x&lt;y;}<br>rn.x = 3, rn.y = 15<br>LOOP-9: CONSTRAINT {x&lt;this.y;}<br>rn.x = 1, rn.y = 14<br>LOOP-9:: CONSTRAINT{x&lt;local::y;}<br>rn.x = 0, rn.y = 8</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数字IC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字前端 </tag>
            
            <tag> SystemVerilog验证 </tag>
            
            <tag> 随机约束 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文献调研——星载计算机单粒子效应故障注入仿真</title>
      <link href="/2022/10/30/wen-xian-diao-yan-xing-zai-ji-suan-ji-dan-li-zi-xiao-ying-gu-zhang-zhu-ru-fang-zhen/"/>
      <url>/2022/10/30/wen-xian-diao-yan-xing-zai-ji-suan-ji-dan-li-zi-xiao-ying-gu-zhang-zhu-ru-fang-zhen/</url>
      
        <content type="html"><![CDATA[<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><p>OBC——星载计算机（On-Board Computer，OBC）<br>SIP——系统级封装</p><h1 id="空间环境中的辐射效应"><a href="#空间环境中的辐射效应" class="headerlink" title="空间环境中的辐射效应"></a>空间环境中的辐射效应</h1><h2 id="总剂量效应"><a href="#总剂量效应" class="headerlink" title="总剂量效应"></a>总剂量效应</h2><h2 id="单粒子效应"><a href="#单粒子效应" class="headerlink" title="单粒子效应"></a>单粒子效应</h2><h1 id="抗辐照性能的评估方法"><a href="#抗辐照性能的评估方法" class="headerlink" title="抗辐照性能的评估方法"></a>抗辐照性能的评估方法</h1><h2 id="空间环境实验"><a href="#空间环境实验" class="headerlink" title="空间环境实验"></a>空间环境实验</h2><p>空间环境实验以及地面模拟等效实验都有几个很明显的缺点：首先是需要搭建实验评估环境，致使试验成本升高；其次是需要对待评估的模块进行流片试产，如果辐照评估出现问题就会重新调试生产，导致设计周期变长；最后是在实验中观察到单粒子效应后，对系统的错误定位也是目前的技术难点。</p><h2 id="地面模拟等效实验"><a href="#地面模拟等效实验" class="headerlink" title="地面模拟等效实验"></a>地面模拟等效实验</h2><p>随着SiP 封装技术在航天星载计算机设计领域的普及，需要对SiP 封装的芯片进行  辐射效应评估，由于地面实验的加速器粒子能量不够，导致在进行地面辐照试验时难以穿透SiP 封装腔体，所以不能有效的对系统进行评估。</p><h2 id="计算机数值模拟仿真"><a href="#计算机数值模拟仿真" class="headerlink" title="计算机数值模拟仿真"></a>计算机数值模拟仿真</h2><p>而使用计算机仿真技术对星载计算机系统进行抗辐照性能评估，使得设计人员能在设计初期对系统可靠性有准确把握。使用计算机仿真软件可以对空间粒子在器件上的作用机理进行模拟仿真，具有效率高、成本低和效果好等诸多优点。</p><h1 id="单粒子效应仿真方法"><a href="#单粒子效应仿真方法" class="headerlink" title="单粒子效应仿真方法"></a>单粒子效应仿真方法</h1><h2 id="器件级仿真"><a href="#器件级仿真" class="headerlink" title="器件级仿真"></a>器件级仿真</h2><p>器件级单粒子效应仿真是通过 TCAD 仿真工具对器件或者小型电路进行建模，通过求解三大方程得到精确的器件模型。最后来模拟空间环境对器件模型产生的辐照效应，以实现对单粒子效应进行分析，是目前业内单粒子效应机理研究方向的主要仿真方法。</p><h2 id="电路级仿真"><a href="#电路级仿真" class="headerlink" title="电路级仿真"></a>电路级仿真</h2><p>电路级单粒子效应仿真忽略了器件底层的物理细节，更加偏重晶体管层面的仿真，通过用SPICE 工具支持的语法描述单粒子脉冲，实现对电路的单粒子效应故障注入。是研究模拟电路以及小规模数字电路单粒子效应的主流仿真手段。</p><h2 id="逻辑门级仿真"><a href="#逻辑门级仿真" class="headerlink" title="逻辑门级仿真"></a>逻辑门级仿真</h2><p>逻辑门级仿真主要是通过预设网表中每个逻辑门的单位时间故障（Failure in Time，FIT），然后分析Verilog 门级网表结构，从而得到整个门级网表的FIT 和软错误率，这种仿真方法有着计算速度快，支持电路规模大的特点。</p><h2 id="RTL-级仿真"><a href="#RTL-级仿真" class="headerlink" title="RTL 级仿真"></a>RTL 级仿真</h2><p>RTL 级故障注入仿真对电路系统的 RTL 级模型进行仿真，由于仿真方法的模型层次较高因此仿真速度也最快。</p><h1 id="星载计算机系统"><a href="#星载计算机系统" class="headerlink" title="星载计算机系统"></a>星载计算机系统</h1><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210272021408.png" alt="|500"><br>通过SiP 封装技术，将系统各模块封装在两个腔体中，其中<font color="#ffc000">腔体1</font> <u>中包括了3 片SRAM 芯片以及两片Flash 芯片</u>，而<font color="#ffc000">腔体2</font> <u>中包括了2 片SRAM 芯片、一片Flash 芯片以及处理器芯片</u>。系统使用倒装技术，片间用金键合丝以及TSV 等技术实现系统互连。</p><ul><li>处理器模块是基于SPARC V8 指令集架构的开源LEON处理器进行开发设计，该模块<u>在系统中负责对外设的控制与通信，程序的读取与执行</u>，是系统的核心。</li><li><u>Flash 与部分SRAM 模块负责程序指令的存储</u>，</li><li><u>其余SRAM 模块负责保存系统的运行数据</u>。</li></ul><p>当系统上电后，处理器先读取保存在Flash 中的boot 初始化程序，对系统寄存器等模块初始化之后，将后续执行的程序，从Flash 转存至指令SRAM中，随后地址跳转到指令SRAM 进行程序的取指、译码、执行、访存、回写等操作。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210272105446.png" alt="|500"></p><p>SRAM的加固 ^a9ac5d</p><p>对存有初始化程序的 Flash，以及存有指令的 SRAM  进行了模块级的三模冗余（Triple Modular Redundancy，TMR）加固设计。<br>加固设计后的目标系统结构就变为下图<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210272109479.png" alt="|500"><br>在为星载计算机系统存入程序时，对<u>三块 Flash 和指令 SRAM 都存储相同的程序</u>，这样在收到外部读取请求信号时，存储器的输出端口中所有数据位都先会通过三输入表决器后再输出到数据总线，从而提高了系统在辐照环境下的工作稳定性。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210291457431.png"><br>采用ECC算法进行SRAM加固模块如下<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210300843699.png"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210300845185.png" alt="|600"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210300847213.png"> ^df961a</p><h1 id="星载计算机系统模型的搭建"><a href="#星载计算机系统模型的搭建" class="headerlink" title="星载计算机系统模型的搭建"></a>星载计算机系统模型的搭建</h1><h2 id="leon2处理器建模（管级网表的提取）"><a href="#leon2处理器建模（管级网表的提取）" class="headerlink" title="leon2处理器建模（管级网表的提取）"></a>leon2处理器建模（管级网表的提取）</h2><p>想要对OBC-SiP 系统进行单粒子效应仿真，首先就必须得到OBC-SiP 的系统模型。</p><p>Leon2 开源代码由可综合的超高速集成电路硬件描述语言（VHDL）代码构成，为了建立 Leon2  处理器的 SPICE 电路模型并进行单粒子效应仿真，需要将 Leon2 处理器寄存器传输 级（RTL）的 VHDL 代码转换为 SPICE 描述的晶体管级网表，<br>需要如下两个步骤：<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210271629166.png"></p><h3 id="DC综合"><a href="#DC综合" class="headerlink" title="DC综合"></a>DC综合</h3><ul><li><strong>转换</strong><br>综合工具首先会将 Leon2 处理器的 VHDL 的描述转换成一个与工艺独立的 RTL 级网表(网表中 RTL 模块通过连线互联)。</li><li><strong>映射</strong><br>然后根据具体指定的工艺库,将 RTL 级网表映射到工艺库上,成为一个门级网表。</li><li><strong>优化</strong><br>最后再根据设计者施加的诸如延时、面积方面的约束条件,对门级网表进行优化。<blockquote><p>[!info]+ DC综合<br>Synopsys 公司的DC（Design Compiler）是目前业内使用最广泛的电路综合工具，可以很方便地将硬件描述语言的可综合代码设计转换到基于标准单元库的门级网表。<br>DC 主要包括<span style="background:rgba(240, 200, 0, 0.2)">转换(translation)</span>、<span style="background:rgba(240, 200, 0, 0.2)">映射(mapping)</span>及<span style="background:rgba(240, 200, 0, 0.2)">优化(optimization)</span>三个步骤。<br>综合工具首先将电路设计代码设计读入内存，用“gtech.db”库中的基本单元将设计转换为基本电路，然后根据综合人员给定的约束设置，对电路性能、面积等参数进行计算并优化，然后将优化之后的电路映射到用户设定的工艺库上<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210261019502.png" alt="|500"></p></blockquote></li></ul><h3 id="管级网表转换"><a href="#管级网表转换" class="headerlink" title="管级网表转换"></a>管级网表转换</h3><p>Mentor 公司提供的<span style="background:rgba(240, 200, 0, 0.2)"> Calibre工具</span>在数字 IC 后端设计中具有广泛的应用。其中 <span style="background:rgba(240, 200, 0, 0.2)">v2lvs命令</span>可以将 DC 综合生成的门级网表转换为 SPICE 管级网表，为后续的处理器故障注入仿真提供基础文件。</p><blockquote><p>[!info]+ 管级网表转换<br>Mentor Graphics 公司的Calibre 工具在IC 后端设计中必不可少，其中Calibre 中的v2lvs 命令能够很方便的将Verilog 的门级网表转换成我们所需要的SPICE 管级网表<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210261023891.png" alt="|500"></p></blockquote><h2 id="存储器模块建模"><a href="#存储器模块建模" class="headerlink" title="存储器模块建模"></a>存储器模块建模</h2><h3 id="Flash模块建模"><a href="#Flash模块建模" class="headerlink" title="Flash模块建模"></a>Flash模块建模</h3><p>Flash 主要器件结构是浮栅晶体管等特殊器件，由于其工艺的特殊性，无法建立该模块的SPICE 晶体管级模型，因此只对Flash 模块进行行为级建模。</p><h3 id="SRAM-模块建模"><a href="#SRAM-模块建模" class="headerlink" title="SRAM 模块建模"></a>SRAM 模块建模</h3><p>SRAM 模块内部由多个子模块组成，可以大致分为：存储单元电路模块、逻辑接口电路模块、行译码电路模块、列译码器和灵敏放大器电路模块几个部分。存储器设计流程与上文中LEON2 处理器设计流程不同，并且灵敏放大器电路等模块和存储单元等模块使用工艺不同，无法按照“DC 综合-管级网表转换”这样的流程来进行建模。<u>采用 Memory Compiler 工具，直接生成其行为级模型和 SPICE 管级模型</u></p><h1 id="SiP-互连建模"><a href="#SiP-互连建模" class="headerlink" title="SiP 互连建模"></a>SiP 互连建模</h1><p>单根金丝可以用图示的简化模型进行电路等效<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210272114894.png" alt="|500"><br>在对系统各模块进行连接时，依据项目组提供资料，为键合金丝的等效模型选择合适的寄生参数，在SPICE 网表中将系统各模块的端口进行连接。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210272116911.png" alt="|500"></p><h2 id="星载计算机系统模型构建（-Leon2-处理器-外部电路）"><a href="#星载计算机系统模型构建（-Leon2-处理器-外部电路）" class="headerlink" title="星载计算机系统模型构建（ Leon2 处理器+外部电路）"></a>星载计算机系统模型构建（ Leon2 处理器+外部电路）</h2><p>完成了 OBC-SiP 系统中各模块电路的建模工作之后，就可以对整个目标系统进行模型搭建。依据LEON2 处理器中的可编程存储器控制器设计要求，以及各存储模块的读写时序，通过连线将各模块进行连接，最终得到整个OBC-SiP 目标系统模型。<br>根据获得的 Leon2 处理器 SPICE 管级网表模型，对其进行外部电路扩展，构成一个小型的星载计算机系统模型，在该模型中存在以下几个模块：①Leon2 处理器核；②指令 SRAM 模块；③数据 SRAM 模块；④初始化指令 SRAM 模块。</p><h1 id="单粒子效应故障注入技术"><a href="#单粒子效应故障注入技术" class="headerlink" title="单粒子效应故障注入技术"></a>单粒子效应故障注入技术</h1><p>对于故障注入技术，按照注入的电路层次不同，可以分为硬件故障注入，软件故障注入，RTL 级故障注入与 SPICE 网表故障注入等。</p><h2 id="软件层次故障注入技术"><a href="#软件层次故障注入技术" class="headerlink" title="软件层次故障注入技术"></a>软件层次故障注入技术</h2><p>软件故障注入技术是在软件层次来实现处理器的故障注入方法，在处理器程序编译或者运行时动态的修改执行程序，或者人为设置寄存器值来改变处理器的运行状态。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>成本低，故障注入位置灵活可控，具有相当高的自由性。</li><li>可通过脚本或者程序可以实现批量的故障注入操作，完成故障注入的全自动化设置。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>只能对计算机体系结构中可配置的寄存器进行故障注入设置，无法对不可配置部分进行故障注入，具有局限性，无法实现对整体芯片的抗辐射可靠性评估。</li><li>软件层次注入一般只对寄存器进行注入，无法精确模拟单粒子效应的实际注入情况，如注入组合逻辑模块等。</li><li>故障注入技术一般需要添加一段额外的处理器程序如故障注入控制程序，结果收集及分析模块等，因此需要确保额外的程序不会影响到原本处理器的正常工作且不会对故障注入结果造成干扰，这通常是难以精确控制的。</li></ul><h2 id="硬件层次故障注入技术"><a href="#硬件层次故障注入技术" class="headerlink" title="硬件层次故障注入技术"></a>硬件层次故障注入技术</h2><p>硬件层次的故障注入是在芯片流片后后进行是对实际的处理器芯片进行故障注入，通用的方法主要有引脚级注入法、重离子加速注入法、激光注入法以及电源电压注入法等，这是最接近于实际的故障环境。</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>采用对实际芯片进行故障注入的方式来分析芯片的抗单粒子效应能力，可以在实际的处理器芯片中触发瞬态故障，翻转故障等，这是最贴近于实际情况的故障注入方式。</p><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>需要昂贵的硬件设备，如离子加速器造价昂贵，且资源紧张*</li><li>硬件层次的故障注入极有可能会对芯片造成损伤，代价高昂，增加了设计成本。</li><li>该层次的故障注入对象为实体芯片，必须等芯片流片后才能进行故障注入，增加了芯片的设计与制造周期。</li><li>难以将故障注入技术实现全自动化，因为芯片级的故障注入需要相当数量的故障次数才能使故障注入分析结果具有统计意义，这需要耗费大量的时间。</li><li>难以精确定位引起芯片运行错误的故障注入点。</li></ul><h2 id="RTL-层次故障注入技术"><a href="#RTL-层次故障注入技术" class="headerlink" title="RTL 层次故障注入技术"></a>RTL 层次故障注入技术</h2><p>RTL 级故障注入技术是针对系统电路的行为级模型进行故障注入，其通常用硬件描述语言如 VHDL，verilog HDL 来实现。</p><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul><li>硬件描述语言具有对电路良好的建模与抽象功能，可以从不同的抽象级别来对处理器内部各个模块进行单粒子效应故障注入，如行为级故障注入仿真，逻辑门级故障注入仿真。</li><li>在 RTL级可以精确地对每个逻辑门或者接口信号进行数值仿真与分析，所以可以精确地控制故障注入的注入时间，注入位置等，更加有利于监控单粒子注入后处理器系统的故障行为。</li><li>在电路设计阶段就能进行故障注入与单粒子效应敏感性分析。根据分析结果就可以在设计阶段采取相应的加固措施来提高处理器的抗辐射能力，因此降低了抗辐射电路的设计成本与与设计周期，有效地加快了抗辐射芯片的研发速度。</li></ul><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><p>verilog HDL 等硬件描述语言进行建模的电路属于数字电路，只有 0 与 1 两种工作状态，对应于模拟电路中的高低电平两种状态。使用 RTL 级故障注入技术忽略了单粒子效应的底层物理细节，只是单纯的改变电路的工作状态。而高能粒子入射期间后引发的瞬态脉冲电流有可能位于高低电平之间的中间区域，RTL 级故障注入技术无法精确地对这种类型的粒子入射进行模拟入射。</p><h2 id="SPICE-层次网表故障注入技术"><a href="#SPICE-层次网表故障注入技术" class="headerlink" title="SPICE 层次网表故障注入技术"></a>SPICE 层次网表故障注入技术</h2><p>SPICE 级网表故障注入技术是针对电路的管级网表模型进行仿真的。从管级网表的特征来分析，因为管级网表体现了电路晶体管的物理特性和电学特性，涉及到具体电压值的改变，不是由简单的 0 或者 1 来表示，表示方式更加准确，因此在最底层晶体管级进行故障注入是最贴近于实际情况且最精确的故障注入技术。</p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><ul><li>首先需要对目标处理器系统进行高精度的 SPICE 建模，进而建立正确的管级模型。*</li><li>需要建立准确的故障注入源，一般情况下，管级网表的故障注入源由器件级单粒子效应仿真结果得到的电流响应数据为基础，通过数学模型的拟合，可以得到不同 LET 值的瞬态脉冲电流源模型作为故障注入源。</li></ul><h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><p>贴近底层晶体管，能够更加准确实际的描述单粒子效应故障入射的情况。</p><h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><p>在仿真过程了添加了许多物理和电学特性，这导致了 SPICE 管级网表进行仿真的速度过慢，一般只支持小型集成电路。</p><h1 id="SPICE-混合仿真"><a href="#SPICE-混合仿真" class="headerlink" title="SPICE 混合仿真"></a>SPICE 混合仿真</h1><p>既考虑了器件级的仿真精度，又兼顾了电路级、RTL 级的仿真规模与速度，解决了现有方法的部分不足。</p><h2 id="单粒子脉冲注入模型建模"><a href="#单粒子脉冲注入模型建模" class="headerlink" title="单粒子脉冲注入模型建模"></a>单粒子脉冲注入模型建模</h2><p>需要通过器件级单粒子效应仿真来分析单粒子瞬态电流数据，得到单粒子效应在不同LET 条件下，产生的瞬态电流脉冲注入模型。<br>首先通过器件级离子注入仿真粒子入射MOSFET 器件电流数据，对数据进行处理，转换为符合SPICE 语法的PWL 电流源模型，最终得到不同能量粒子轰击半导体器件产生的单粒子瞬态电流脉冲注入模型</p><h2 id="提取电路敏感节点"><a href="#提取电路敏感节点" class="headerlink" title="提取电路敏感节点"></a>提取电路敏感节点</h2><p>对待注入模块的 SPICE 网表进行处理，提取出该模块的敏感节点，得到敏感节点列表文件。</p><blockquote><p>[!info]+ 电路敏感节点<br>NMOS 收集迁移率更高的电子，因此在相同入射条件，相同时间内，NMOS 总能收集更多的载流子从而产生更大的单粒子瞬态电流，体现出更强的单粒子瞬态效应。本文定义电路敏感节点为SPICE 网表中每个NMOS 晶体管的漏极。<u>本文定义电路敏感节点为SPICE 网表中每个NMOS 晶体管的漏极。</u></p></blockquote><h2 id="敏感节点故障注入"><a href="#敏感节点故障注入" class="headerlink" title="敏感节点故障注入"></a>敏感节点故障注入</h2><p>得到待注入模块网表的敏感节点列表之后，就可以对该模块的敏感节点进行单粒子随机或定点故障注入。<br>该步骤用 Perl 脚本实现，自动生成故障注入文件。通过用户设定的<span style="background:rgba(240, 200, 0, 0.2)">单粒子 LET值</span>，<span style="background:rgba(240, 200, 0, 0.2)">注入时间范围</span>，<span style="background:rgba(240, 200, 0, 0.2)">注入时间步长（纳秒）</span>，<span style="background:rgba(240, 200, 0, 0.2)">注入模块名称</span>等参数，脚本会结合待注入模块的敏感节点列表和单粒子脉冲注入模型，对脉冲电流源进行参数处理，得到包含单粒子注入信息的故障注入文件。<br><u></u></p><h2 id="SPICE-混合仿真-1"><a href="#SPICE-混合仿真-1" class="headerlink" title="SPICE 混合仿真"></a>SPICE 混合仿真</h2><p>获得单粒子瞬态脉冲电流源模型以及对待注入模块的敏感节点提取并生成故障注入文件之后，就可以使用 SPICE 仿真工具对目标系统进行单粒子效应仿真。<br>然而对于规模较大的星载计算机系统，直接使用 SPICE 仿真器进行电路级单粒子仿真，需要的仿真时间以及运算资源都会非常大。<br>因此本文（柳炜鑫论文）在电路级基础上进行改进，提出基于SPICE 混合仿真的单粒子效应仿真方法。</p><p><span style="background:rgba(136, 49, 204, 0.2)">第一步</span>，讨论单粒子注入方案，对目标系统进行模块划分。明确单粒子注入位置（<u>如整数单元、总线控制器或者SRAM 等等</u>），根据注入需求，将系统划分成各种功能模块。  </p><p><span style="background:rgba(136, 49, 204, 0.2)">第二步</span>，分别搭建系统模块不同层级的模型。完成目标系统的模块划分后，为了减小仿真中SPICE 网表的规模，本文采用的方案是<u>对待注入模块需要得到SPICE管级模型，而对于不需要进行单粒子故障注入的模块则可以建立其行为级模型或 RTL模型</u>。  </p><p><span style="background:rgba(136, 49, 204, 0.2)">第三步</span>，<u>完成接口网络（Mixed Nets）的搭建。这个模块是用于在混合信号仿真中实现模拟和数字模块之间连接的信号网络，位于模拟模块和数字模块的边界。</u>在混合仿真中，根据需要仿真器需要根据信号的传输方向，将混合信号进行 D2A 转换，以将数字逻辑值转换为模拟电压量，反之亦然。该接口网络为理想网络，D2A 转换中的默认高低电压值分别是SPICE 网表中的VDD 和0V。A2D 转换中默认的电压阈值为VDD 的50％。可以根据需要使用d2a 和a2d 命令对这些值进行修改。</p><p><span style="background:rgba(136, 49, 204, 0.2)">第四步</span>，完成系统的连接。将各模块所搭建的不同层级模型，通过接口网络实现整个目标系统的连接。</p><p><span style="background:rgba(136, 49, 204, 0.2)">第五步</span>，进行混合仿真。得到了目标系统的混合模型，就可以使用 VCS-MX 和Finesim Pro 进行仿真工作。  </p><p><span style="background:rgba(136, 49, 204, 0.2)">第六步</span>，输出仿真结果。等待仿真结束后，依据仿真网表中节点电压测量语句，会将需要观测的节点电压值通过文本的形式进行输出，最终得到单粒子效应仿真的结果。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210272139793.png" alt="|500"></p><p><strong>以OBC-SiP 目标系统模型进行单粒子效应仿真为例</strong><br>首先完成模块划分，<u>本例将处理器和 SRAM 作为待注入模块，因此系统中处理器和 SRAM 使用 SPICE 管级模型，而 Flash 模块使用行为级模型。  </u><br>然后是完成接口网络搭建，对于使用VCS-MX和Finesim Pro进行VHDL / Verilog-SPICE 的流程中，该工具会自动插入A2D 和D2A 模块。<br>接下来使用接口网络完成系统的连接；完成系统混合模型之后，输入命令提交仿真。<br>等待仿真结束，就完成了一次对 OBC-SiP 目标系统的单粒子故障注入仿真，接下来就可以对仿真器输出的结果进行仿真比对以及系统错误统计。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210262147339.png" alt="|500"></p><h1 id="柳师兄论文调研"><a href="#柳师兄论文调研" class="headerlink" title="柳师兄论文调研"></a>柳师兄论文调研</h1><h1 id="荀师兄论文调研"><a href="#荀师兄论文调研" class="headerlink" title="荀师兄论文调研"></a>荀师兄论文调研</h1><p>通过 Perl 与 Shell 脚本实现了仿真中的数据测量、结果比对等工<br>作，并针对混合仿真<u>提出了一种混合电路模块快速划分方法</u>，有效地提升了仿真效率。<br><u>提出了 SiP 系统模块级单粒子效应敏感性的仿真方案</u>；<u>采用三阶矩阵乘法的程序指令，分别针对目标 SiP 系统中的整数处理单元、寄存器堆、缓存、AMBA 总线控制器、存储控制器、指令 SRAM 和数据 SRAM 进行仿真分析</u>，发现数据 SRAM 具有 5.57%的系统软错误率，远高于系统其余模块，需要在系统抗单粒子效应加固设计时重点考虑。<br>基于 SiP 系统模块级单粒子效应敏感性的仿真方案，提出了面积等效的分析方法，进一步实现了全电路的混合仿真。</p><h1 id="吕师兄论文调研"><a href="#吕师兄论文调研" class="headerlink" title="吕师兄论文调研"></a>吕师兄论文调研</h1><p>实现了一种<u>基于断点分析的多点故障注入技术</u>，该技术在传统的单点故障注入方法基础上进行改进而来，通过在单粒子效应系统级仿真过程中加入断点的方式，在上一级仿真结果的基础上加入下一级故障注入点，这样可以有效地多次注入故障注入点，同时保证了相邻故障注入点之间的结果非相干性。<br>通过在星载计算机系统中加载矩阵乘法程序并进行 SPICE 仿真，得到在运行该程序的基础上可以实现的最小故障注入间隔时间。</p>]]></content>
      
      
      <categories>
          
          <category> 数字IC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 星载计算机 </tag>
            
            <tag> 单粒子效应 </tag>
            
            <tag> leon2处理器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SystemVerilog课程笔记(七)</title>
      <link href="/2022/10/29/systemverilog-ke-cheng-bi-ji-qi/"/>
      <url>/2022/10/29/systemverilog-ke-cheng-bi-ji-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="1-利用类的继承，将多种test包含进base-test中"><a href="#1-利用类的继承，将多种test包含进base-test中" class="headerlink" title="1. 利用类的继承，将多种test包含进base test中"></a>1. 利用类的继承，将多种test包含进base test中</h1><h2 id="1-1-改进"><a href="#1-1-改进" class="headerlink" title="1.1 改进"></a>1.1 改进</h2><p>(1)将stimulator、monitor、generator、checker的例化、连接、run放入rt_env类中；<br>(2)genarator_to_stimulator的数据传输语句块放入rt_env类中的task run；<br>(3)将generate_data_proc产生数据的语句块放入对应的单通道/双通道/多通道测试的类中；</p><pre class=" language-systemverilog"><code class="language-systemverilog">class rt_env;  //rt_env包含各个组件的例化、连接、run)    ...endclass    ...endclassclass rt_base_test;//rt_base_test包含rt_env，rt_env包含各个组件    rt_env env;    ...endclassclass rt_single_ch_test extends rt_base_test;//单个通道测试    ...endclassclass rt_two_ch_test extends rt_base_test;//两个通道测试    ...endclassclass rt_two_ch_same_chout_test extends rt_two_ch_test;    ...endclassclass rt_multi_ch_test extends rt_base_test;//多个通道测试    ...endclassclass rt_full_ch_test extends rt_multi_ch_test;    ...endclass</code></pre><p>各个class层次结构如下：</p><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211181107662.png" width="60%" height="60%"></div><h2 id="1-2-改进后的tb-sv"><a href="#1-2-改进后的tb-sv" class="headerlink" title="1.2 改进后的tb.sv"></a>1.2 改进后的tb.sv</h2><pre class=" language-systemverilog"><code class="language-systemverilog">class rt_packet;  bit [3:0] src;  bit [3:0] dst;  bit [7:0] data [];  function new();  endfunction  function void set_members(bit [3:0]src, bit [3:0]dst, bit[7:0]data []);    this.src = src;    this.dst = dst;    this.data = data;  endfunction  function string sprint();//打印packet信息的函数    sprint = {sprint , $sformatf("src = %0d\n",src)};    sprint = {sprint , $sformatf("dst = %0d\n",dst)};    sprint = {sprint , $sformatf("data_length = %0d\n",data.size())};    foreach(data[i])        sprint = {sprint , $sformatf("data[%0d] = 'h%0x\n", i, data[i])};  endfunction  function bit compare(rt_packet p);//输入exp_pkt        if(dst == p.dst && data == p.data)            compare = 1;        else             compare = 0;  endfunctionendclassinterface rt_interface();    logic clock;    logic reset_n;    logic [15:0] din;    logic [15:0] frame_n;    logic [15:0] valid_n;    logic [15:0] dout;    logic [15:0] valido_n;    logic [15:0] busy_n;    logic [15:0] frameo_n;endinterface//********************************** stimulator **********************************//class rt_stimulator;    virtual rt_interface intf;//class里的接口不能用端口的方式描述，需要添加virtual关键字，在类里面用接口的指针//for debug purpose from waveform//定义检测状态的变量  typedef enum {DRV_RESET,DRV_IDLE,DRV_ADDR,DRV_PAD,DRV_DATA} drv_state_t;  drv_state_t dbg_state;    byte unsigned dbg_din_chnl0_data;   int src_chnl_status[int];  //关联数组，后面int：src_chnl的number；前面int：dest_chnl的Number ？？    //generator传送p给stimulator  rt_packet pkts[$];//定义stimulator中的的队列pkts  function void put_pkt(input rt_packet p);    pkts.push_back(p);//将generator中传过来的p放入stimulator的pkts中(在pkts队列尾插入p)  endfunctiontask run();    fork        drive_reset(); //reset动作        get_packet_and_drive(); //drive_chnl动作    join_noneendtask    task drive_reset();//reset    forever begin        @(negedge intf.reset_n);        dbg_state <= DRV_RESET;        intf.din <= 0;        intf.frame_n <= '1;//等效16'hFFFF        intf.valid_n <= '1;    endendtask// 发送数据task get_packet_and_drive();//drive_chnl    //rt_packet_t p;  @(negedge intf.reset_n);  repeat(10) @(posedge intf.clock);//延迟10个时钟周期  forever begin    automatic rt_packet p;//声明一个动态的    wait(pkts.size()>0);    p = pkts.pop_front();//将p从队列pkts里面取出    fork//后台触发线程，触发线程在后台运行，继续执行剩下内容        begin            wait_src_chnl_avail(p);//判断src chnl是否被占用，是否需要等待            drive_chnl(p);//从P中拿到发送端口，目标端口，发送数据            set_src_chnl_avail(p);        end    join_none    endendtasktask  wait_src_chnl_avail(rt_packet p);//判断src chnl是否被占用，是否需要等待    if(!src_chnl_status.exists(p.src))//src_chnl_status关联数组里面不含p.src，(表示未占用任何dest_chnl,一开始不满足）        src_chnl_status[p.src] = p.dst;//表示当前正在使用src_chnl,对应dest_chnl就是p.dst（p.src端口在向p.dst端口发送数据）    else if(src_chnl_status[p.src] >= 0)//如果在给0,1,2...dest_chnl发送数据（被占用），需要等待,，否则不需要等待        wait(src_chnl_status[p.src] == -1);//直到src_chnl_status[p.src] == -1(自定义的dest_chnl端口数之外任意的数，表示未占用任何dest_chnl)endtaskfunction  set_src_chnl_avail(rt_packet p);    src_chnl_status[p.src] = -1;//如果chnl发送完后，把src_chnl置回来(自定义的dest_chnl端口数之外任意的数，表示未占用任何dest_chnl)endfunctiontask  drive_chnl(rt_packet p);  $display("@%0t:[DRV] src_chnl[%0d] & dest_chnl[%0d] data trans started with packet: \n%s",$time,p.src,p.dst,p.sprint());    // drive address phase 输入地址位阶段for(int i=0;i<4;i++)begin  //4 clock  @(posedge intf.clock);  dbg_state <=DRV_ADDR;  intf.din[p.src] <= p.dst[i];  intf.valid_n[p.src] <= $urandom_range(0,1);//valid_n在din的地址输入时间段可为任意值x  intf.frame_n[p.src] <= 1'b0;//frame_n需要为低end    // drive pad phase //隔离阶段  for (int i=0;i<5;i++)begin  //5 clock    @(posedge intf.clock);    dbg_state <=DRV_PAD;    intf.din[p.src] <= 1'b1;    intf.valid_n[p.src] <= 1'b1;//valid_n需为高电平    intf.frame_n[p.src] <= 1'b0; //frame_n需为低电平  end    // drive data phase 传输数据阶段  foreach(p.data[id])begin    for(int i=0;i<8;i++)begin     @(posedge intf.clock);      dbg_state <=DRV_DATA;      dbg_din_chnl0_data <= p.data[id];      intf.din[p.src] <= p.data[id][i];      intf.valid_n[p.src] <=1'b0;      intf.frame_n[p.src] <= (id == p.data.size()-1 && i == 7) ? 1'b1 : 1'b0;//packet最后一位输出数据时frameo_n为高    end  end// drive idle phase 闲置（没有数据传输）阶段  @(posedge intf.clock);  dbg_state <=DRV_IDLE;  dbg_din_chnl0_data <= 0;  intf.din[p.src] <= 1'b0;  intf.valid_n[p.src] <= 1'b1;  intf.frame_n[p.src] <= 1'b1;  $display("@%0t: [DRV]src_chnl[%0d],dest_chnl[%0d] data trans finished",$time,p.src,p.dst);endtaskendclass//********************************** generator **********************************//class rt_generator;//generator产生数据交给stimulator  rt_packet pkts[$];//定义队列  function void put_pkt(input rt_packet p);    pkts.push_back(p);//将p放入队列pkts里面（在pkts队列尾插入p）  endfunction    task get_pkt(output rt_packet p);    wait(pkts.size() >0 )//队列不为空      p = pkts.pop_front();//将p从队列pkts里面取出，提取队列首元素  endtask  //generate a random packet  function void gen_pkt(int src = -1, int dst = -1);  endfunction    task run();        //TODO  endtask    endclass//********************************** monitor **********************************//class rt_monitor;virtual rt_interface intf;    rt_packet in_pkts[16][$];    rt_packet out_pkts[16][$];    task run();    fork        mon_chnls();    join_noneendtask    task mon_chnls;    foreach(in_pkts[i]) begin        automatic int chid = i;        fork        mon_chnl_in(chid);//每个输入端口均调用mon_chnl_in任务，监测数据输入        mon_chnl_out(chid);//每个输出端口均调用mon_chnl_out任务，监测数据输入        join_none    endendtask    task  mon_chnl_in (bit[3:0]id);//监测数据输入的任务    rt_packet pkt;//定义结构体变量    forever begin    //clear content for the same struct variable。清除pkt    pkt = new();    pkt.src = id;//第id个输入端口    //monitor specific channel-in data and put it into the queue    // monitor address phase    @(negedge intf.frame_n[id]);//监测frame_n下降沿(frame_n由时钟驱动)    for(int i=0; i<4; i++)begin        @(negedge intf.clock);//frame_n下降沿后监测4个clk negedge        pkt.dst[i]= intf.din[id];        end        $display ("@%0t: [MON] src_chn1[%0d] & dest_chn1[%0d] data trans started",$time,pkt.src,pkt.dst);    //pass pad phase 不考虑pad阶段是否满足协议要求    repeat(5) @(negedge intf.clock);    do begin        pkt.data = new [pkt.data.size + 1](pkt.data);//创建动态数组并复制pkt.data        for ( int i=0; i<8; i++) begin            @(negedge intf.clock); //在8个clk negedge监测8bit数据            pkt.data[pkt.data.size-1][i] = intf.din[id];        end    end while(!intf.frame_n[id]);    in_pkts[id].push_back(pkt);//将monitor拿到的数据放入in_pkts    $display("@%0t:[MON] CH_IN src_chnl[%0d] &dest_chnl[%0d ] finished with packet: \n%s",$time,pkt.src,pkt.dst,pkt.sprint());    endendtasktask  mon_chnl_out(bit[ 3:0]id);//监测数据输出的任务    rt_packet pkt;    forever begin        //clear content for the same struct variable        pkt = new();        pkt.src = 0;        pkt.dst = id;        @(negedge intf.frameo_n[id]);        $display( "@%0t: [MON] CH_OUT dest_chn1[%0d] data trans started",$time,pkt.dst);        do begin        pkt.data = new [ pkt.data.size + 1](pkt.data);        for(int i=0;i<8; i++) begin            @(negedge intf.clock iff !intf.valido_n[id]);//clock与valido_n信号同时为低            pkt.data[pkt.data.size-1][i]= intf.dout [id];        end    end while(!intf.frameo_n[id]);    out_pkts[id].push_back(pkt);    $display("@%0t: [MON] CH_OUT dest_chn1[%0d] data finished woth packet : \n %s",$time,pkt.dst,pkt.sprint());    //monitor specific channel-out data and put it into the queue    endendtaskendclass//********************************** checker **********************************//class rt_checker;    int unsigned compare_count;    int unsigned error_count;        function new();//赋初值，可有可无，整形变量默认初始值为0        compare_count = 0;        error_count = 0;    endfunction        rt_packet exp_out_pkts[16][$];    rt_monitor mon;        task run();    foreach(exp_out_pkts[i])begin        automatic int chid = i;        fork            do_routing(chid);            do_compare(chid);        join_none        end    endtask        task do_routing(bit[3:0] id);//将monitor中采样到的输入数据放入期望的输出端队列中        rt_packet pkt;        forever begin            wait(mon.in_pkts[id].size > 0);            pkt = mon.in_pkts[id].pop_front();//从monitor中拿到in_pkts队列数据放入pkt            exp_out_pkts[pkt.dst].push_back(pkt);//将pkt数据放入对应期望的dest_chnl            end    endtask         task do_compare(bit[3:0] id);//比较采集的实际输出与期望输出        rt_packet exp_pkt, act_pkt;        forever begin            wait(mon.out_pkts[id].size > 0 && exp_out_pkts[id].size > 0);//实际采样数据与期望数据都有值            act_pkt = mon.out_pkts[id].pop_front();//实际数据为monitor采样的输出数据            exp_pkt = exp_out_pkts[id].pop_front();//期望数据为monitor采样到的输入数据            if(act_pkt.compare(exp_pkt))begin//如果exp_pkt与act_pkt比较成功，返回1                $display("[CHK] data compare success with packet : \n%s",act_pkt.sprint());            end            else begin                $display("[CHK] data compare failure with actual packet : \n%s \nexpected packet : \n%s", act_pkt.sprint(), exp_pkt.sprint());                error_count++;            end                compare_count++;        end    endtask         function void do_report();        $display("TOTAL COMPARING %0d times",compare_count);        if(!error_count)            $display("TEST PASSED!");        else begin            $display("TEST FAILED!");            $display("TOTAL ERROR %0d times", error_count);        end    endfunctionendclass//**********************************  **********************************//class rt_env;//rt_env包含各个组件    rt_stimulator stim;    rt_monitor mon;    rt_generator gen;    rt_checker chk;            function new(virtual rt_interface intf);        //build stage,例化        stim = new();        gen = new();        mon = new();        chk = new();        //connect sage，连接        stim.intf = intf;        mon.intf = intf;        chk.mon = mon;//check拿monitor句柄，即拿monitor中in_pkts与out_pkts队列    endfunction         task run();        rt_packet p;        //run stage，run        fork            stim.run();//class里面的函数不会自动调用，需要手动调用            gen.run();            mon.run();            chk.run();            begin:genarator_to_stimulator_proc//取出genarator中的数据给stimulator                 forever begin//此处不需要延迟0，执行task run的时候默认function new已执行                    gen.get_pkt(p);//get句柄                    stim.put_pkt(p);//put句柄                end            end        join_none                    endtask    endclassclass rt_base_test;//rt_base_test包含rt_env，rt_env包含各个组件    rt_env env;        function new(virtual rt_interface intf);        env = new(intf);    endfunction        task run();        fork            env.run();        join_none    endtaskendclass    class rt_single_ch_test extends rt_base_test;//单个通道测试        function new(virtual rt_interface intf);            env = new(intf);        endfunction                task run();            rt_packet p;            super.run();//调用父类的run，即执行env.run()，进行组件的例化等操作            p = new();//obj1(每次put_pkt都需要new一下)            p.set_members(0,3,'{8'h33,8'h77});//注意层次变化，在env层次下面            env.gen.put_pkt(p);            p = new();//obj2            p.set_members(0,5,'{8'h55,8'h66});            env.gen.put_pkt(p);        endtask            endclass    class rt_two_ch_test extends rt_base_test;        function new(virtual rt_interface intf);            env = new(intf);        endfunction    endclass        class rt_two_ch_same_chout_test extends rt_two_ch_test;            function new(virtual rt_interface intf);                env = new(intf);            endfunction        endclass    class rt_multi_ch_test extends rt_base_test;//多通道测试        function new(virtual rt_interface intf);            env = new(intf);        endfunction                task run();            rt_packet p;            super.run();            p = new();            p.set_members(0,3,'{8'h33,8'h77});            env.gen.put_pkt(p);            p = new();//每次put_pkt都需要new一下            p.set_members(0,5,'{8'h55,8'h66});            env.gen.put_pkt(p);            p = new();            p.set_members(3,6,'{8'h77,8'h88,8'h22});            env.gen.put_pkt(p);            p = new();            p.set_members(4,7,'{8'haa,8'hcc,8'h33});            env.gen.put_pkt(p);        endtask    endclass        class rt_full_ch_test extends rt_multi_ch_test;            function new(virtual rt_interface intf);                env = new(intf);            endfunction        endclass//**********************************  **********************************////********************************** tb **********************************//module tb;bit clk,rstn;logic [15:0] din, frame_n, valid_n;logic [15:0] dout, valido_n, busy_n, frameo_n;// 产生时钟，周期为10nsinitial     forever #5ns clk <= !clk;// 产生复位信号  initial begin    #2ns rstn <= 1;    #10ns rstn <= 0;    #10ns rstn <= 1;  end//例化router为DUTrouter dut(             .reset_n(rstn),  .clock(clk),  .frame_n(intf.frame_n),  .valid_n(intf.valid_n),  .din(intf.din),  .dout(intf.dout),  .busy_n(intf.busy_n),  .valido_n(intf.valido_n),  .frameo_n(intf.frameo_n));rt_interface intf();//例化接口    assign intf.reset_n = rstn;    assign intf.clock = clk;    rt_single_ch_test  single_ch_test;    rt_multi_ch_test   multi_ch_test;            initial begin : inst_init_proc            single_ch_test = new(intf);            //multi_ch_test  = new(intf);            single_ch_test.run();            //multi_ch_test.run();    end    endmodule </code></pre><h2 id="1-3-仿真结果"><a href="#1-3-仿真结果" class="headerlink" title="1.3 仿真结果"></a>1.3 仿真结果</h2><h3 id="1-3-1-单通道测试-0→3，0→5"><a href="#1-3-1-单通道测试-0→3，0→5" class="headerlink" title="1.3.1 单通道测试(0→3，0→5)"></a>1.3.1 单通道测试(0→3，0→5)</h3><p>单通道测试：</p><pre class=" language-systemverilog"><code class="language-systemverilog">single_ch_test = new(intf);//multi_ch_test  = new(intf);single_ch_test.run();//multi_ch_test.run();</code></pre><p>仿真结果：</p><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211172147174.png" width="60%" height="60%"></div><h3 id="1-3-2-多通道测试-0→3，0→5，3→6，4→7"><a href="#1-3-2-多通道测试-0→3，0→5，3→6，4→7" class="headerlink" title="1.3.2 多通道测试(0→3，0→5，3→6，4→7)"></a>1.3.2 多通道测试(0→3，0→5，3→6，4→7)</h3><p>多通道测试：</p><pre class=" language-systemverilog"><code class="language-systemverilog">//single_ch_test = new(intf);multi_ch_test  = new(intf);//single_ch_test.run();multi_ch_test.run();</code></pre><p>仿真结果：</p><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211172152813.png" width="60%" height="50%"></div><h1 id="2-增加数据传输完成信号、checker的判断、test-name"><a href="#2-增加数据传输完成信号、checker的判断、test-name" class="headerlink" title="2. 增加数据传输完成信号、checker的判断、test name"></a>2. 增加数据传输完成信号、checker的判断、test name</h1><h2 id="2-1-改进"><a href="#2-1-改进" class="headerlink" title="2.1 改进"></a>2.1 改进</h2><p><strong>(1)增加数据传输完成信号，数据传输完成后调用checker里的report进行报告</strong></p><pre class=" language-systemverilog"><code class="language-systemverilog">task report();    wait(gen_trans_done == 1);    #(test_drain_time_us * 1us);    env.report(name);//调用env里的chk.report()进行report    $finish();//terminates the current testendtask</code></pre><p><strong>(2)增加checker比较的判断，需判断exp_out_pkts与mon.out_pkts必须有数据</strong></p><pre class=" language-systemverilog"><code class="language-systemverilog">function void report();    $display("TOTAL COMPARING %0d times",compare_count);    if(!error_count && check_data_buffer())//判断无误且二者有数据        $display("TEST PASSED!");    else begin        $display("TEST FAILED!");        $display("TOTAL ERROR %0d times", error_count);    endendfunctionfunction bit check_data_buffer();    check_data_buffer = 1;    foreach(exp_out_pkts[id])begin         if(exp_out_pkts[id].size != 0)begin//exp_out_pkts必须有数据            check_data_buffer = 0;            $display("exp_out_pkts[%0d] buffer size is not 0(still with %0d data)",id,exp_out_pkts[id].size);        end        if(mon.out_pkts[id].size != 0)begin//mon.out_pkts必须有数据            check_data_buffer = 0;            $display("mon.out_pkts[%0d] buffer size is not 0(still with %0d data)",id,mon.out_pkts[id].size);        end    endendfunction</code></pre><p><strong>(3)增加test的name，并由checker里的report函数打印</strong></p><h2 id="2-2-改进后的tb-sv"><a href="#2-2-改进后的tb-sv" class="headerlink" title="2.2 改进后的tb.sv"></a>2.2 改进后的tb.sv</h2><pre class=" language-systemverilog"><code class="language-systemverilog">class rt_packet;  bit [3:0] src;  bit [3:0] dst;  bit [7:0] data [];  function new();  endfunction  function void set_members(bit [3:0]src, bit [3:0]dst, bit[7:0]data []);    this.src = src;    this.dst = dst;    this.data = data;  endfunction  function string sprint();//打印packet信息的函数    sprint = {sprint , $sformatf("src = %0d\n",src)};    sprint = {sprint , $sformatf("dst = %0d\n",dst)};    sprint = {sprint , $sformatf("data_length = %0d\n",data.size())};    foreach(data[i])        sprint = {sprint , $sformatf("data[%0d] = 'h%0x\n", i, data[i])};  endfunction  function bit compare(rt_packet p);//输入exp_pkt        if(dst == p.dst && data == p.data)            compare = 1;        else             compare = 0;  endfunctionendclassinterface rt_interface();    logic clock;    logic reset_n;    logic [15:0] din;    logic [15:0] frame_n;    logic [15:0] valid_n;    logic [15:0] dout;    logic [15:0] valido_n;    logic [15:0] busy_n;    logic [15:0] frameo_n;endinterface//********************************** stimulator **********************************//class rt_stimulator;    virtual rt_interface intf;//class里的接口不能用端口的方式描述，需要添加virtual关键字，在类里面用接口的指针//for debug purpose from waveform//定义检测状态的变量  typedef enum {DRV_RESET,DRV_IDLE,DRV_ADDR,DRV_PAD,DRV_DATA} drv_state_t;  drv_state_t dbg_state;    byte unsigned dbg_din_chnl0_data;   int src_chnl_status[int];  //关联数组，后面int：src_chnl的number；前面int：dest_chnl的Number ？？    //generator传送p给stimulator  rt_packet pkts[$];//定义stimulator中的的队列pkts  function void put_pkt(input rt_packet p);    pkts.push_back(p);//将generator中传过来的p放入stimulator的pkts中(在pkts队列尾插入p)  endfunctiontask run();    fork        drive_reset(); //reset动作        get_packet_and_drive(); //drive_chnl动作    join_noneendtask    task drive_reset();//reset    forever begin        @(negedge intf.reset_n);        dbg_state <= DRV_RESET;        intf.din <= 0;        intf.frame_n <= '1;//等效16'hFFFF        intf.valid_n <= '1;    endendtask// 发送数据task get_packet_and_drive();//drive_chnl    //rt_packet_t p;  @(negedge intf.reset_n);  repeat(10) @(posedge intf.clock);//延迟10个时钟周期  forever begin    automatic rt_packet p;//声明一个动态的    wait(pkts.size()>0);    p = pkts.pop_front();//将p从队列pkts里面取出    fork//后台触发线程，触发线程在后台运行，继续执行剩下内容        begin            wait_src_chnl_avail(p);//判断src chnl是否被占用，是否需要等待            drive_chnl(p);//从P中拿到发送端口，目标端口，发送数据            set_src_chnl_avail(p);        end    join_none    endendtasktask  wait_src_chnl_avail(rt_packet p);//判断src chnl是否被占用，是否需要等待    if(!src_chnl_status.exists(p.src))//src_chnl_status关联数组里面不含p.src，(表示未占用任何dest_chnl,一开始不满足）        src_chnl_status[p.src] = p.dst;//表示当前正在使用src_chnl,对应dest_chnl就是p.dst（p.src端口在向p.dst端口发送数据）    else if(src_chnl_status[p.src] >= 0)//如果在给0,1,2...dest_chnl发送数据（被占用），需要等待,，否则不需要等待        wait(src_chnl_status[p.src] == -1);//直到src_chnl_status[p.src] == -1(自定义的dest_chnl端口数之外任意的数，表示未占用任何dest_chnl)endtaskfunction  set_src_chnl_avail(rt_packet p);    src_chnl_status[p.src] = -1;//如果chnl发送完后，把src_chnl置回来(自定义的dest_chnl端口数之外任意的数，表示未占用任何dest_chnl)endfunctiontask  drive_chnl(rt_packet p);  $display("@%0t:[DRV] src_chnl[%0d] & dest_chnl[%0d] data trans started with packet: \n%s",$time,p.src,p.dst,p.sprint());    // drive address phase 输入地址位阶段for(int i=0;i<4;i++)begin  //4 clock  @(posedge intf.clock);  dbg_state <=DRV_ADDR;  intf.din[p.src] <= p.dst[i];  intf.valid_n[p.src] <= $urandom_range(0,1);//valid_n在din的地址输入时间段可为任意值x  intf.frame_n[p.src] <= 1'b0;//frame_n需要为低end    // drive pad phase //隔离阶段  for (int i=0;i<5;i++)begin  //5 clock    @(posedge intf.clock);    dbg_state <=DRV_PAD;    intf.din[p.src] <= 1'b1;    intf.valid_n[p.src] <= 1'b1;//valid_n需为高电平    intf.frame_n[p.src] <= 1'b0; //frame_n需为低电平  end    // drive data phase 传输数据阶段  foreach(p.data[id])begin    for(int i=0;i<8;i++)begin     @(posedge intf.clock);      dbg_state <=DRV_DATA;      dbg_din_chnl0_data <= p.data[id];      intf.din[p.src] <= p.data[id][i];      intf.valid_n[p.src] <=1'b0;      intf.frame_n[p.src] <= (id == p.data.size()-1 && i == 7) ? 1'b1 : 1'b0;//packet最后一位输出数据时frameo_n为高    end  end// drive idle phase 闲置（没有数据传输）阶段  @(posedge intf.clock);  dbg_state <=DRV_IDLE;  dbg_din_chnl0_data <= 0;  intf.din[p.src] <= 1'b0;  intf.valid_n[p.src] <= 1'b1;  intf.frame_n[p.src] <= 1'b1;  $display("@%0t: [DRV]src_chnl[%0d],dest_chnl[%0d] data trans finished",$time,p.src,p.dst);endtaskendclass//********************************** generator **********************************//class rt_generator;//generator产生数据交给stimulator  rt_packet pkts[$];//定义队列  function void put_pkt(input rt_packet p);    pkts.push_back(p);//将p放入队列pkts里面（在pkts队列尾插入p）  endfunction    task get_pkt(output rt_packet p);    wait(pkts.size() >0 )//队列不为空      p = pkts.pop_front();//将p从队列pkts里面取出，提取队列首元素  endtask  //generate a random packet  function void gen_pkt(int src = -1, int dst = -1);  endfunction    task run();        //TODO  endtask    endclass//********************************** monitor **********************************//class rt_monitor;virtual rt_interface intf;    rt_packet in_pkts[16][$];    rt_packet out_pkts[16][$];    task run();    fork        mon_chnls();    join_noneendtask    task mon_chnls;    foreach(in_pkts[i]) begin        automatic int chid = i;        fork        mon_chnl_in(chid);//每个输入端口均调用mon_chnl_in任务，监测数据输入        mon_chnl_out(chid);//每个输出端口均调用mon_chnl_out任务，监测数据输入        join_none    endendtask    task  mon_chnl_in (bit[3:0]id);//监测数据输入的任务    rt_packet pkt;//定义结构体变量    forever begin    //clear content for the same struct variable。清除pkt    pkt = new();    pkt.src = id;//第id个输入端口    //monitor specific channel-in data and put it into the queue    // monitor address phase    @(negedge intf.frame_n[id]);//监测frame_n下降沿(frame_n由时钟驱动)    for(int i=0; i<4; i++)begin        @(negedge intf.clock);//frame_n下降沿后监测4个clk negedge        pkt.dst[i]= intf.din[id];        end        $display ("@%0t: [MON] src_chn1[%0d] & dest_chn1[%0d] data trans started",$time,pkt.src,pkt.dst);    //pass pad phase 不考虑pad阶段是否满足协议要求    repeat(5) @(negedge intf.clock);    do begin        pkt.data = new [pkt.data.size + 1](pkt.data);//创建动态数组并复制pkt.data        for ( int i=0; i<8; i++) begin            @(negedge intf.clock); //在8个clk negedge监测8bit数据            pkt.data[pkt.data.size-1][i] = intf.din[id];        end    end while(!intf.frame_n[id]);    in_pkts[id].push_back(pkt);//将monitor拿到的数据放入in_pkts    $display("@%0t:[MON] CH_IN src_chnl[%0d] &dest_chnl[%0d ] finished with packet: \n%s",$time,pkt.src,pkt.dst,pkt.sprint());    endendtasktask  mon_chnl_out(bit[ 3:0]id);//监测数据输出的任务    rt_packet pkt;    forever begin        //clear content for the same struct variable        pkt = new();        pkt.src = 0;        pkt.dst = id;        @(negedge intf.frameo_n[id]);        $display( "@%0t: [MON] CH_OUT dest_chn1[%0d] data trans started",$time,pkt.dst);        do begin        pkt.data = new [ pkt.data.size + 1](pkt.data);        for(int i=0;i<8; i++) begin            @(negedge intf.clock iff !intf.valido_n[id]);//clock与valido_n信号同时为低            pkt.data[pkt.data.size-1][i]= intf.dout [id];        end    end while(!intf.frameo_n[id]);    out_pkts[id].push_back(pkt);    $display("@%0t: [MON] CH_OUT dest_chn1[%0d] data finished woth packet : \n %s",$time,pkt.dst,pkt.sprint());    //monitor specific channel-out data and put it into the queue    endendtaskendclass//********************************** checker **********************************//class rt_checker;    int unsigned compare_count;    int unsigned error_count;        function new();//赋初值，可有可无，整形变量默认初始值为0        compare_count = 0;        error_count = 0;    endfunction        rt_packet exp_out_pkts[16][$];    rt_monitor mon;        task run();    foreach(exp_out_pkts[i])begin        automatic int chid = i;        fork            do_routing(chid);            do_compare(chid);        join_none        end    endtask        task do_routing(bit[3:0] id);//将monitor中采样到的输入数据放入期望的输出端队列中        rt_packet pkt;        forever begin            wait(mon.in_pkts[id].size > 0);            pkt = mon.in_pkts[id].pop_front();//从monitor中拿到in_pkts队列数据放入pkt            exp_out_pkts[pkt.dst].push_back(pkt);//将pkt数据放入对应期望的dest_chnl            end    endtask         task do_compare(bit[3:0] id);//比较采集的实际输出与期望输出        rt_packet exp_pkt, act_pkt;        forever begin            wait(mon.out_pkts[id].size > 0 && exp_out_pkts[id].size > 0);//实际采样数据与期望数据都有值            act_pkt = mon.out_pkts[id].pop_front();//实际数据为monitor采样的输出数据            exp_pkt = exp_out_pkts[id].pop_front();//期望数据为monitor采样到的输入数据            if(act_pkt.compare(exp_pkt))begin//如果exp_pkt与act_pkt比较成功，返回1                $display("[CHK] data compare success with packet : \n%s",act_pkt.sprint());            end            else begin                $display("[CHK] data compare failure with actual packet : \n%s \nexpected packet : \n%s", act_pkt.sprint(), exp_pkt.sprint());                error_count++;            end                compare_count++;        end    endtask         function void report(string name);        $display("TOTAL COMPARING %0d times",compare_count);        if(!error_count && check_data_buffer())//判断无误且二者有数据            $display("TEST [%s] PASSED!",name);        else begin            $display("TEST [%s]FAILED!",name);            $display("TOTAL ERROR %0d times", error_count);        end    endfunction        function bit check_data_buffer();        check_data_buffer = 1;        foreach(exp_out_pkts[id])begin             if(exp_out_pkts[id].size != 0)begin//exp_out_pkts必须有数据                check_data_buffer = 0;                $display("exp_out_pkts[%0d] buffer size is not 0(still with %0d data)",id,exp_out_pkts[id].size);            end            if(mon.out_pkts[id].size != 0)begin//mon.out_pkts必须有数据                check_data_buffer = 0;                $display("mon.out_pkts[%0d] buffer size is not 0(still with %0d data)",id,mon.out_pkts[id].size);            end        end    endfunction    endclass//********************************** Optional tests **********************************//class rt_env;//rt_env包含各个组件    rt_stimulator stim;    rt_monitor mon;    rt_generator gen;    rt_checker chk;            function new(virtual rt_interface intf);        //build stage,例化        stim = new();        gen = new();        mon = new();        chk = new();        //connect stage，连接        stim.intf = intf;        mon.intf = intf;        chk.mon = mon;//check拿monitor句柄，即拿monitor中in_pkts与out_pkts队列    endfunction         task run();        rt_packet p;        //run stage，run        fork            stim.run();//class里面的函数不会自动调用，需要手动调用            gen.run();            mon.run();            chk.run();            begin:genarator_to_stimulator_proc//取出genarator中的数据给stimulator                 forever begin//此处不需要延迟0，执行task run的时候默认function new已执行                    gen.get_pkt(p);//get句柄                    stim.put_pkt(p);//put句柄                end            end        join_none    endtask        function void report(string name);        chk.report(name);    endfunction    endclassclass rt_base_test;//rt_base_test包含rt_env，rt_env包含各个组件    rt_env env;    bit gen_trans_done = 0;//表示数据传输未开始    int unsigned test_drain_time_us = 1;//数据传输完后等待报告的时间    string name;        function new(virtual rt_interface intf,string name = "rt_base_test");        env = new(intf);        this.name = name;    endfunction        task run();    $display("TEST %s started",name);        fork            env.run();            report();//调用report        join_none    endtask        task report();        wait(gen_trans_done == 1);        #(test_drain_time_us * 1us);        env.report(name);//调用env里的chk.report()进行report        $finish();//terminates the current test    endtask  function void set_trans_done(bit done = 1);//将set_trans_done信号置为1，表示数据传输已完成        gen_trans_done = done;    endfunctionendclass    class rt_single_ch_test extends rt_base_test;//单个通道测试        function new(virtual rt_interface intf,string name = "rt_single_ch_test");            super.new(intf,name);        endfunction                    task run();            rt_packet p;            super.run();//调用父类的run，即执行env.run()，进行组件的例化等操作            p = new();//obj1(每次put_pkt都需要new一下)            p.set_members(0,3,'{8'h33,8'h77});//注意层次变化，在env层次下面            env.gen.put_pkt(p);            p = new();//obj2            p.set_members(0,5,'{8'h55,8'h66});            env.gen.put_pkt(p);            set_trans_done();        endtask            endclass    class rt_two_ch_test extends rt_base_test;        function new(virtual rt_interface intf,string name = "rt_two_ch_test");            super.new(intf,name);        endfunction    endclass        class rt_two_ch_same_chout_test extends rt_two_ch_test;            function new(virtual rt_interface intf,string name = "rt_two_ch_same_chout_test");                super.new(intf,name);            endfunction        endclass    class rt_multi_ch_test extends rt_base_test;//多通道测试        function new(virtual rt_interface intf,string name = "rt_multi_ch_test");            super.new(intf,name);        endfunction                task run();            rt_packet p;            super.run();            p = new();            p.set_members(0,3,'{8'h33,8'h77});            env.gen.put_pkt(p);            p = new();//每次put_pkt都需要new一下            p.set_members(0,5,'{8'h55,8'h66});            env.gen.put_pkt(p);            p = new();            p.set_members(3,6,'{8'h77,8'h88,8'h22});            env.gen.put_pkt(p);            p = new();            p.set_members(4,7,'{8'haa,8'hcc,8'h33});            env.gen.put_pkt(p);            set_trans_done();        endtask    endclass        class rt_full_ch_test extends rt_multi_ch_test;            function new(virtual rt_interface intf,string name = "rt_full_ch_test");                super.new(intf,name);            endfunction        endclass//********************************** Optional tests **********************************////********************************** tb **********************************//module tb;bit clk,rstn;logic [15:0] din, frame_n, valid_n;logic [15:0] dout, valido_n, busy_n, frameo_n;// 产生时钟，周期为10nsinitial     forever #5ns clk <= !clk;// 产生复位信号  initial begin    #2ns rstn <= 1;    #10ns rstn <= 0;    #10ns rstn <= 1;  end//例化router为DUTrouter dut(             .reset_n(rstn),  .clock(clk),  .frame_n(intf.frame_n),  .valid_n(intf.valid_n),  .din(intf.din),  .dout(intf.dout),  .busy_n(intf.busy_n),  .valido_n(intf.valido_n),  .frameo_n(intf.frameo_n));rt_interface intf();//例化接口    assign intf.reset_n = rstn;    assign intf.clock = clk;    rt_single_ch_test  single_ch_test;    rt_multi_ch_test   multi_ch_test;            initial begin : inst_init_proc            single_ch_test = new(intf);            //multi_ch_test  = new(intf);            single_ch_test.run();            //multi_ch_test.run();    end    endmodule </code></pre><h2 id="2-3-仿真结果"><a href="#2-3-仿真结果" class="headerlink" title="2.3 仿真结果"></a>2.3 仿真结果</h2><p>同上</p><h1 id="3-package封装与makefile的使用"><a href="#3-package封装与makefile的使用" class="headerlink" title="3.  package封装与makefile的使用"></a>3.  package封装与makefile的使用</h1><h2 id="3-1-利用package将文件打包，并将package里的内容放入一个单独的文件里面"><a href="#3-1-利用package将文件打包，并将package里的内容放入一个单独的文件里面" class="headerlink" title="3.1 利用package将文件打包，并将package里的内容放入一个单独的文件里面"></a>3.1 利用package将文件打包，并将package里的内容放入一个单独的文件里面</h2><h3 id="rt-test-pkg-sv"><a href="#rt-test-pkg-sv" class="headerlink" title="rt_test_pkg.sv"></a>rt_test_pkg.sv</h3><pre class=" language-systemverilog"><code class="language-systemverilog">package rt_test_pkg;class rt_packet;  bit [3:0] src;  bit [3:0] dst;  bit [7:0] data [];  function new();  endfunction  function void set_members(bit [3:0]src, bit [3:0]dst, bit[7:0]data []);    this.src = src;    this.dst = dst;    this.data = data;  endfunction  function string sprint();//打印packet信息的函数    sprint = {sprint , $sformatf("src = %0d\n",src)};    sprint = {sprint , $sformatf("dst = %0d\n",dst)};    sprint = {sprint , $sformatf("data_length = %0d\n",data.size())};    foreach(data[i])        sprint = {sprint , $sformatf("data[%0d] = 'h%0x\n", i, data[i])};  endfunction  function bit compare(rt_packet p);//输入exp_pkt        if(dst == p.dst && data == p.data)            compare = 1;        else             compare = 0;  endfunctionendclass//********************************** stimulator **********************************//class rt_stimulator;    virtual rt_interface intf;//class里的接口不能用端口的方式描述，需要添加virtual关键字，在类里面用接口的指针//for debug purpose from waveform//定义检测状态的变量  typedef enum {DRV_RESET,DRV_IDLE,DRV_ADDR,DRV_PAD,DRV_DATA} drv_state_t;  drv_state_t dbg_state;    byte unsigned dbg_din_chnl0_data;   int src_chnl_status[int];  //关联数组，后面int：src_chnl的number；前面int：dest_chnl的Number ？？    //generator传送p给stimulator  rt_packet pkts[$];//定义stimulator中的的队列pkts  function void put_pkt(input rt_packet p);    pkts.push_back(p);//将generator中传过来的p放入stimulator的pkts中(在pkts队列尾插入p)  endfunctiontask run();    fork        drive_reset(); //reset动作        get_packet_and_drive(); //drive_chnl动作    join_noneendtask    task drive_reset();//reset    forever begin        @(negedge intf.reset_n);        dbg_state <= DRV_RESET;        intf.din <= 0;        intf.frame_n <= '1;//等效16'hFFFF        intf.valid_n <= '1;    endendtask// 发送数据task get_packet_and_drive();//drive_chnl    //rt_packet_t p;  @(negedge intf.reset_n);  repeat(10) @(posedge intf.clock);//延迟10个时钟周期  forever begin    automatic rt_packet p;//声明一个动态的    wait(pkts.size()>0);    p = pkts.pop_front();//将p从队列pkts里面取出    fork//后台触发线程，触发线程在后台运行，继续执行剩下内容        begin            wait_src_chnl_avail(p);//判断src chnl是否被占用，是否需要等待            drive_chnl(p);//从P中拿到发送端口，目标端口，发送数据            set_src_chnl_avail(p);        end    join_none    endendtasktask  wait_src_chnl_avail(rt_packet p);//判断src chnl是否被占用，是否需要等待    if(!src_chnl_status.exists(p.src))//src_chnl_status关联数组里面不含p.src，(表示未占用任何dest_chnl,一开始不满足）        src_chnl_status[p.src] = p.dst;//表示当前正在使用src_chnl,对应dest_chnl就是p.dst（p.src端口在向p.dst端口发送数据）    else if(src_chnl_status[p.src] >= 0)//如果在给0,1,2...dest_chnl发送数据（被占用），需要等待,，否则不需要等待        wait(src_chnl_status[p.src] == -1);//直到src_chnl_status[p.src] == -1(自定义的dest_chnl端口数之外任意的数，表示未占用任何dest_chnl)endtaskfunction  set_src_chnl_avail(rt_packet p);    src_chnl_status[p.src] = -1;//如果chnl发送完后，把src_chnl置回来(自定义的dest_chnl端口数之外任意的数，表示未占用任何dest_chnl)endfunctiontask  drive_chnl(rt_packet p);  $display("@%0t:[DRV] src_chnl[%0d] & dest_chnl[%0d] data trans started with packet: \n%s",$time,p.src,p.dst,p.sprint());    // drive address phase 输入地址位阶段for(int i=0;i<4;i++)begin  //4 clock  @(posedge intf.clock);  dbg_state <=DRV_ADDR;  intf.din[p.src] <= p.dst[i];  intf.valid_n[p.src] <= $urandom_range(0,1);//valid_n在din的地址输入时间段可为任意值x  intf.frame_n[p.src] <= 1'b0;//frame_n需要为低end    // drive pad phase //隔离阶段  for (int i=0;i<5;i++)begin  //5 clock    @(posedge intf.clock);    dbg_state <=DRV_PAD;    intf.din[p.src] <= 1'b1;    intf.valid_n[p.src] <= 1'b1;//valid_n需为高电平    intf.frame_n[p.src] <= 1'b0; //frame_n需为低电平  end    // drive data phase 传输数据阶段  foreach(p.data[id])begin    for(int i=0;i<8;i++)begin     @(posedge intf.clock);      dbg_state <=DRV_DATA;      dbg_din_chnl0_data <= p.data[id];      intf.din[p.src] <= p.data[id][i];      intf.valid_n[p.src] <=1'b0;      intf.frame_n[p.src] <= (id == p.data.size()-1 && i == 7) ? 1'b1 : 1'b0;//packet最后一位输出数据时frameo_n为高    end  end// drive idle phase 闲置（没有数据传输）阶段  @(posedge intf.clock);  dbg_state <=DRV_IDLE;  dbg_din_chnl0_data <= 0;  intf.din[p.src] <= 1'b0;  intf.valid_n[p.src] <= 1'b1;  intf.frame_n[p.src] <= 1'b1;  $display("@%0t: [DRV]src_chnl[%0d],dest_chnl[%0d] data trans finished",$time,p.src,p.dst);endtaskendclass//********************************** generator **********************************//class rt_generator;//generator产生数据交给stimulator  rt_packet pkts[$];//定义队列  function void put_pkt(input rt_packet p);    pkts.push_back(p);//将p放入队列pkts里面（在pkts队列尾插入p）  endfunction    task get_pkt(output rt_packet p);    wait(pkts.size() >0 )//队列不为空      p = pkts.pop_front();//将p从队列pkts里面取出，提取队列首元素  endtask  //generate a random packet  function void gen_pkt(int src = -1, int dst = -1);  endfunction    task run();        //TODO  endtask    endclass//********************************** monitor **********************************//class rt_monitor;virtual rt_interface intf;    rt_packet in_pkts[16][$];    rt_packet out_pkts[16][$];    task run();    fork        mon_chnls();    join_noneendtask    task mon_chnls;    foreach(in_pkts[i]) begin        automatic int chid = i;        fork        mon_chnl_in(chid);//每个输入端口均调用mon_chnl_in任务，监测数据输入        mon_chnl_out(chid);//每个输出端口均调用mon_chnl_out任务，监测数据输入        join_none    endendtask    task  mon_chnl_in (bit[3:0]id);//监测数据输入的任务    rt_packet pkt;//定义结构体变量    forever begin    //clear content for the same struct variable。清除pkt    pkt = new();    pkt.src = id;//第id个输入端口    //monitor specific channel-in data and put it into the queue    // monitor address phase    @(negedge intf.frame_n[id]);//监测frame_n下降沿(frame_n由时钟驱动)    for(int i=0; i<4; i++)begin        @(negedge intf.clock);//frame_n下降沿后监测4个clk negedge        pkt.dst[i]= intf.din[id];        end        $display ("@%0t: [MON] src_chn1[%0d] & dest_chn1[%0d] data trans started",$time,pkt.src,pkt.dst);    //pass pad phase 不考虑pad阶段是否满足协议要求    repeat(5) @(negedge intf.clock);    do begin        pkt.data = new [pkt.data.size + 1](pkt.data);//创建动态数组并复制pkt.data        for ( int i=0; i<8; i++) begin            @(negedge intf.clock); //在8个clk negedge监测8bit数据            pkt.data[pkt.data.size-1][i] = intf.din[id];        end    end while(!intf.frame_n[id]);    in_pkts[id].push_back(pkt);//将monitor拿到的数据放入in_pkts    $display("@%0t:[MON] CH_IN src_chnl[%0d] &dest_chnl[%0d ] finished with packet: \n%s",$time,pkt.src,pkt.dst,pkt.sprint());    endendtasktask  mon_chnl_out(bit[ 3:0]id);//监测数据输出的任务    rt_packet pkt;    forever begin        //clear content for the same struct variable        pkt = new();        pkt.src = 0;        pkt.dst = id;        @(negedge intf.frameo_n[id]);        $display( "@%0t: [MON] CH_OUT dest_chn1[%0d] data trans started",$time,pkt.dst);        do begin        pkt.data = new [ pkt.data.size + 1](pkt.data);        for(int i=0;i<8; i++) begin            @(negedge intf.clock iff !intf.valido_n[id]);//clock与valido_n信号同时为低            pkt.data[pkt.data.size-1][i]= intf.dout [id];        end    end while(!intf.frameo_n[id]);    out_pkts[id].push_back(pkt);    $display("@%0t: [MON] CH_OUT dest_chn1[%0d] data finished woth packet : \n %s",$time,pkt.dst,pkt.sprint());    //monitor specific channel-out data and put it into the queue    endendtaskendclass//********************************** checker **********************************//class rt_checker;    int unsigned compare_count;    int unsigned error_count;        function new();//赋初值，可有可无，整形变量默认初始值为0        compare_count = 0;        error_count = 0;    endfunction        rt_packet exp_out_pkts[16][$];    rt_monitor mon;        task run();    foreach(exp_out_pkts[i])begin        automatic int chid = i;        fork            do_routing(chid);            do_compare(chid);        join_none        end    endtask        task do_routing(bit[3:0] id);//将monitor中采样到的输入数据放入期望的输出端队列中        rt_packet pkt;        forever begin            wait(mon.in_pkts[id].size > 0);            pkt = mon.in_pkts[id].pop_front();//从monitor中拿到in_pkts队列数据放入pkt            exp_out_pkts[pkt.dst].push_back(pkt);//将pkt数据放入对应期望的dest_chnl            end    endtask         task do_compare(bit[3:0] id);//比较采集的实际输出与期望输出        rt_packet exp_pkt, act_pkt;        forever begin            wait(mon.out_pkts[id].size > 0 && exp_out_pkts[id].size > 0);//实际采样数据与期望数据都有值            act_pkt = mon.out_pkts[id].pop_front();//实际数据为monitor采样的输出数据            exp_pkt = exp_out_pkts[id].pop_front();//期望数据为monitor采样到的输入数据            if(act_pkt.compare(exp_pkt))begin//如果exp_pkt与act_pkt比较成功，返回1                $display("[CHK] data compare success with packet : \n%s",act_pkt.sprint());            end            else begin                $display("[CHK] data compare failure with actual packet : \n%s \nexpected packet : \n%s", act_pkt.sprint(), exp_pkt.sprint());                error_count++;            end                compare_count++;        end    endtask         function void report(string name);        $display("TOTAL COMPARING %0d times",compare_count);        if(!error_count && check_data_buffer())//判断无误且二者有数据            $display("TEST [%s] PASSED!",name);        else begin            $display("TEST [%s]FAILED!",name);            $display("TOTAL ERROR %0d times", error_count);        end    endfunction        function bit check_data_buffer();        check_data_buffer = 1;        foreach(exp_out_pkts[id])begin             if(exp_out_pkts[id].size != 0)begin//exp_out_pkts必须有数据                check_data_buffer = 0;                $display("exp_out_pkts[%0d] buffer size is not 0(still with %0d data)",id,exp_out_pkts[id].size);            end            if(mon.out_pkts[id].size != 0)begin//mon.out_pkts必须有数据                check_data_buffer = 0;                $display("mon.out_pkts[%0d] buffer size is not 0(still with %0d data)",id,mon.out_pkts[id].size);            end        end    endfunction    endclass//********************************** Optional tests **********************************//class rt_env;//rt_env包含各个组件    rt_stimulator stim;    rt_monitor mon;    rt_generator gen;    rt_checker chk;            function new(virtual rt_interface intf);        //build stage,例化        stim = new();        gen = new();        mon = new();        chk = new();        //connect stage，连接        stim.intf = intf;        mon.intf = intf;        chk.mon = mon;//check拿monitor句柄，即拿monitor中in_pkts与out_pkts队列    endfunction         task run();        rt_packet p;        //run stage，run        fork            stim.run();//class里面的函数不会自动调用，需要手动调用            gen.run();            mon.run();            chk.run();            begin:genarator_to_stimulator_proc//取出genarator中的数据给stimulator                 forever begin//此处不需要延迟0，执行task run的时候默认function new已执行                    gen.get_pkt(p);//get句柄                    stim.put_pkt(p);//put句柄                end            end        join_none    endtask        function void report(string name);        chk.report(name);    endfunction    endclassclass rt_base_test;//rt_base_test包含rt_env，rt_env包含各个组件    rt_env env;    bit gen_trans_done = 0;//表示数据传输未开始    int unsigned test_drain_time_us = 1;//数据传输完后等待报告的时间    string name;        function new(virtual rt_interface intf,string name = "rt_base_test");        env = new(intf);        this.name = name;    endfunction        task run();    $display("TEST %s started",name);        fork            env.run();            report();//调用report        join_none    endtask        task report();        wait(gen_trans_done == 1);        #(test_drain_time_us * 1us);        env.report(name);//调用env里的chk.report()进行report        $finish();//terminates the current test    endtask  function void set_trans_done(bit done = 1);//将set_trans_done信号置为1，表示数据传输已完成        gen_trans_done = done;    endfunctionendclass    class rt_single_ch_test extends rt_base_test;//单个通道测试        function new(virtual rt_interface intf,string name = "rt_single_ch_test");            super.new(intf,name);        endfunction                    task run();            rt_packet p;            super.run();//调用父类的run，即执行env.run()，进行组件的例化等操作            p = new();//obj1(每次put_pkt都需要new一下)            p.set_members(0,3,'{8'h33,8'h77});//注意层次变化，在env层次下面            env.gen.put_pkt(p);            p = new();//obj2            p.set_members(0,5,'{8'h55,8'h66});            env.gen.put_pkt(p);            set_trans_done();        endtask            endclass    class rt_two_ch_test extends rt_base_test;        function new(virtual rt_interface intf,string name = "rt_two_ch_test");            super.new(intf,name);        endfunction    endclass        class rt_two_ch_same_chout_test extends rt_two_ch_test;            function new(virtual rt_interface intf,string name = "rt_two_ch_same_chout_test");                super.new(intf,name);            endfunction        endclass    class rt_multi_ch_test extends rt_base_test;//多通道测试        function new(virtual rt_interface intf,string name = "rt_multi_ch_test");            super.new(intf,name);        endfunction                task run();            rt_packet p;            super.run();            p = new();            p.set_members(0,3,'{8'h33,8'h77});            env.gen.put_pkt(p);            p = new();//每次put_pkt都需要new一下            p.set_members(0,5,'{8'h55,8'h66});            env.gen.put_pkt(p);            p = new();            p.set_members(3,6,'{8'h77,8'h88,8'h22});            env.gen.put_pkt(p);            p = new();            p.set_members(4,7,'{8'haa,8'hcc,8'h33});            env.gen.put_pkt(p);            set_trans_done();        endtask    endclass        class rt_full_ch_test extends rt_multi_ch_test;            function new(virtual rt_interface intf,string name = "rt_full_ch_test");                super.new(intf,name);            endfunction        endclassendpackage//********************************** Optional tests **********************************//</code></pre><h3 id="lab7tb-sv"><a href="#lab7tb-sv" class="headerlink" title="lab7tb.sv"></a>lab7tb.sv</h3><pre class=" language-systemverilog"><code class="language-systemverilog">interface rt_interface();    logic clock;    logic reset_n;    logic [15:0] din;    logic [15:0] frame_n;    logic [15:0] valid_n;    logic [15:0] dout;    logic [15:0] valido_n;    logic [15:0] busy_n;    logic [15:0] frameo_n;endinterface//********************************** tb **********************************//module tb;import rt_test_pkg:: * ; bit clk,rstn;logic [15:0] din, frame_n, valid_n;logic [15:0] dout, valido_n, busy_n, frameo_n;// 产生时钟，周期为10nsinitial     forever #5ns clk <= !clk;// 产生复位信号  initial begin    #2ns rstn <= 1;    #10ns rstn <= 0;    #10ns rstn <= 1;  end//例化router为DUTrouter dut(             .reset_n(rstn),  .clock(clk),  .frame_n(intf.frame_n),  .valid_n(intf.valid_n),  .din(intf.din),  .dout(intf.dout),  .busy_n(intf.busy_n),  .valido_n(intf.valido_n),  .frameo_n(intf.frameo_n));rt_interface intf();//例化接口    assign intf.reset_n = rstn;    assign intf.clock = clk;    rt_single_ch_test  single_ch_test;    rt_multi_ch_test   multi_ch_test;            initial begin : inst_init_proc            single_ch_test = new(intf);            multi_ch_test  = new(intf);            //single_ch_test.run();            multi_ch_test.run();    end    endmodule</code></pre><h3 id="VCS命令"><a href="#VCS命令" class="headerlink" title="VCS命令"></a>VCS命令</h3><blockquote><p>vcs -full64 -debug_access+all -sverilog -timescale=1ns/1ps <span style="background:rgba(5, 117, 197, 0.2)">router.v</span> <span style="background:rgba(136, 49, 204, 0.2)">rt_test_pkg.sv</span> <span style="background:#affad1">lab7tb.sv</span>  -top tb<br>//注意文件顺序，lab7tb.sv中的类是在rt_test_pkg.sv中创建的，rt_test_pkg.sv应在前面</p></blockquote><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211180958453.png" width="45%" height="45%"></div><h2 id="3-2-使用makefile"><a href="#3-2-使用makefile" class="headerlink" title="3.2 使用makefile"></a>3.2 使用makefile</h2><p>使用脚本包含命令及其组合，makefile代码如下：</p><pre class=" language-systemverilog"><code class="language-systemverilog">############################ User variables###########################TB       = tbSEED  = 1TESTNAME ?= rt_single_ch_testFILES    = router.v rt_test_pkg.sv lab7tb.sv #User Defination############################ Environment variables###########################COMP = vcs -full64 -sverilog -debug_access+all -timescale=1ns/1ps -l comp.log $(FILES)RUN = ./$(TB).simv -l run.log -sml +ntb_random_seed=$(SEED) +TESTNAME=$(TESTNAME)comp:    $(COMP) -top $(TB) -o $(TB).simvrun:    $(RUN)rung:    $(RUN) -gui</code></pre><p>相关命令：</p><blockquote><p>make comp    //编译当前路径下的makefile文件，生成命令<br>make run/make rung    //执行run或rung的内容，生成log文件，make rung会调用vcs的可视化窗口</p></blockquote><h2 id="3-3对makefile增加输入参数"><a href="#3-3对makefile增加输入参数" class="headerlink" title="3.3对makefile增加输入参数"></a>3.3对makefile增加输入参数</h2><p>将外部输入参数添加到tb文件中：</p><pre class=" language-systemverilog"><code class="language-systemverilog">    initial begin : Select_the_test    string name;      single_ch_test = new(intf);      multi_ch_test  = new(intf);      //single_ch_test.run();      //multi_ch_test.run();      if($value$plusargs("TESTNAME=%s",name))begin//$value$plusargs作用：运行仿真时输入参数        case(name)            "rt_single_ch_test" : single_ch_test.run();//输入rt_single_ch_test，调用对应run，执行输入rt_single_ch_test                "rt_multi_ch_test" :multi_ch_test.run();            default:$fatal("[ERRTEST],test name %s is invalid,please specity a valid name!0",name);        endcase        end    end</code></pre><p>相关命令：</p><blockquote><p>make rung TESTNAME=rt_multi_ch_test &amp;    //传入参数rt_multi_ch_test，进行多通道测试<br>make rung TESTNAME=rt_single_ch_test &amp;    //传入参数rt_single_ch_test，进行多通道测试</p></blockquote><h2 id="3-4-仿真结果"><a href="#3-4-仿真结果" class="headerlink" title="3.4 仿真结果"></a>3.4 仿真结果</h2><p>同上</p>]]></content>
      
      
      <categories>
          
          <category> 数字IC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字前端 </tag>
            
            <tag> SystemVerilog验证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lightroom后期（四）局部曝光的调整</title>
      <link href="/2022/10/28/lightroom-hou-qi-si-ju-bu-pu-guang-de-diao-zheng/"/>
      <url>/2022/10/28/lightroom-hou-qi-si-ju-bu-pu-guang-de-diao-zheng/</url>
      
        <content type="html"><![CDATA[<h1 id="一、渐变滤镜"><a href="#一、渐变滤镜" class="headerlink" title="一、渐变滤镜"></a>一、渐变滤镜</h1><p>渐变滤镜的作用呢，是创造有过度的曝光调整，可以是生硬的过度，也可以是柔和的过度。软过度的调整呢，让照片中的光线看起来要更自然。<br>拍日落的时候，当太阳逐渐降低到地平线后，天空的曝光很亮，但是地面的建筑阴影这些背光的位置很暗。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210281956398.png"><br>这个时候就可以使用渐变滤镜来调整。在照片中曝光有差别的位置，拉一个渐变滤镜，通常是在地平线的位置。过度要稍微的软一些，也就是这三条线的距离要大一点。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210282000844.png"><br>在参数的设置里，可以按照上一节([[lightroom后期（三）提升照片质感]])对比度和立体感的调整方法来设置参数<br>可以添加一个明亮度范围蒙板<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210282002665.png"><br>在范围这里边，左侧是暗部，右侧是亮部，点击显示明亮度蒙板就可以看到调整的过程当中蒙板的变化。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210282005945.png"><br>同样也可以增加阴影来调高所有的阴影位置，在这个案例当中，可以搭配阴影和明亮度蒙板来调整建筑与天空之间的过渡。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210282008223.png"><br>对比一下原片，可以看到高光的位置，也就是天空被压暗，而建筑呢被提亮。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210282009769.png"><br>无论是1/2还是1/3的构图方法，甚至是左右分割以及对角线曝光不平衡的画面，只要是大面积的需要调整曝光的时候呢，都可以使用渐变滤镜来解决。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210282011038.png"></p><h1 id="二、径向滤镜"><a href="#二、径向滤镜" class="headerlink" title="二、径向滤镜"></a>二、径向滤镜</h1><p>由于径向滤镜的覆盖面积，是圆形或者是椭圆形的，在调整高光的时候要更方便，在城市建筑以及街景的案例当中更为常用。例如这张照片左侧的树和右侧的建筑，刚好形成了一个框架，照片中间的建筑和天空被阳光直射，使用径向滤镜刚好达到完美的覆盖这个区域。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210282013415.png"><br>在径向滤镜当中，比渐变滤镜啊要多一个选项，叫做羽化，指的是滤镜周围的过渡，大多数的情况下呢，都需要使用比较大的羽化，让光线过度更自然，勾选左下角的显示选定的蒙板叠加，就可以看到现在径向滤镜所影响的范围。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210282015936.png"><br>降低羽化会让滤镜的边缘过渡非常的生硬，所以经常我们要加大羽化的数值，营造比较自然柔和的光线。</p><h1 id="三、调整画笔"><a href="#三、调整画笔" class="headerlink" title="三、调整画笔"></a>三、调整画笔</h1><p>调整画笔是非常重要的细节修补工具，特别是城市照片这种细节特别多的题材，例如这张照片当中，酒店建筑外观的立体感稍微有点差，渐变滤镜和径向滤镜的覆盖范围又没有办法在这个位置发挥很好的作用，那就刚好用到了调整画笔。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210282018972.png"></p><p>后期思路：降低屋顶曝光，提高建筑白色部分曝光度，增大与屋顶对比。添加白色色阶，降低黑色色阶，让窗户的这个窗户框能够变得更明显，增加一点点的纹理。通过这样的分区调整屋顶以及楼体的曝光，就可以实现将建筑细节重塑曝光的效果。<br>对比原片，就可以看到现在建筑拥有更立体的效果。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210282022793.png"></p><p>以上这三个工具的区别，可以理解为覆盖面积的不一样。<br>渐变滤镜的面积最大，径向滤镜适合圆形的范围调整；画笔适应能力最强，它的覆盖面积最小，可以自由的选择想要调整的位置以及形状，是精修细节的最好选择。组合搭配这三个工具，就可以实现特别的光影效果，特别是在调整黑白照片当中，利用局部曝光的明暗对比来提亮主体，压暗阴影，获得更具有戏剧性的视觉效果。</p><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p><a href="https://www.bilibili.com/video/BV15b4y1Q7xH/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=83d80c57e4377b69f911cc68016fb835">【Edi x TourBox后期训练营】光影的后期再造秘籍 - 局部曝光的调整对照片的微妙作用_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> 摄影后期 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lightroom </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lightroom后期(三) 提升照片质感</title>
      <link href="/2022/10/27/lightroom-hou-qi-san-ti-sheng-zhao-pian-zhi-gan/"/>
      <url>/2022/10/27/lightroom-hou-qi-san-ti-sheng-zhao-pian-zhi-gan/</url>
      
        <content type="html"><![CDATA[<h1 id="一、对比度"><a href="#一、对比度" class="headerlink" title="一、对比度"></a>一、对比度</h1><h2 id="亮度对比"><a href="#亮度对比" class="headerlink" title="亮度对比"></a>亮度对比</h2><p>改变光线的明暗差别，可以提高物体的立体感。当有光照到的亮部和阴影位置的暗部差别很大的时候，物体看起来更加立体。所以天气不好或者阴天的时候建筑立体感看起来要差一些。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210271427490.png"><br>大范围设置：<font color="#0070c0">对比度</font><br>更精细设置：<font color="#0070c0">高光</font>和<font color="#0070c0">阴影</font>以及<font color="#0070c0">黑白色阶</font>设置，它基本上只影响了直方图左右两端的曲线，也就是非常亮和非常暗的区域（直方图从左到右分别是黑色色阶、阴影、曝光度、高光和白色色阶）。 </p><h2 id="颜色的明亮度对比"><a href="#颜色的明亮度对比" class="headerlink" title="颜色的明亮度对比"></a>颜色的明亮度对比</h2><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210271428890.png"><br>在<font color="#0070c0">HSL颜色工具中的</font><font color="#0070c0">明亮度</font>设置，可以将主体和背景的颜色拉开对比， 同样可以获得很好的立体感提升。</p><h1 id="二、清晰度"><a href="#二、清晰度" class="headerlink" title="二、清晰度"></a>二、清晰度</h1><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210271429623.png"><br><font color="#0070c0">纹理</font>是用来增加细节的很好方法，特别是建筑纹理或者不同材质材料的纹路。<br><font color="#0070c0">清晰度</font>的调整范围要比纹理更大，不仅影响纹理，还影响整张照片所有物体边缘的明暗对比。增加清晰度可以看到阴影部分变得更暗，<u>它和对比度参数最大的不同是：对比度设置会降低暗部提高亮度，提高亮部的亮度。而清晰度设置对物体边缘暗部的影响要更大，而高光只有一点点变化。</u></p><h1 id="三、锐化"><a href="#三、锐化" class="headerlink" title="三、锐化"></a>三、锐化</h1><p>在Lightroom的细节工具当中，<font color="#0070c0">锐化</font>是后期时常用的细节增强工具。锐化会给照片中所有的物体边缘带来非常强烈的对比。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210271424301.png"><br><font color="#00b050">数量参数</font>通常控制在50以下，避免过度锐化带来更多噪点。<br><font color="#00b050">半径参数</font>指锐化边缘的范围，半径数值从0到3.0像素，避免过度使用的话控制在1-1.5之间。<br><font color="#00b050">蒙版设置</font>是用来去掉一些不该被锐化的区域，例如只想要锐化建筑，但是并不想影响云和天空，添加蒙版就可以去掉这些区域的锐化效果</p><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p><a href="https://www.bilibili.com/video/BV1nz4y117Ub/">【Edi x TourBox后期训练营】提高照片质感的方法 - 对比度/清晰度/锐化可以为照片带来什么样改变_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> 摄影后期 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lightroom </tag>
            
            <tag> 提升质感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>车规芯片(四)  leon2处理器</title>
      <link href="/2022/10/24/che-gui-xin-pian-si-leon2-chu-li-qi/"/>
      <url>/2022/10/24/che-gui-xin-pian-si-leon2-chu-li-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p><span style="background:rgba(240, 200, 0, 0.2)">leon2处理器是一款开源的、符合SPARC(可扩展处理器体系架构) V8规范的、采用RISC 结构的32位处理器I P 核。</span>它可以从互联网上免费下载使用。Leon2是以VHDL 形式存在的软核、完全可综合、内部硬件资源可裁剪、主要面向嵌入式应用系统、可以用FPGA/CPLD 和ASIC等技术实现。</p><h1 id="二、leno2处理器结构"><a href="#二、leno2处理器结构" class="headerlink" title="二、leno2处理器结构"></a>二、leno2处理器结构</h1><h3 id="处理器单元"><a href="#处理器单元" class="headerlink" title="处理器单元"></a>处理器单元</h3><p>处理器单元由<font color="#ff0000">整数单元IU</font>、<font color="#ff0000">浮点单元FPU</font>、<font color="#ff0000">协处理器单元CP</font>构成。</p><ul><li>整数单元的特点有：5级指令流水、分离的数据和指令Cache、支持2~32个寄存器窗口、可选的4个观察口寄存器、可配置乘法器、可选的16×16位MAC(40位累加器)、基2除法器。</li><li>可支持的浮点处理器有GaislerResearch的GRFPU，Sun Microsystems的Meiko FPU或其他通用浮点处理单元。</li><li>Leon2提供了一个通用的用户可定义的协处理器，同IU并行运行增强了系统功能。</li></ul><h3 id="Cache子系统"><a href="#Cache子系统" class="headerlink" title="Cache子系统"></a>Cache子系统</h3><p>可配置的模式有直接映射模式和2~4组相联的多组相联模式；可选的三种替换算法是LRU、LRR和伪随机。</p><h3 id="片上外设"><a href="#片上外设" class="headerlink" title="片上外设"></a>片上外设</h3><p>片上外设包括：2个中断控制器、2个UART、2个Timer和1个Watchdog、16位的I／O口、存储器控制器(PROM、SRAM、S13RAM)、PCI桥接器、Ethernet接口、高级片上调试支持单元(DSU)和跟踪缓冲器等．中断控制器可以最大处理46个内部和外部中断。2个串行通信口 (UART)，支持8位数据帧、1位校验位、1位停止位，支持硬件流控功能。调试支持单元(DSU)能够把处理器设置到调试模式，通过它可以读写处理器的所有寄存器和Cache。DSU还包括一个跟踪缓存，可以保存已执行了的指令和AHB上传输的数据。</p><p>开源的 LEON2 处理器版本中包括：<u>整数处理单元（Integer Unit，IU），独立的指令缓存（I-Cache）模块和数据缓存（D-Cache）模块，16 位I/O 端口，存储器控制器模块（Memory Controller）等等。</u>根据需求，设计者可以通过片上AMBA AHB/APB 总线控制器实现外设的添加。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210260836471.png" alt="|500"></p><h1 id="三、Leon2的技术特点"><a href="#三、Leon2的技术特点" class="headerlink" title="三、Leon2的技术特点"></a>三、Leon2的技术特点</h1><p>Leon2的技术特点主要有：<span style="background:rgba(240, 107, 5, 0.2)">采用SPARC V8结构</span>、<span style="background:rgba(240, 107, 5, 0.2)">采用内部AMBA总线结构</span>、<span style="background:rgba(240, 107, 5, 0.2)">容错设计</span>和<span style="background:rgba(240, 107, 5, 0.2)">VHDL编程风格</span>。</p><h2 id="SPARC-V8"><a href="#SPARC-V8" class="headerlink" title="SPARC V8"></a>SPARC V8</h2><p>SPARC是可扩展处理器体系架构的首字母缩略词，是一个从RISC派生出的CPU指令集结构(ISA)。指令集结构是指：定义了指令、寄存器、指令和数据存储器、指令执行对寄存器和存储器的影响、控制指令执行的算法等内容，但不定义时钟周期、每条指令的执行时钟周期数(CPI)、数据通路等内容。作为一个结构，SPARC允许在具有不同性能价格比的广泛应用中，实现不同系列的芯片和系统，包括科学、工程、编程、实时和商业应用等。<span style="background:rgba(240, 200, 0, 0.2)">SPARC的设计目标是优化编译器和易于硬件流水线实现。</span></p><h3 id="指令集架构"><a href="#指令集架构" class="headerlink" title="指令集架构"></a>指令集架构</h3><p>&nbsp;所有指令都编码成32位格式，可以分成六个基本的类型，一共有72条指令。六种基本的指令分别是：①Load／store；②Arthmetic／logical／shift；③Control transfer；④Read／write control register；⑤Floating-point operate；⑥Coprocessor operate。<br>&nbsp;### 寄存器窗口<br>它是SPARC的最大技术特点。SPARC处理器包括两种寄存器：一种是<span style="background:rgba(240, 200, 0, 0.2)">通用寄存器</span>，另一种是<span style="background:rgba(240, 200, 0, 0.2)">控制／状态寄存器</span>。其中整数单元中的控制/状态寄存器主要负责记录<br>处理器状态和计数等任务，包括PSR，WIM，TBR，PC，ASRs 等；而整数单元的通用寄存器，则<u>采用独特寄存器窗口的实现方式来提高处理器运行效率</u>，这也是SPARC  架构区别于架构设计之处。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210260939296.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210260941294.png"><br>IU的通用寄存器叫r寄存器。一个IU(整数元)的实现可能包括40<del>520个32位r寄存器。这些寄存器又被分成8个全局寄存器，再加上2</del>32个与实现有关的16位寄存器组，每一个寄存器组又进一步分为8个输入寄存器和8个输出寄存器。<br>&nbsp;<img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210260926694.png" alt="|500"><br>&nbsp;<img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210260932765.png" alt="|500"><br>上图是一个8窗口寄存器结构示意图。在任何一个时刻，一条指令只能访问8个全局寄存器和由当前窗口指针(CWP)指定的当前窗口。这个窗口是由8个输入寄存器、8个局部寄存器和8个输入寄存器构成。从图中可以看出，两个相邻窗口的入和出寄存器是共享的。<u>当前是按窗口号顺序(或前或后)转换的，正好上一次的输出寄存器成为当前窗口的输入寄存器，这样可以减少存储器读写和运行时的现场保护。</u></p><h2 id="AMBA"><a href="#AMBA" class="headerlink" title="AMBA"></a>AMBA</h2><p>&nbsp;AMBA(Advanced Microntroller Bus Architecture)规范，是一种已制定的、开放的规范，充当着SoC设计的架构，正迅速成为SoC和IP库开发事实上的标准，为高性能嵌入式微控制器设计定义了一种片上通信标准。<br>&nbsp;AMBA规范中定义了三种不同的总线,即 AHB 、ASB 和 APB 。<br>&nbsp;* AHB 是为高性能、高时钟频率的系统模块提供的,担任着高性能系统的背板总线、支持多处理器、片上各种存储器和片外外部存储器接口连接到低功耗辅助宏单元。<br>&nbsp;* ASB也是为高性能系统模块提供,当AHB 的高性能特点无需要时,就可以用ASB 来代替；它也支持多处理器、片上各种存储器和片外外部存储器接口连接到低功耗辅助宏单元。<br>&nbsp;* APB 是为低功耗的外围设备提供的,它优化到为最小功耗和减小接口的复杂性来支持辅助功能。</p><h2 id="容错问题"><a href="#容错问题" class="headerlink" title="容错问题"></a>容错问题</h2><p>为了适用于航空航天的高可靠性应用，Leon2采用多层次的容错策略；奇偶校验、TMR(三模冗余)寄存器、片上EDAC(检错和纠错)、流水线重启、强迫Cache不命中等．尽管现在几乎所有CPU都有一些常规的容错措施，如奇偶校验、流水线重启等，像IBM S／390 G5还采用了写阶段以前的全部流水线复制技术。IntelItanium采用的混合ECC和校验编码等技术；但远没有Leon2那样，采用如此全面的容错措施。</p><p>Leon2将时序(存储)单元的状态翻转作为数字容错的主要内容，根据时序逻辑的不同特点和性质，采用了不同的容错技术和手段．</p><h3 id="Cache的容错"><a href="#Cache的容错" class="headerlink" title="Cache的容错"></a>Cache的容错</h3><p>大的Cache对高性能CPU来说是至关重要的，而且位于处理器的关键(时间)通路上。为了减少复杂性和时间开销，错误检测的方法<span style="background:rgba(240, 200, 0, 0.2)">采用2位的奇偶校验位，l位用作奇校验，l位偶校验</span>，因此可以检查所有的错误情况，在读Cache的同时进行校验。当校验出错误，强制Cache丢失，并从外部存储去获取数据。</p><h3 id="处理器寄存器文件的错误保护"><a href="#处理器寄存器文件的错误保护" class="headerlink" title="处理器寄存器文件的错误保护"></a>处理器寄存器文件的错误保护</h3><p>寄存器文件是处理器内部的寄存器堆，内部的寄存器对于指令的运行速度和用户程序设计的灵活程度都是很重要的。内部寄存器的使用频率很大，其状态的正确性是也很关键。Leon2<span style="background:rgba(240, 200, 0, 0.2)">采用1、2奇偶校验位和(32.7)BCH校验和进行容错</span>。</p><h3 id="触发器的错误保护"><a href="#触发器的错误保护" class="headerlink" title="触发器的错误保护"></a>触发器的错误保护</h3><p>处理器的2500个触发器均<span style="background:rgba(240, 200, 0, 0.2)">采用三模冗余的方式进行容错</span>，通过表决器来决出正确的输出。</p><h3 id="外部存储器的错误保护"><a href="#外部存储器的错误保护" class="headerlink" title="外部存储器的错误保护"></a>外部存储器的错误保护</h3><p>采用挂上的EDAC单元实现。EDAC：<span style="background:rgba(240, 200, 0, 0.2)">采用标准的(32.7)BCH码，每32位字可纠正1位错误和检测2位错误。</span></p><h3 id="主检测模式"><a href="#主检测模式" class="headerlink" title="主检测模式"></a>主检测模式</h3><p>是指<span style="background:rgba(240, 200, 0, 0.2)">两个相同的处理器同时并行执行相同的指令，只让其中的主模式处理器输出结果，不让检测模式的处理器输出结果</span>。在内部，将检测模式处理器的输出同主模式处理器输出进行比较，以检查错误是否存在。这种工作模式，可以应用于要求更高可靠性的情况。</p><h3 id="Cache的清洗"><a href="#Cache的清洗" class="headerlink" title="Cache的清洗"></a>Cache的清洗</h3><p>因为上面介绍的五种方法，只有在对相应的单元进行访问时才进行错误检查。如果存储单元的数据不常使用，这些单元的错误会逐渐增加，因此必须<span style="background:rgba(240, 200, 0, 0.2)">使用一些软件的方法来实现</span>。</p><h2 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h2>]]></content>
      
      
      <categories>
          
          <category> 数字IC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leon2处理器 </tag>
            
            <tag> 车规芯片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Obsidan(四)  自带callout用法</title>
      <link href="/2022/10/24/obsidan-si-zi-dai-callout-yong-fa/"/>
      <url>/2022/10/24/obsidan-si-zi-dai-callout-yong-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><pre class=" language-markdown"><code class="language-markdown"><span class="token blockquote punctuation">></span> [!INFO]<span class="token blockquote punctuation">></span> 内容（它支持<span class="token bold"><span class="token punctuation">**</span>markdown<span class="token punctuation">**</span></span>，维基链接和嵌入内容）</code></pre><blockquote><p>[!INFO]<br>内容（它支持<strong>markdown</strong>，<a href="https://help.obsidian.md/How+to/Internal+link">维基链接</a>和<a href="https://help.obsidian.md/How+to/Embed+files">嵌入</a>！）</p></blockquote><h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><ol><li>note<blockquote><p>[!note]<br>内容</p></blockquote></li><li>abstract, summary, tldr<blockquote><p>[!abstract]<br>内容</p></blockquote></li><li>info, todo<blockquote><p>[!info]<br>内容</p></blockquote></li><li>tip, hint, important<blockquote><p>[!tip]<br>内容</p></blockquote></li><li>success, check, done<blockquote><p>[!success]<br>内容</p></blockquote></li><li>question, help, faq<blockquote><p>[!question]<br>内容</p></blockquote></li><li>warning, caution, attention<blockquote><p>[!warning]<br>内容</p></blockquote></li><li>failure, fail, missing<blockquote><p>[!failure]<br>内容</p></blockquote></li><li>danger, error<blockquote><p>[!danger]<br>内容</p></blockquote></li><li>bug<blockquote><p>[!bug]<br>内容</p></blockquote></li><li>example<blockquote><p>[!example]<br>内容</p></blockquote></li><li>quote, cite<blockquote><p>[!quote]<br>内容</p></blockquote></li></ol><h1 id="自定义标题"><a href="#自定义标题" class="headerlink" title="自定义标题"></a>自定义标题</h1><pre class=" language-markdown"><code class="language-markdown"><span class="token blockquote punctuation">></span> [!TIP] Callouts can have custom titles, which also supports <span class="token bold"><span class="token punctuation">**</span>markdown<span class="token punctuation">**</span></span>!</code></pre><blockquote><p>[!TIP] Callouts can have custom titles, which also supports <strong>markdown</strong>!<br>内容</p></blockquote><h1 id="折叠"><a href="#折叠" class="headerlink" title="折叠"></a>折叠</h1><p><strong>使用&nbsp;<code>+</code>&nbsp;默认展开或者&nbsp;<code>-</code>&nbsp;默认折叠正文部分</strong><br><strong>默认展开</strong>：</p><pre class=" language-markdown"><code class="language-markdown"><span class="token blockquote punctuation">></span> [!important]+<span class="token blockquote punctuation">></span> 可以使用<span class="token entity" title="&nbsp;">&amp;nbsp;</span><span class="token code keyword">`+`</span><span class="token entity" title="&nbsp;">&amp;nbsp;</span>默认展开或者<span class="token entity" title="&nbsp;">&amp;nbsp;</span><span class="token code keyword">`-`</span><span class="token entity" title="&nbsp;">&amp;nbsp;</span>默认折叠正文部分</code></pre><blockquote><p>[!important]+<br>可以使用&nbsp;<code>+</code>&nbsp;默认展开或者&nbsp;<code>-</code>&nbsp;默认折叠正文部分</p></blockquote><p><strong>默认折叠</strong>：</p><pre class=" language-markdown"><code class="language-markdown"><span class="token blockquote punctuation">></span> [!important]-<span class="token blockquote punctuation">></span> 可以使用<span class="token entity" title="&nbsp;">&amp;nbsp;</span><span class="token code keyword">`+`</span><span class="token entity" title="&nbsp;">&amp;nbsp;</span>默认展开或者<span class="token entity" title="&nbsp;">&amp;nbsp;</span><span class="token code keyword">`-`</span><span class="token entity" title="&nbsp;">&amp;nbsp;</span>默认折叠正文部分</code></pre><blockquote><p>[!important]-<br>可以使用&nbsp;<code>+</code>&nbsp;默认展开或者&nbsp;<code>-</code>&nbsp;默认折叠正文部分</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 猎奇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Obsidian </tag>
            
            <tag> callout </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SystemVerilog课程笔记(六)</title>
      <link href="/2022/10/24/systemverilog-ke-cheng-bi-ji-liu/"/>
      <url>/2022/10/24/systemverilog-ke-cheng-bi-ji-liu/</url>
      
        <content type="html"><![CDATA[<h1 id="1-将数据传输从结构体改造为类"><a href="#1-将数据传输从结构体改造为类" class="headerlink" title="1. 将数据传输从结构体改造为类"></a>1. 将数据传输从结构体改造为类</h1><h2 id="1-1-改造"><a href="#1-1-改造" class="headerlink" title="1.1 改造"></a>1.1 改造</h2><div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211161658402.png " width="80%" height="80%"></div><h2 id="1-2-改造后的tb-sv"><a href="#1-2-改造后的tb-sv" class="headerlink" title="1.2 改造后的tb.sv"></a>1.2 改造后的tb.sv</h2><pre class=" language-systemverilog"><code class="language-systemverilog">class rt_packet;  bit [3:0] src;  bit [3:0] dst;  bit [7:0] data [];  function void set_members(bit [3:0]src, bit [3:0]dst, bit[7:0]data []);    this.src = src;    this.dst = dst;    this.data = data;  endfunctionendclassinterface rt_interface();    logic clock;    logic reset_n;    logic [15:0] din;    logic [15:0] frame_n;    logic [15:0] valid_n;    logic [15:0] dout;    logic [15:0] valido_n;    logic [15:0] busy_n;    logic [15:0] frameo_n;endinterface//********************************** stimulator **********************************//module rt_stimulator(    rt_interface intf);//for debug purpose from waveform//定义检测状态的变量  typedef enum {DRV_RESET,DRV_IDLE,DRV_ADDR,DRV_PAD,DRV_DATA} drv_state_t;  drv_state_t dbg_state;    byte unsigned dbg_din_chnl0_data;   int src_chnl_status[int];  //关联数组，后面int：src_chnl的number；前面int：dest_chnl的Number ？？    //generator传送p给stimulator  rt_packet pkts[$];//定义stimulator中的的队列pkts  function void put_pkt(input rt_packet p);    pkts.push_back(p);//将generator中传过来的p放入stimulator的pkts中(在pkts队列尾插入p)  endfunction//reset阶段，复位时，reset_n为低电平,frame_n和valid_n为高电平initial begin : drive_reset_proc   drive_reset();endtask drive_reset();  @(negedge intf.reset_n);  dbg_state <= DRV_RESET;  intf.din <= 0;  intf.frame_n <= '1;//等效16'hFFFF  intf.valid_n <= '1;endtask// 发送数据initial begin : drive_chnl_proc    //rt_packet_t p;  @(negedge intf.reset_n);  repeat(10) @(posedge intf.clock);//延迟10个时钟周期  forever begin    automatic rt_packet p;//声明一个动态的    wait(pkts.size()>0);    p = pkts.pop_front();//将p从队列pkts里面取出    fork//后台触发线程，触发线程在后台运行，继续执行剩下内容        begin            wait_src_chnl_avail(p);//判断src chnl是否被占用，是否需要等待            drive_chnl(p.src, p.dst, p.data);//从P中拿到发送端口，目标端口，发送数据            set_src_chnl_avail(p);        end    join_none    endendtask automatic wait_src_chnl_avail(rt_packet p);//判断src chnl是否被占用，是否需要等待    if(!src_chnl_status.exists(p.src))//src_chnl_status关联数组里面不含p.src，(表示未占用任何dest_chnl,一开始不满足）        src_chnl_status[p.src] = p.dst;//表示当前正在使用src_chnl,对应dest_chnl就是p.dst（p.src端口在向p.dst端口发送数据）    else if(src_chnl_status[p.src] >= 0)//如果在给0,1,2...dest_chnl发送数据（被占用），需要等待,，否则不需要等待        wait(src_chnl_status[p.src] == -1);//直到src_chnl_status[p.src] == -1(自定义的dest_chnl端口数之外任意的数，表示未占用任何dest_chnl)endtaskfunction automatic set_src_chnl_avail(rt_packet p);    src_chnl_status[p.src] = -1;//如果chnl发送完后，把src_chnl置回来(自定义的dest_chnl端口数之外任意的数，表示未占用任何dest_chnl)endfunctiontask automatic drive_chnl(bit[3:0] saddr, bit [3:0] daddr, byte unsigned data[]);  $display("@%0t: [DRV]src_chnl[%0d],dest_chnl[%0d] data trans started",$time,saddr,daddr);    // drive address phase 输入地址位阶段for(int i=0;i<4;i++)begin  //4 clock  @(posedge intf.clock);  dbg_state <=DRV_ADDR;  intf.din[saddr] <= daddr[i];  intf.valid_n[saddr] <= $urandom_range(0,1);//valid_n在din的地址输入时间段可为任意值x  intf.frame_n[saddr] <= 1'b0;//frame_n需要为低end    // drive pad phase //隔离阶段  for (int i=0;i<5;i++)begin  //5 clock    @(posedge intf.clock);    dbg_state <=DRV_PAD;    intf.din[saddr] <= 1'b1;    intf.valid_n[saddr] <= 1'b1;//valid_n需为高电平    intf.frame_n[saddr] <= 1'b0; //frame_n需为低电平  end    // drive data phase 传输数据阶段  foreach(data[id])begin    for(int i=0;i<8;i++)begin     @(posedge intf.clock);      dbg_state <=DRV_DATA;      dbg_din_chnl0_data <= data[id];      intf.din[saddr] <= data[id][i];      intf.valid_n[saddr] <=1'b0;      intf.frame_n[saddr] <= (id == data.size()-1 && i == 7) ? 1'b1 : 1'b0;//packet最后一位输出数据时frameo_n为高    end  end// drive idle phase 闲置（没有数据传输）阶段  @(posedge intf.clock);  dbg_state <=DRV_IDLE;  dbg_din_chnl0_data <= 0;  intf.din[saddr] <= 1'b0;  intf.valid_n[saddr] <= 1'b1;  intf.frame_n[saddr] <= 1'b1;  $display("@%0t: [DRV]src_chnl[%0d],dest_chnl[%0d] data trans finished",$time,saddr,daddr);endtaskendmodule//********************************** generator **********************************//module rt_generator;//generator产生数据交给stimulator  rt_packet pkts[$];//定义队列  function void put_pkt(input rt_packet p);    pkts.push_back(p);//将p放入队列pkts里面（在pkts队列尾插入p）  endfunction    task get_pkt(output rt_packet p);    wait(pkts.size() >0 )//队列不为空      p = pkts.pop_front();//将p从队列pkts里面取出，提取队列首元素  endtask  //generate a random packet  function void gen_pkt(int src = -1, int dst = -1);  endfunctionendmodule//********************************** monitor **********************************//module rt_monitor(rt_interface intf);    rt_packet in_pkts[16][$];    rt_packet out_pkts[16][$];    initial begin : mon_chnl_proc        foreach(in_pkts[i]) begin            automatic int chid = i;            fork            mon_chnl_in(chid);//每个输入端口均调用mon_chnl_in任务，监测数据输入            mon_chnl_out(chid);//每个输出端口均调用mon_chnl_out任务，监测数据输入            join_none        end    end    task automatic mon_chnl_in (bit[3:0]id);//监测数据输入的任务    rt_packet pkt;//定义结构体变量    forever begin    //clear content for the same struct variable。清除pkt    pkt = new();    pkt.src = id;//第id个输入端口    //monitor specific channel-in data and put it into the queue    // monitor address phase    @(negedge intf.frame_n[id]);//监测frame_n下降沿(frame_n由时钟驱动)    for(int i=0; i<4; i++)begin        @(negedge intf.clock);//frame_n下降沿后监测4个clk negedge        pkt.dst[i]= intf.din[id];        end        $display ("@%0t: [MON] src_chn1[%0d] & dest_chn1[%0d] data trans started",$time,pkt.src,pkt.dst);    //pass pad phase 不考虑pad阶段是否满足协议要求    repeat(5) @(negedge intf.clock);    do begin        pkt.data = new [pkt.data.size + 1](pkt.data);//创建动态数组并复制pkt.data        for ( int i=0; i<8; i++) begin            @(negedge intf.clock); //在8个clk negedge监测8bit数据            pkt.data[pkt.data.size-1][i] = intf.din[id];        end    end while(!intf.frame_n[id]);    in_pkts[id].push_back(pkt);//将monitor拿到的数据放入in_pkts    $display("@%0t: [MON] src_chn1[%0d] & dest_chn1[%0d] data trans [%0p] finished",$time,pkt.src,pkt.dst,pkt.data);    endendtasktask automatic mon_chnl_out(bit[ 3:0]id);//监测数据输出的任务    rt_packet pkt;    forever begin        //clear content for the same struct variable        pkt = new();        pkt.src = 0;        pkt.dst = id;        @(negedge intf.frameo_n[id]);        $display( "@%0t: [MON] CH_OUT dest_chn1[%0d] data trans started",$time,pkt.dst);        do begin        pkt.data = new [ pkt.data.size + 1](pkt.data);        for(int i=0;i<8; i++) begin            @(negedge intf.clock iff !intf.valido_n[id]);//clock与valido_n信号同时为低            pkt.data[pkt.data.size-1][i]= intf.dout [id];        end    end while(!intf.frameo_n[id]);    out_pkts[id].push_back(pkt);    $display("@%0t: [MON] CH_OUT dest_chn1[%0d] data trans [%0p] finished",$time,pkt.dst,pkt.data);    //monitor specific channel-out data and put it into the queue    endendtaskendmodule//********************************** tb **********************************//module tb;bit clk,rstn;logic [15:0] din, frame_n, valid_n;logic [15:0] dout, valido_n, busy_n, frameo_n;// 产生时钟，周期为10nsinitial     forever #5ns clk <= !clk;// 产生复位信号  initial begin    #2ns rstn <= 1;    #10ns rstn <= 0;    #10ns rstn <= 1;  end//例化router为DUTrouter dut(             .reset_n(rstn),  .clock(clk),  .frame_n(intf.frame_n),  .valid_n(intf.valid_n),  .din(intf.din),  .dout(intf.dout),  .busy_n(intf.busy_n),  .valido_n(intf.valido_n),  .frameo_n(intf.frameo_n));rt_interface intf();//例化接口    assign intf.reset_n = rstn;    assign intf.clock = clk;    //例化stimulatorrt_stimulator stim(intf);//例化Monitorrt_monitor mon(intf);//例化generatorrt_generator gen();    initial begin:generate_data_proc//产生数据        rt_packet p;        p = new();        p.set_members(0,3,'{8'h33,8'h77});        gen.put_pkt(p);        p = new();//每次put_pkt都需要new一下        p.set_members(0,5,'{8'h55,8'h66});        gen.put_pkt(p);        p = new();        p.set_members(3,6,'{8'h77,8'h88,8'h22});        gen.put_pkt(p);        p = new();        p.set_members(4,7,'{8'haa,8'hcc,8'h33});        gen.put_pkt(p);    endinitial begin:genarator_to_stimulator_proc//取出genarator中的数据给stimulator    rt_packet p;    forever begin        gen.get_pkt(p);        stim.put_pkt(p);    endendendmodule </code></pre><h2 id="1-3-仿真结果"><a href="#1-3-仿真结果" class="headerlink" title="1.3 仿真结果"></a>1.3 仿真结果</h2><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211161639835.png" width="60%" height="60%"></div><h1 id="2-将drive-chnl任务的输入改为类"><a href="#2-将drive-chnl任务的输入改为类" class="headerlink" title="2. 将drive_chnl任务的输入改为类"></a>2. 将drive_chnl任务的输入改为类</h1><h2 id="2-1-改造"><a href="#2-1-改造" class="headerlink" title="2.1 改造"></a>2.1 改造</h2><p><strong>(1)增加打印函数</strong></p><pre class=" language-systemverilog"><code class="language-systemverilog">  function string sprint();//打印packet信息的函数    sprint = {sprint , $sformatf("src = %0d\n",src)};    sprint = {sprint , $sformatf("dst = %0d\n",dst)};    sprint = {sprint , $sformatf("data_length = %0d\n",data.size())};    foreach(data[i])        sprint = {sprint , $sformatf("data[%0d] = 'h%0x\n", i, data[i])};  endfunction</code></pre><p><strong>(2)将drive_chnl任务的输入改为类</strong></p><pre class=" language-systemverilog"><code class="language-systemverilog">task automatic drive_chnl(rt_packet p);</code></pre><h2 id="2-2-改造后的tb-sv"><a href="#2-2-改造后的tb-sv" class="headerlink" title="2.2 改造后的tb.sv"></a>2.2 改造后的tb.sv</h2><pre class=" language-systemverilog"><code class="language-systemverilog">class rt_packet;  bit [3:0] src;  bit [3:0] dst;  bit [7:0] data [];  function new();  endfunction  function void set_members(bit [3:0]src, bit [3:0]dst, bit[7:0]data []);    this.src = src;    this.dst = dst;    this.data = data;  endfunction  function string sprint();    sprint = {sprint , $sformatf("src = %0d\n",src)};    sprint = {sprint , $sformatf("dst = %0d\n",dst)};    sprint = {sprint , $sformatf("data_length = %0d\n",data.size())};    foreach(data[i])        sprint = {sprint , $sformatf("data[%0d] = 'h%0x\n", i, data[i])};    endfunction    endclass//**********************************  rt_stimulator  ***********************************//interface rt_interface;    logic clock;    logic reset_n;    logic [15:0] din;    logic [15:0] frame_n;    logic [15:0] valid_n;    logic [15:0] dout;    logic [15:0] valido_n;    logic [15:0] busy_n;    logic [15:0] frameo_n;endinterface    module rt_stimulator(  rt_interface intf);//for debug purpose from waveform    typedef enum {DRV_RESET,DRV_IDLE,DRV_ADDR,DRV_PAD,DRV_DATA} drv_state_t;    drv_state_t dbg_state;//定义状态检测变量dbg_state    byte unsigned dbg_din_chnl0_data;    rt_packet pkts[$];//队列里面存放的将是rt_packet句柄而不再是实际的对象    int src_chnl_status[int];  //关联数组，后面int：src_chnl的number；前面int：dest_chnl的Number ？？    function void put_pkt(input rt_packet p);        pkts.push_back(p);    endfunction    initial begin : drive_reset_proc        drive_reset();    end    task drive_reset();        @(negedge intf.reset_n);        dbg_state <= DRV_RESET;        intf.din <= 0;        intf.frame_n <= '1;        intf.valid_n <= '1;    endtask    initial begin : drive_chnl_proc        @(negedge intf.reset_n);        repeat(10) @(posedge intf.clock);        forever begin             automatic rt_packet p;//声明一个动态的            wait(pkts.size() > 0);            p = pkts.pop_front();            fork//后台触发线程，触发线程在后台运行，继续执行剩下内容                begin                wait_src_chnl_avail(p);                drive_chnl(p);                set_src_chnl_avail(p);                end            join_none        end    end        task automatic wait_src_chnl_avail(rt_packet p);//判断src chnl是否被占用，是否需要等待    if(!src_chnl_status.exists(p.src))//动态数组为空        src_chnl_status[p.src] = p.dst;//表示当前正在使用src_chnl,对应dest就是p.dst    else if(src_chnl_status[p.src] >= 0)//如果给dest的0,1,2这样的chnl在发送数据，需要等待        wait(src_chnl_status[p.src] == -1);//直到    endtask        function automatic set_src_chnl_avail(rt_packet p);        src_chnl_status[p.src] = -1;//如果chnl发送完后，把src_chnl置回来    endfunction    task automatic drive_chnl(rt_packet p);        $display("@%0t:[DRV] src_chnl[%0d] & dest_chnl[%0d] data trans started with packet: \n %s",$time,p.src,p.dst,p.sprint());// drive address phase         for(int i=0; i<4; i++)begin        @(posedge intf.clock);        dbg_state <=DRV_ADDR;        intf.din[p.src] <= p.dst[i];        intf.valid_n[p.src] <= $urandom_range(0,1);        intf.frame_n[p.src] <= 1'b0;    end// drive pad phase   for (int i=0; i<5; i++)begin    @(posedge intf.clock);    dbg_state <= DRV_PAD;    intf.din[p.src] <= 1'b1;    intf.valid_n[p.src] <= 1'b1;    intf.frame_n[p.src] <= 1'b0;  end// drive data phase  foreach(p.data[id])begin    for(int i=0;i<8; i++)begin    @(posedge intf.clock);    dbg_state <= DRV_DATA;    dbg_din_chnl0_data <= p.data[id];    intf.din[p.src] <= p.data[id][i];    intf.valid_n[p.src] <=1'b0;    intf.frame_n[p.src] <= (id == p.data.size()-1 && i == 7) ? 1'b1 : 1'b0;    end  end// drive idle phase  @(posedge intf.clock);  dbg_state <= DRV_IDLE;  dbg_din_chnl0_data <= 0;  intf.din[p.src] <= 1'b0;  intf.valid_n[p.src] <= 1'b1;  intf.frame_n[p.src] <= 1'b1;  $display("@%0t:[DRV] src_chnl[%0d] &dest_chnl[%0d ] finished",$time,p.src,p.dst);endtaskendmodule//**********************************  rt_generator  ************************************//module rt_generator;  rt_packet pkts[$];//定义队列pkts  function void put_pkt(input rt_packet p);    pkts.push_back(p);//在pkts队列尾插入p  endfunction  task get_pkt(output rt_packet p);    wait(pkts.size() >0 )      p = pkts.pop_front();//pkts.size()>0时执行，提取队列首元素，输出队列首元素  endtask  //generate a random packet  function void gen_pkt(int src = -1, int dst = -1);  endfunctionendmodulemodule rt_monitor(rt_interface intf);    rt_packet in_pkts[16][$];    rt_packet out_pkts[16][$];        initial begin: mon_chnl_proc        foreach(in_pkts[i])begin        automatic int chid = i;        fork             mon_chnl_in (chid);            mon_chnl_out (chid);        join_none        end    end        task automatic mon_chnl_in(bit[3:0] id);    rt_packet pkt;    forever begin        //clear content for the same struct variable        pkt = new();        pkt.dst = id;        //monitor specific channel-in data abd put in into the quene        //monitor adress phase        @(negedge intf.frame_n[id]);        for (int i = 0;i<4;i++)begin            @(negedge intf.clock);            pkt.dst[i] = intf.din[id];        end        $display("@%0t:[MON] CH_IN src_chnl[%0d] &dest_chnl[%0d ]data trans started",$time,pkt.src,pkt.dst);        //pass pad phase 不考虑pad阶段        repeat(5) @(negedge intf.clock);        do begin            pkt.data = new[pkt.data.size + 1] (pkt.data);            for (int i=0;i<8;i++)begin                @(negedge intf.clock);                pkt.data[pkt.data.size - 1][i] = intf.din[id];            end        end while(intf.frame_n[id]);        in_pkts[id].push_back(pkt);        $display("@%0t:[MON] CH_IN src_chnl[%0d] &dest_chnl[%0d ] finished with packet: \n %s",$time,pkt.src,pkt.dst,pkt.sprint());    end    endtask        task automatic mon_chnl_out(bit[3:0] id);        rt_packet pkt;    forever begin        //clear content for the same struct variable        pkt = new();        pkt.src = 0;        pkt.dst = id;        @(negedge intf.frameo_n[id]);        $display("@%0t:[MON] CH_OUT dest_chnl[%0d ]data trans started",$time,pkt.dst);        do begin            pkt.data = new[pkt.data.size + 1] (pkt.data);            for (int i=0;i<8;i++)begin                @(negedge intf.clock iff !intf.valido_n[id]);                pkt.data[pkt.data.size - 1][i] = intf.din[id];            end        end while(!intf.frameo_n[id]);        out_pkts[id].push_back(pkt);        $display("@%0t:[MON] CH_OUT dest_chnl[%0d ] finished with packet: \n %s",$time,pkt.dst,pkt.sprint());    end    endtaskendmodulemodule rt_test_top;endmodule//********************************** tb  ************************************//module tb;    bit clk,rstn;    logic [15:0] din, frame_n, valid_n;    logic [15:0] dout, valido_n, busy_n, frameo_n;    // generate clock    initial         forever #5ns clk <= !clk;    // genarate reset    initial begin        #2ns  rstn <= 1;        #10ns rstn <= 0;        #10ns rstn <= 1;    end    router dut(//例化router为dut        .reset_n(rstn)        ,.clock(clk)        ,.frame_n(intf.frame_n)        ,.valid_n(intf.valid_n)        ,.din(intf.din)        ,.dout(intf.dout)        ,.busy_n(intf.busy_n)        ,.valido_n(intf.valido_n)        ,.frameo_n(intf.frameo_n));    rt_interface intf(); //例化rt_interface为intf    assign intf.reset_n = rstn;    assign intf.clock = clk;        rt_stimulator stim(intf);//例化rt_stimulator为stim        rt_monitor mon(intf);        rt_generator gen(); //例化rt_generator为gen //generate and transmit packet 产生数据    initial begin : generate_proc        rt_packet p;        p = new();        p.set_members(0,3,'{8'h33,8'h77});        gen.put_pkt(p);        p = new();//每次put_pkt都需要new一下        p.set_members(0,5,'{8'h55,8'h66});        gen.put_pkt(p);        p = new();        p.set_members(3,6,'{8'h77,8'h88,8'h22});        gen.put_pkt(p);        p = new();        p.set_members(4,7,'{8'haa,8'hcc,8'h33});        gen.put_pkt(p);    end        initial begin : transmit_proc        rt_packet p;    forever  begin       gen.get_pkt(p);//generator输出p，p为generator里pkts的首元素      stim.put_pkt(p);//把数据p输入stim里的pkts队列尾   end  end  endmodule</code></pre><h2 id="2-3-仿真结果"><a href="#2-3-仿真结果" class="headerlink" title="2.3 仿真结果"></a>2.3 仿真结果</h2><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211171321867.png" width="50%" height="50%"></div><h1 id="3-将stimulator、generator、monitor改为类"><a href="#3-将stimulator、generator、monitor改为类" class="headerlink" title="3. 将stimulator、generator、monitor改为类"></a>3. 将stimulator、generator、monitor改为类</h1><h2 id="3-1-改造"><a href="#3-1-改造" class="headerlink" title="3.1 改造"></a>3.1 改造</h2><p><strong>(1)将stimulator、generator、monitor从module改为class：</strong></p><pre class=" language-systemverilog"><code class="language-systemverilog">class rt_stimulator;    ...endclassclass rt_generator;    ...endclassclass rt_monitor;    ...endclass</code></pre><p><strong>(2)stimulator、generator、monitor的例化变为：</strong></p><pre class=" language-systemverilog"><code class="language-systemverilog">rt_stimulator stim;rt_monitor mon;rt_generator gen;        initial begin : inst_init_proc        //build stage,例化        stim = new();        gen = new();        mon = new();        //connect sage，连接        stim.intf = intf;        mon.intf = intf;        //run stage，run        fork            stim.run();//class里面的函数不会自动调用，需要手动调用            gen.run();            mon.run();        join_none    end</code></pre><p>类默认为动态，所以使用的automatic可以去掉<br><strong>(3)将drive_reset_proc和drive_chnl_proc这两个initial begin end语句改为task:</strong></p><pre class=" language-systemverilog"><code class="language-systemverilog">task run();    fork        drive_reset(); //reset动作        get_packet_and_drive(); //drive_chnl动作    join_noneendtask    task drive_reset();//reset    ...endtasktask drive_chnl_proc();//drive_chnl    ...endtask</code></pre><h2 id="3-2-改造后的tb-sv"><a href="#3-2-改造后的tb-sv" class="headerlink" title="3.2 改造后的tb.sv"></a>3.2 改造后的tb.sv</h2><pre class=" language-systemverilog"><code class="language-systemverilog">class rt_packet;  bit [3:0] src;  bit [3:0] dst;  bit [7:0] data [];  function new();  endfunction  function void set_members(bit [3:0]src, bit [3:0]dst, bit[7:0]data []);    this.src = src;    this.dst = dst;    this.data = data;  endfunction  function string sprint();//打印packet信息的函数    sprint = {sprint , $sformatf("src = %0d\n",src)};    sprint = {sprint , $sformatf("dst = %0d\n",dst)};    sprint = {sprint , $sformatf("data_length = %0d\n",data.size())};    foreach(data[i])        sprint = {sprint , $sformatf("data[%0d] = 'h%0x\n", i, data[i])};  endfunctionendclassinterface rt_interface();    logic clock;    logic reset_n;    logic [15:0] din;    logic [15:0] frame_n;    logic [15:0] valid_n;    logic [15:0] dout;    logic [15:0] valido_n;    logic [15:0] busy_n;    logic [15:0] frameo_n;endinterface//********************************** stimulator **********************************//class rt_stimulator;    virtual rt_interface intf;//class里的接口不能用端口的方式描述，需要添加virtual关键字，在类里面用接口的指针//for debug purpose from waveform//定义检测状态的变量  typedef enum {DRV_RESET,DRV_IDLE,DRV_ADDR,DRV_PAD,DRV_DATA} drv_state_t;  drv_state_t dbg_state;    byte unsigned dbg_din_chnl0_data;   int src_chnl_status[int];  //关联数组，后面int：src_chnl的number；前面int：dest_chnl的Number ？？    //generator传送p给stimulator  rt_packet pkts[$];//定义stimulator中的的队列pkts  function void put_pkt(input rt_packet p);    pkts.push_back(p);//将generator中传过来的p放入stimulator的pkts中(在pkts队列尾插入p)  endfunctiontask run();    fork        drive_reset(); //reset动作        get_packet_and_drive(); //drive_chnl动作    join_noneendtask    task drive_reset();//reset    forever begin        @(negedge intf.reset_n);        dbg_state <= DRV_RESET;        intf.din <= 0;        intf.frame_n <= '1;//等效16'hFFFF        intf.valid_n <= '1;    endendtask// 发送数据task get_packet_and_drive();//drive_chnl    //rt_packet_t p;  @(negedge intf.reset_n);  repeat(10) @(posedge intf.clock);//延迟10个时钟周期  forever begin    automatic rt_packet p;//声明一个动态的    wait(pkts.size()>0);    p = pkts.pop_front();//将p从队列pkts里面取出    fork//后台触发线程，触发线程在后台运行，继续执行剩下内容        begin            wait_src_chnl_avail(p);//判断src chnl是否被占用，是否需要等待            drive_chnl(p);//从P中拿到发送端口，目标端口，发送数据            set_src_chnl_avail(p);        end    join_none    endendtasktask  wait_src_chnl_avail(rt_packet p);//判断src chnl是否被占用，是否需要等待    if(!src_chnl_status.exists(p.src))//src_chnl_status关联数组里面不含p.src，(表示未占用任何dest_chnl,一开始不满足）        src_chnl_status[p.src] = p.dst;//表示当前正在使用src_chnl,对应dest_chnl就是p.dst（p.src端口在向p.dst端口发送数据）    else if(src_chnl_status[p.src] >= 0)//如果在给0,1,2...dest_chnl发送数据（被占用），需要等待,，否则不需要等待        wait(src_chnl_status[p.src] == -1);//直到src_chnl_status[p.src] == -1(自定义的dest_chnl端口数之外任意的数，表示未占用任何dest_chnl)endtaskfunction  set_src_chnl_avail(rt_packet p);    src_chnl_status[p.src] = -1;//如果chnl发送完后，把src_chnl置回来(自定义的dest_chnl端口数之外任意的数，表示未占用任何dest_chnl)endfunctiontask  drive_chnl(rt_packet p);  $display("@%0t:[DRV] src_chnl[%0d] & dest_chnl[%0d] data trans started with packet: \n%s",$time,p.src,p.dst,p.sprint());    // drive address phase 输入地址位阶段for(int i=0;i<4;i++)begin  //4 clock  @(posedge intf.clock);  dbg_state <=DRV_ADDR;  intf.din[p.src] <= p.dst[i];  intf.valid_n[p.src] <= $urandom_range(0,1);//valid_n在din的地址输入时间段可为任意值x  intf.frame_n[p.src] <= 1'b0;//frame_n需要为低end    // drive pad phase //隔离阶段  for (int i=0;i<5;i++)begin  //5 clock    @(posedge intf.clock);    dbg_state <=DRV_PAD;    intf.din[p.src] <= 1'b1;    intf.valid_n[p.src] <= 1'b1;//valid_n需为高电平    intf.frame_n[p.src] <= 1'b0; //frame_n需为低电平  end    // drive data phase 传输数据阶段  foreach(p.data[id])begin    for(int i=0;i<8;i++)begin     @(posedge intf.clock);      dbg_state <=DRV_DATA;      dbg_din_chnl0_data <= p.data[id];      intf.din[p.src] <= p.data[id][i];      intf.valid_n[p.src] <=1'b0;      intf.frame_n[p.src] <= (id == p.data.size()-1 && i == 7) ? 1'b1 : 1'b0;//packet最后一位输出数据时frameo_n为高    end  end// drive idle phase 闲置（没有数据传输）阶段  @(posedge intf.clock);  dbg_state <=DRV_IDLE;  dbg_din_chnl0_data <= 0;  intf.din[p.src] <= 1'b0;  intf.valid_n[p.src] <= 1'b1;  intf.frame_n[p.src] <= 1'b1;  $display("@%0t: [DRV]src_chnl[%0d],dest_chnl[%0d] data trans finished",$time,p.src,p.dst);endtaskendclass//********************************** generator **********************************//class rt_generator;//generator产生数据交给stimulator  rt_packet pkts[$];//定义队列  function void put_pkt(input rt_packet p);    pkts.push_back(p);//将p放入队列pkts里面（在pkts队列尾插入p）  endfunction    task get_pkt(output rt_packet p);    wait(pkts.size() >0 )//队列不为空      p = pkts.pop_front();//将p从队列pkts里面取出，提取队列首元素  endtask  //generate a random packet  function void gen_pkt(int src = -1, int dst = -1);  endfunction    task run();        //TODO  endtask    endclass//********************************** monitor **********************************//class rt_monitor;virtual rt_interface intf;    rt_packet in_pkts[16][$];    rt_packet out_pkts[16][$];    task run();    fork        mon_chnls();    join_noneendtask    task mon_chnls;    foreach(in_pkts[i]) begin        automatic int chid = i;        fork        mon_chnl_in(chid);//每个输入端口均调用mon_chnl_in任务，监测数据输入        mon_chnl_out(chid);//每个输出端口均调用mon_chnl_out任务，监测数据输入        join_none    endendtask    task  mon_chnl_in (bit[3:0]id);//监测数据输入的任务    rt_packet pkt;//定义结构体变量    forever begin    //clear content for the same struct variable。清除pkt    pkt = new();    pkt.src = id;//第id个输入端口    //monitor specific channel-in data and put it into the queue    // monitor address phase    @(negedge intf.frame_n[id]);//监测frame_n下降沿(frame_n由时钟驱动)    for(int i=0; i<4; i++)begin        @(negedge intf.clock);//frame_n下降沿后监测4个clk negedge        pkt.dst[i]= intf.din[id];        end        $display ("@%0t: [MON] src_chn1[%0d] & dest_chn1[%0d] data trans started",$time,pkt.src,pkt.dst);    //pass pad phase 不考虑pad阶段是否满足协议要求    repeat(5) @(negedge intf.clock);    do begin        pkt.data = new [pkt.data.size + 1](pkt.data);//创建动态数组并复制pkt.data        for ( int i=0; i<8; i++) begin            @(negedge intf.clock); //在8个clk negedge监测8bit数据            pkt.data[pkt.data.size-1][i] = intf.din[id];        end    end while(!intf.frame_n[id]);    in_pkts[id].push_back(pkt);//将monitor拿到的数据放入in_pkts    $display("@%0t:[MON] CH_IN src_chnl[%0d] &dest_chnl[%0d ] finished with packet: \n%s",$time,pkt.src,pkt.dst,pkt.sprint());    endendtasktask  mon_chnl_out(bit[ 3:0]id);//监测数据输出的任务    rt_packet pkt;    forever begin        //clear content for the same struct variable        pkt = new();        pkt.src = 0;        pkt.dst = id;        @(negedge intf.frameo_n[id]);        $display( "@%0t: [MON] CH_OUT dest_chn1[%0d] data trans started",$time,pkt.dst);        do begin        pkt.data = new [ pkt.data.size + 1](pkt.data);        for(int i=0;i<8; i++) begin            @(negedge intf.clock iff !intf.valido_n[id]);//clock与valido_n信号同时为低            pkt.data[pkt.data.size-1][i]= intf.dout [id];        end    end while(!intf.frameo_n[id]);    out_pkts[id].push_back(pkt);    $display("@%0t: [MON] CH_OUT dest_chn1[%0d] data finished woth packet : \n %s",$time,pkt.dst,pkt.sprint());    //monitor specific channel-out data and put it into the queue    endendtaskendclass//********************************** tb **********************************//module tb;bit clk,rstn;logic [15:0] din, frame_n, valid_n;logic [15:0] dout, valido_n, busy_n, frameo_n;// 产生时钟，周期为10nsinitial     forever #5ns clk <= !clk;// 产生复位信号  initial begin    #2ns rstn <= 1;    #10ns rstn <= 0;    #10ns rstn <= 1;  end//例化router为DUTrouter dut(             .reset_n(rstn),  .clock(clk),  .frame_n(intf.frame_n),  .valid_n(intf.valid_n),  .din(intf.din),  .dout(intf.dout),  .busy_n(intf.busy_n),  .valido_n(intf.valido_n),  .frameo_n(intf.frameo_n));rt_interface intf();//例化接口    assign intf.reset_n = rstn;    assign intf.clock = clk;    //例化stimulatorrt_stimulator stim;//例化Monitorrt_monitor mon;//例化generatorrt_generator gen;        initial begin : inst_init_proc        //build stage,例化        stim = new();        gen = new();        mon = new();        //connect sage，连接        stim.intf = intf;        mon.intf = intf;        //run stage，run        fork            stim.run();//class里面的函数不会自动调用，需要手动调用            gen.run();            mon.run();        join_none    end    initial begin:generate_data_proc//产生数据        rt_packet p;        #0; //wait for test components instantiated以下句柄并没有在仿真开始前例化完成，需要进入上面initial里面，所以为了上述initial先执行，等module转化为class例化完成再使用这些句柄，添加延迟最小时间单元        p = new();        p.set_members(0,3,'{8'h33,8'h77});        gen.put_pkt(p);        p = new();//每次put_pkt都需要new一下        p.set_members(0,5,'{8'h55,8'h66});        gen.put_pkt(p);        p = new();        p.set_members(3,6,'{8'h77,8'h88,8'h22});        gen.put_pkt(p);        p = new();        p.set_members(4,7,'{8'haa,8'hcc,8'h33});        gen.put_pkt(p);    endinitial begin:genarator_to_stimulator_proc//取出genarator中的数据给stimulator    rt_packet p;    #0; //wait for test components instantiated    forever begin        gen.get_pkt(p);        stim.put_pkt(p);    endendendmodule </code></pre><h2 id="3-3-仿真结果"><a href="#3-3-仿真结果" class="headerlink" title="3.3 仿真结果"></a>3.3 仿真结果</h2><p>结果同上，硬件结构层次如下：</p><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211171624571.png" width="45%" height="45%"></div><h1 id="4-增加checker组件"><a href="#4-增加checker组件" class="headerlink" title="4. 增加checker组件"></a>4. 增加checker组件</h1><h2 id="4-1-思路"><a href="#4-1-思路" class="headerlink" title="4.1 思路"></a>4.1 思路</h2><p>Checker从Monitor中拿到monitor采样的输入数据为期望的输出、拿到monitor采样的输出数据为实际的输出，比较二者判断输入与输出是否相等。</p><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211171936043.png" width="60%" height="60%"></div><h2 id="4-2-改造后的tb-sv"><a href="#4-2-改造后的tb-sv" class="headerlink" title="4.2 改造后的tb.sv"></a>4.2 改造后的tb.sv</h2><pre class=" language-systemverilog"><code class="language-systemverilog">class rt_packet;  bit [3:0] src;  bit [3:0] dst;  bit [7:0] data [];  function new();  endfunction  function void set_members(bit [3:0]src, bit [3:0]dst, bit[7:0]data []);    this.src = src;    this.dst = dst;    this.data = data;  endfunction  function string sprint();//打印packet信息的函数    sprint = {sprint , $sformatf("src = %0d\n",src)};    sprint = {sprint , $sformatf("dst = %0d\n",dst)};    sprint = {sprint , $sformatf("data_length = %0d\n",data.size())};    foreach(data[i])        sprint = {sprint , $sformatf("data[%0d] = 'h%0x\n", i, data[i])};  endfunction  function bit compare(rt_packet p);//输入exp_pkt        if(dst == p.dst && data == p.data)            compare = 1;        else             compare = 0;  endfunctionendclassinterface rt_interface();    logic clock;    logic reset_n;    logic [15:0] din;    logic [15:0] frame_n;    logic [15:0] valid_n;    logic [15:0] dout;    logic [15:0] valido_n;    logic [15:0] busy_n;    logic [15:0] frameo_n;endinterface//********************************** stimulator **********************************//class rt_stimulator;    virtual rt_interface intf;//class里的接口不能用端口的方式描述，需要添加virtual关键字，在类里面用接口的指针//for debug purpose from waveform//定义检测状态的变量  typedef enum {DRV_RESET,DRV_IDLE,DRV_ADDR,DRV_PAD,DRV_DATA} drv_state_t;  drv_state_t dbg_state;    byte unsigned dbg_din_chnl0_data;   int src_chnl_status[int];  //关联数组，后面int：src_chnl的number；前面int：dest_chnl的Number ？？    //generator传送p给stimulator  rt_packet pkts[$];//定义stimulator中的的队列pkts  function void put_pkt(input rt_packet p);    pkts.push_back(p);//将generator中传过来的p放入stimulator的pkts中(在pkts队列尾插入p)  endfunctiontask run();    fork        drive_reset(); //reset动作        get_packet_and_drive(); //drive_chnl动作    join_noneendtask    task drive_reset();//reset    forever begin        @(negedge intf.reset_n);        dbg_state <= DRV_RESET;        intf.din <= 0;        intf.frame_n <= '1;//等效16'hFFFF        intf.valid_n <= '1;    endendtask// 发送数据task get_packet_and_drive();//drive_chnl    //rt_packet_t p;  @(negedge intf.reset_n);  repeat(10) @(posedge intf.clock);//延迟10个时钟周期  forever begin    automatic rt_packet p;//声明一个动态的    wait(pkts.size()>0);    p = pkts.pop_front();//将p从队列pkts里面取出    fork//后台触发线程，触发线程在后台运行，继续执行剩下内容        begin            wait_src_chnl_avail(p);//判断src chnl是否被占用，是否需要等待            drive_chnl(p);//从P中拿到发送端口，目标端口，发送数据            set_src_chnl_avail(p);        end    join_none    endendtasktask  wait_src_chnl_avail(rt_packet p);//判断src chnl是否被占用，是否需要等待    if(!src_chnl_status.exists(p.src))//src_chnl_status关联数组里面不含p.src，(表示未占用任何dest_chnl,一开始不满足）        src_chnl_status[p.src] = p.dst;//表示当前正在使用src_chnl,对应dest_chnl就是p.dst（p.src端口在向p.dst端口发送数据）    else if(src_chnl_status[p.src] >= 0)//如果在给0,1,2...dest_chnl发送数据（被占用），需要等待,，否则不需要等待        wait(src_chnl_status[p.src] == -1);//直到src_chnl_status[p.src] == -1(自定义的dest_chnl端口数之外任意的数，表示未占用任何dest_chnl)endtaskfunction  set_src_chnl_avail(rt_packet p);    src_chnl_status[p.src] = -1;//如果chnl发送完后，把src_chnl置回来(自定义的dest_chnl端口数之外任意的数，表示未占用任何dest_chnl)endfunctiontask  drive_chnl(rt_packet p);  $display("@%0t:[DRV] src_chnl[%0d] & dest_chnl[%0d] data trans started with packet: \n%s",$time,p.src,p.dst,p.sprint());    // drive address phase 输入地址位阶段for(int i=0;i<4;i++)begin  //4 clock  @(posedge intf.clock);  dbg_state <=DRV_ADDR;  intf.din[p.src] <= p.dst[i];  intf.valid_n[p.src] <= $urandom_range(0,1);//valid_n在din的地址输入时间段可为任意值x  intf.frame_n[p.src] <= 1'b0;//frame_n需要为低end    // drive pad phase //隔离阶段  for (int i=0;i<5;i++)begin  //5 clock    @(posedge intf.clock);    dbg_state <=DRV_PAD;    intf.din[p.src] <= 1'b1;    intf.valid_n[p.src] <= 1'b1;//valid_n需为高电平    intf.frame_n[p.src] <= 1'b0; //frame_n需为低电平  end    // drive data phase 传输数据阶段  foreach(p.data[id])begin    for(int i=0;i<8;i++)begin     @(posedge intf.clock);      dbg_state <=DRV_DATA;      dbg_din_chnl0_data <= p.data[id];      intf.din[p.src] <= p.data[id][i];      intf.valid_n[p.src] <=1'b0;      intf.frame_n[p.src] <= (id == p.data.size()-1 && i == 7) ? 1'b1 : 1'b0;//packet最后一位输出数据时frameo_n为高    end  end// drive idle phase 闲置（没有数据传输）阶段  @(posedge intf.clock);  dbg_state <=DRV_IDLE;  dbg_din_chnl0_data <= 0;  intf.din[p.src] <= 1'b0;  intf.valid_n[p.src] <= 1'b1;  intf.frame_n[p.src] <= 1'b1;  $display("@%0t: [DRV]src_chnl[%0d],dest_chnl[%0d] data trans finished",$time,p.src,p.dst);endtaskendclass//********************************** generator **********************************//class rt_generator;//generator产生数据交给stimulator  rt_packet pkts[$];//定义队列  function void put_pkt(input rt_packet p);    pkts.push_back(p);//将p放入队列pkts里面（在pkts队列尾插入p）  endfunction    task get_pkt(output rt_packet p);    wait(pkts.size() >0 )//队列不为空      p = pkts.pop_front();//将p从队列pkts里面取出，提取队列首元素  endtask  //generate a random packet  function void gen_pkt(int src = -1, int dst = -1);  endfunction    task run();        //TODO  endtask    endclass//********************************** monitor **********************************//class rt_monitor;virtual rt_interface intf;    rt_packet in_pkts[16][$];    rt_packet out_pkts[16][$];    task run();    fork        mon_chnls();    join_noneendtask    task mon_chnls;    foreach(in_pkts[i]) begin        automatic int chid = i;        fork        mon_chnl_in(chid);//每个输入端口均调用mon_chnl_in任务，监测数据输入        mon_chnl_out(chid);//每个输出端口均调用mon_chnl_out任务，监测数据输入        join_none    endendtask    task  mon_chnl_in (bit[3:0]id);//监测数据输入的任务    rt_packet pkt;//定义结构体变量    forever begin    //clear content for the same struct variable。清除pkt    pkt = new();    pkt.src = id;//第id个输入端口    //monitor specific channel-in data and put it into the queue    // monitor address phase    @(negedge intf.frame_n[id]);//监测frame_n下降沿(frame_n由时钟驱动)    for(int i=0; i<4; i++)begin        @(negedge intf.clock);//frame_n下降沿后监测4个clk negedge        pkt.dst[i]= intf.din[id];        end        $display ("@%0t: [MON] src_chn1[%0d] & dest_chn1[%0d] data trans started",$time,pkt.src,pkt.dst);    //pass pad phase 不考虑pad阶段是否满足协议要求    repeat(5) @(negedge intf.clock);    do begin        pkt.data = new [pkt.data.size + 1](pkt.data);//创建动态数组并复制pkt.data        for ( int i=0; i<8; i++) begin            @(negedge intf.clock); //在8个clk negedge监测8bit数据            pkt.data[pkt.data.size-1][i] = intf.din[id];        end    end while(!intf.frame_n[id]);    in_pkts[id].push_back(pkt);//将monitor拿到的数据放入in_pkts    $display("@%0t:[MON] CH_IN src_chnl[%0d] &dest_chnl[%0d ] finished with packet: \n%s",$time,pkt.src,pkt.dst,pkt.sprint());    endendtasktask  mon_chnl_out(bit[ 3:0]id);//监测数据输出的任务    rt_packet pkt;    forever begin        //clear content for the same struct variable        pkt = new();        pkt.src = 0;        pkt.dst = id;        @(negedge intf.frameo_n[id]);        $display( "@%0t: [MON] CH_OUT dest_chn1[%0d] data trans started",$time,pkt.dst);        do begin        pkt.data = new [ pkt.data.size + 1](pkt.data);        for(int i=0;i<8; i++) begin            @(negedge intf.clock iff !intf.valido_n[id]);//clock与valido_n信号同时为低            pkt.data[pkt.data.size-1][i]= intf.dout [id];        end    end while(!intf.frameo_n[id]);    out_pkts[id].push_back(pkt);    $display("@%0t: [MON] CH_OUT dest_chn1[%0d] data finished woth packet : \n %s",$time,pkt.dst,pkt.sprint());    //monitor specific channel-out data and put it into the queue    endendtaskendclass//********************************** checker **********************************//class rt_checker;    int unsigned compare_count;    int unsigned error_count;        function new();//赋初值，可有可无，整形变量默认初始值为0        compare_count = 0;        error_count = 0;    endfunction        rt_packet exp_out_pkts[16][$];    rt_monitor mon;        task run();    foreach(exp_out_pkts[i])begin        automatic int chid = i;        fork            do_routing(chid);            do_compare(chid);        join_none        end    endtask        task do_routing(bit[3:0] id);//将monitor中采样到的输入数据放入期望的输出端队列中        rt_packet pkt;        forever begin            wait(mon.in_pkts[id].size > 0);            pkt = mon.in_pkts[id].pop_front();//从monitor中拿到in_pkts队列数据放入pkt            exp_out_pkts[pkt.dst].push_back(pkt);//将pkt数据放入对应期望的dest_chnl            end    endtask         task do_compare(bit[3:0] id);//比较采集的实际输出与期望输出        rt_packet exp_pkt, act_pkt;        forever begin            wait(mon.out_pkts[id].size > 0 && exp_out_pkts[id].size > 0);//实际采样数据与期望数据都有值            act_pkt = mon.out_pkts[id].pop_front();//实际数据为monitor采样的输出数据            exp_pkt = exp_out_pkts[id].pop_front();//期望数据为monitor采样到的输入数据            if(act_pkt.compare(exp_pkt))begin//如果exp_pkt与act_pkt比较成功，返回1                $display("[CHK] data compare success with packet : \n%s",act_pkt.sprint());            end            else begin                $display("[CHK] data compare failure with actual packet : \n%s \nexpected packet : \n%s", act_pkt.sprint(), exp_pkt.sprint());                error_count++;            end                compare_count++;        end    endtask         function void do_report();        $display("TOTAL COMPARING %0d times",compare_count);        if(!error_count)            $display("TEST PASSED!");        else begin            $display("TEST FAILED!");            $display("TOTAL ERROR %0d times", error_count);        end    endfunctionendclass//********************************** tb **********************************//module tb;bit clk,rstn;logic [15:0] din, frame_n, valid_n;logic [15:0] dout, valido_n, busy_n, frameo_n;// 产生时钟，周期为10nsinitial     forever #5ns clk <= !clk;// 产生复位信号  initial begin    #2ns rstn <= 1;    #10ns rstn <= 0;    #10ns rstn <= 1;  end//例化router为DUTrouter dut(             .reset_n(rstn),  .clock(clk),  .frame_n(intf.frame_n),  .valid_n(intf.valid_n),  .din(intf.din),  .dout(intf.dout),  .busy_n(intf.busy_n),  .valido_n(intf.valido_n),  .frameo_n(intf.frameo_n));rt_interface intf();//例化接口    assign intf.reset_n = rstn;    assign intf.clock = clk;    //例化stimulatorrt_stimulator stim;//例化Monitorrt_monitor mon;//例化generatorrt_generator gen;rt_checker chk;        initial begin : inst_init_proc        //build stage,例化        stim = new();        gen = new();        mon = new();        chk = new();        //connect sage，连接        stim.intf = intf;        mon.intf = intf;        chk.mon = mon;//check拿monitor句柄，即拿monitor中in_pkts与out_pkts队列        //run stage，run        fork            stim.run();//class里面的函数不会自动调用，需要手动调用            gen.run();            mon.run();            chk.run();        join_none    end    initial begin:generate_data_proc//产生数据        rt_packet p;        #0; //wait for test components instantiated以下句柄并没有在仿真开始前例化完成，需要进入上面initial里面，所以为了上述initial先执行，等module转化为class例化完成再使用这些句柄，添加延迟最小时间单元        p = new();        p.set_members(0,3,'{8'h33,8'h77});        gen.put_pkt(p);        p = new();//每次put_pkt都需要new一下        p.set_members(0,5,'{8'h55,8'h66});        gen.put_pkt(p);        p = new();        p.set_members(3,6,'{8'h77,8'h88,8'h22});        gen.put_pkt(p);        p = new();        p.set_members(4,7,'{8'haa,8'hcc,8'h33});        gen.put_pkt(p);    endinitial begin:genarator_to_stimulator_proc//取出genarator中的数据给stimulator    rt_packet p;    #0; //wait for test components instantiated    forever begin        gen.get_pkt(p);        stim.put_pkt(p);    endendendmodule </code></pre><h2 id="4-3-仿真结果"><a href="#4-3-仿真结果" class="headerlink" title="4.3 仿真结果"></a>4.3 仿真结果</h2><p><strong>DVE报告</strong></p><blockquote><p>dve&gt; run 2us<br>2000000 ps<br>@105000:[DRV] src_chnl[0] &amp; dest_chnl[3] data trans started with packet:<br>src = 0<br>dst = 3<br>data_length = 2<br>data[0] = ‘h33<br>data[1] = ‘h77</p><p>@105000:[DRV] src_chnl[3] &amp; dest_chnl[6] data trans started with packet:<br>src = 3<br>dst = 6<br>data_length = 3<br>data[0] = ‘h77<br>data[1] = ‘h88<br>data[2] = ‘h22</p><p>@105000:[DRV] src_chnl[4] &amp; dest_chnl[7] data trans started with packet:<br>src = 4<br>dst = 7<br>data_length = 3<br>data[0] = ‘haa<br>data[1] = ‘hcc<br>data[2] = ‘h33</p><p>@150000: [MON] src_chn1[0] &amp; dest_chn1[3] data trans started<br>@150000: [MON] src_chn1[3] &amp; dest_chn1[6] data trans started<br>@150000: [MON] src_chn1[4] &amp; dest_chn1[7] data trans started<br>@205000: [MON] CH_OUT dest_chn1[3] data trans started<br>@205000: [MON] CH_OUT dest_chn1[6] data trans started<br>@205000: [MON] CH_OUT dest_chn1[7] data trans started<br>@360000:[MON] CH_IN src_chnl[0] &amp;dest_chnl[3 ] finished with packet:<br>src = 0<br>dst = 3<br>data_length = 2<br>data[0] = ‘h33<br>data[1] = ‘h77</p><p>@365000: [DRV]src_chnl[0],dest_chnl[3] data trans finished<br>@365000:[DRV] src_chnl[0] &amp; dest_chnl[5] data trans started with packet:<br>src = 0<br>dst = 5<br>data_length = 2<br>data[0] = ‘h55<br>data[1] = ‘h66</p><p>@380000: [MON] CH_OUT dest_chn1[3] data finished woth packet :<br>src = 0<br>dst = 3<br>data_length = 2<br>data[0] = ‘h33<br>data[1] = ‘h77</p><p>[CHK] data compare success with packet :<br>src = 0<br>dst = 3<br>data_length = 2<br>data[0] = ‘h33<br>data[1] = ‘h77</p><p>@410000: [MON] src_chn1[0] &amp; dest_chn1[5] data trans started<br>@440000:[MON] CH_IN src_chnl[3] &amp;dest_chnl[6 ] finished with packet:<br>src = 3<br>dst = 6<br>data_length = 3<br>data[0] = ‘h77<br>data[1] = ‘h88<br>data[2] = ‘h22</p><p>@440000:[MON] CH_IN src_chnl[4] &amp;dest_chnl[7 ] finished with packet:<br>src = 4<br>dst = 7<br>data_length = 3<br>data[0] = ‘haa<br>data[1] = ‘hcc<br>data[2] = ‘h33</p><p>@445000: [DRV]src_chnl[3],dest_chnl[6] data trans finished<br>@445000: [DRV]src_chnl[4],dest_chnl[7] data trans finished<br>@460000: [MON] CH_OUT dest_chn1[6] data finished woth packet :<br>src = 0<br>dst = 6<br>data_length = 3<br>data[0] = ‘h77<br>data[1] = ‘h88<br>data[2] = ‘h22</p><p>@460000: [MON] CH_OUT dest_chn1[7] data finished woth packet :<br>src = 0<br>dst = 7<br>data_length = 3<br>data[0] = ‘haa<br>data[1] = ‘hcc<br>data[2] = ‘h33</p><p>[CHK] data compare success with packet :<br>src = 0<br>dst = 6<br>data_length = 3<br>data[0] = ‘h77<br>data[1] = ‘h88<br>data[2] = ‘h22</p><p>[CHK] data compare success with packet :<br>src = 0<br>dst = 7<br>data_length = 3<br>data[0] = ‘haa<br>data[1] = ‘hcc<br>data[2] = ‘h33</p><p>@465000: [MON] CH_OUT dest_chn1[5] data trans started<br>@620000:[MON] CH_IN src_chnl[0] &amp;dest_chnl[5 ] finished with packet:<br>src = 0<br>dst = 5<br>data_length = 2<br>data[0] = ‘h55<br>data[1] = ‘h66</p><p>@625000: [DRV]src_chnl[0],dest_chnl[5] data trans finished<br>@640000: [MON] CH_OUT dest_chn1[5] data finished woth packet :<br>src = 0<br>dst = 5<br>data_length = 2<br>data[0] = ‘h55<br>data[1] = ‘h66</p><p>[CHK] data compare success with packet :<br>src = 0<br>dst = 5<br>data_length = 2<br>data[0] = ‘h55<br>data[1] = ‘h66</p></blockquote><p><strong>硬件结构层次如下：</strong></p><div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211171907835.png " width="45%" height="45%"></div><h1 id="5-TestBench概览"><a href="#5-TestBench概览" class="headerlink" title="5. TestBench概览"></a>5. TestBench概览</h1><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211171924107.png" width="80%" height="80%"></div>]]></content>
      
      
      <categories>
          
          <category> 数字IC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字前端 </tag>
            
            <tag> SystemVerilog验证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lightroom后期（二）后期快速修片流程</title>
      <link href="/2022/10/23/lightroom-hou-qi-er-hou-qi-kuai-su-xiu-pian-liu-cheng/"/>
      <url>/2022/10/23/lightroom-hou-qi-er-hou-qi-kuai-su-xiu-pian-liu-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="第一步：改变照片的尺寸和比例"><a href="#第一步：改变照片的尺寸和比例" class="headerlink" title="第一步：改变照片的尺寸和比例"></a>第一步：改变照片的尺寸和比例</h1><h2 id="变换工具"><a href="#变换工具" class="headerlink" title="变换工具"></a>变换工具</h2><p>在变换工具中，可以进行手动或者自动校正垂直线</p><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210232202333.png" width="50%" height="50%"></div><h2 id="裁剪工具"><a href="#裁剪工具" class="headerlink" title="裁剪工具"></a>裁剪工具</h2><p>在裁剪叠加里有一个非常好用的小工具，当地平线在照片里比较明显可以看出来的时候，点击“自动”按钮就可以自动修正。</p><div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210232205428.png " width="45%" height="45%"></div>有很多时候照片里看不出水平线，需要手动调整，可以点击下面这个小尺子的图标。拉一条水平线，来告诉Lightroom这里本该是地平线，全都设置好了之后就可以锁定图像了。<div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/20221023_221022.gif" width="100%" height="100%"></div><h2 id="镜头矫正"><a href="#镜头矫正" class="headerlink" title="镜头矫正"></a>镜头矫正</h2><p>勾选移除色差和启用配置文件校正这两个选项可以进行视角矫正。<br>同样地，也可尽手动操作来校正广角镜头的畸变、以及消除紫边和暗角。</p><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210232241294.png" width="45%" height="45%"></div><h1 id="第二步：修整曝光还原色彩"><a href="#第二步：修整曝光还原色彩" class="headerlink" title="第二步：修整曝光还原色彩"></a>第二步：修整曝光还原色彩</h1><h2 id="白平衡校正"><a href="#白平衡校正" class="headerlink" title="白平衡校正"></a>白平衡校正</h2><p>这一步的目的主要是让照片中的颜色还原成拍摄时的样子，为之后的调色打基础。</p><div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210232246573.png " width="50%" height="50%"></div><h2 id="色调修正"><a href="#色调修正" class="headerlink" title="色调修正"></a>色调修正</h2><p>对照片的全局曝光进行修正</p><div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210232246382.png " width="45%" height="45%"></div>调整局部曝光可以使用径向滤镜、渐变滤镜和调整画笔。可以使用渐变滤镜调整比较规律的大面积；径向滤镜用来调整圆形或椭圆形范围；画笔可以更加精细调整局部范围。<div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210232249320.png " width="45%" height="45%"></div><h1 id="第三步：增加立体感和细节"><a href="#第三步：增加立体感和细节" class="headerlink" title="第三步：增加立体感和细节"></a>第三步：增加立体感和细节</h1><h2 id="偏好设置"><a href="#偏好设置" class="headerlink" title="偏好设置"></a>偏好设置</h2><div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210232252200.png " width="45%" height="45%"></div>其中，纹理和清晰度可以有效的增加细节和质感。## 色调曲线工具色调曲线工具可以同时改变照片的曝光和对比度，色调的改变可以导致照片的立体感产生变化。<div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210232254636.png " width="35%" height="35%"></div>## 细节工具对照片进行锐化和细节增强<div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210232256377.png" width="30%" height="30%"></div># 第四步：调色和添加效果接下来对照片进行微调或者加强渲染，形成自己的独特调色风格<div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210232301802.png" width="40%" height="40%"></div># 第五步：去除污点和杂物去除如传感器污点，影响照片效果的内容等等。可以使用Lightroom中的污点去除工具，不仅可以去除点状的内容，还可以去除复杂外形的杂物。只需要拖动鼠标，完整的覆盖想要去除的区域，lightroom就会寻找一个类似的内容进行覆盖。<div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210232305738.png" width="40%" height="40%"></div><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p><a href="https://www.bilibili.com/video/BV1mK4y1Q7uy/?vd_source=83d80c57e4377b69f911cc68016fb835">【Edi x TourBox后期训练营】后期修片的流程顺序 - 新手快速入门摄影后期的实用方法_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> 摄影后期 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lightroom </tag>
            
            <tag> 修片流程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WordPress安装教程</title>
      <link href="/2022/10/22/wordpress-an-zhuang-jiao-cheng/"/>
      <url>/2022/10/22/wordpress-an-zhuang-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<p>首先，需要购买一台云服务器/轻量云服务器，步骤如下<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222121301.png"><br>选择云服务器配置<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222126775.png"><br>购买完成后即可在如下位置看见已购买的云服务器（此处我购买的为轻量云服务器）<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222130358.png"><br>点击进入<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210231651076.png"></p><p>接下来进入管理面板<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210231651672.png"></p><p>要访问宝塔面板，防火墙/安全组需要放行面板[8888]端口，操作如下：<br>点进如下界面<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210231652992.png"></p><p>点击添加规则<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222135726.png"></p><p>在端口一栏输入<strong>8888</strong>以开放端口<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222135122.png"></p><p>之后在“应用管理”界面复制命令，点击登录<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210231653542.png"></p><p>此处需要登录一下<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222136412.png"></p><p>粘贴刚才复制的命令，回车<br>得到宝塔面板的登录信息，可以保存下来方便后面使用<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222136778.png"></p><p>浏览器中输入刚保存的外网面板地址，输入刚保存的账户密码登录<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222136087.png"></p><p>绑定宝塔账号(没有就去<a href="https://www.bt.cn/new/index.html">宝塔面板官网</a>)注册一个再来绑定）<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222136339.png"></p><p>点击查看，新建API密钥<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222137388.png"></p><p>点击新建密钥，密钥就会出现在下方<br>复制APPID、Secretid、SecretKey输入到刚才关联API密钥界面即可<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222138035.png"></p><p>此处选择急速安装与编译安装都可以，之后点击一键安装<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222138624.png"></p><p>接下来等待安装完成就行<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222138905.png"></p><p>安装完成后，在软件商店搜索wordpress，如下<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222120098.png"><br>这里需要填写自己购买的域名，域名的购买可参考我的另一篇博客==（链接）==<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210231654333.png"></p><hr><p>——————————————分割线——————————————————<br>==注意：以下属于购买域名部分的不同处：==<br>在对域名进行解析时，需要将记录值添加为云服务器的公网IP<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210231654475.png"></p><p>云服务器的公网IP在这里获取：<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222146682.png"><br>——————————————分割线——————————————————–<br>填好域名后，<img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222148697.png"><br>进入wordpress安装界面（建议在这一步安装之前，先部署ssl证书，否则可能访问不了安装页面，如何获取ssl证书见下一步）<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222148503.png"><br>进入此页面，搜索ssl证书，点击进入<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222149111.png"><br>在“我的证书”里面进行购买（免费）<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222150531.png"><br>选择如下<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222150546.png"><br>填写信息<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222152165.png"><br>根据给出得主机记录、记录类型、记录值添加域名解析记录==（见我的另一篇关于域名购买的博客）==<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222152866.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222152753.png"><br>之后验证域名<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222154908.png"><br>验证通过之后在“我的证书”里面下载<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222155303.png"><br>请根据服务器类型选择证书下载:<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222155468.png"><br>下载解压打开，有如下文件<br><img src="/!%5B%5D(https:/cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/20221022215719.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/20221022215719.png"><br>进入宝塔面板如下页面：<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222156120.png"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222157240.png"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222158087.png"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222158808.png"></p><p>完成之后在此进入Wordpress安装界面，点击安装<img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222159505.png"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222159244.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222159535.png"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222159668.png"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222200184.png"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222200978.png"><br>WordPress安装完成，接下来更改相关设置<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222200401.png"></p><p>进入如下页面<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222201542.png"></p><p>选择好之后回到宝塔页面<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222202188.png"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222202515.png"><br>再回到wordpress<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222202459.png"><br>设置更新完成<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/~2$6O0@%7DQLSFCET5H3L3Z5M.png"></p><p>至此，WordPress安装全部完成，可以通过自己购买的域名访问WordPress<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210222203746.png"></p><p>备注：网站需要备案才能访问<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210231859668.png"></p>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WordPress </tag>
            
            <tag> 安装教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lightroom后期（一）图片管理方法</title>
      <link href="/2022/10/21/lightroom-hou-qi-yi-tu-pian-guan-li-fang-fa/"/>
      <url>/2022/10/21/lightroom-hou-qi-yi-tu-pian-guan-li-fang-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="一-文件管理体系"><a href="#一-文件管理体系" class="headerlink" title="(一)文件管理体系"></a>(一)文件管理体系</h2><ol><li>使用<font color="#7030a0">摄影日期</font>(或加上<font color="rgb(227, 108, 9)">地名</font>)命名文件夹</li><li>按照文件格式分类分别保存JEPG、RAW、视频文件</li><li>新建加水印图片的文件夹，保存缩小尺寸、添加水印的照片，用于网络分享</li></ol><h2 id="二-lightroom导入照片的方式"><a href="#二-lightroom导入照片的方式" class="headerlink" title="(二)lightroom导入照片的方式"></a>(二)lightroom导入照片的方式</h2><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210211231869.png" width="45%" height="45%"></div><font color="#fac08f">复制</font>：将照片复制到新位置并添加到目录<font color="#00b0f0">移动</font>：将照片移到新位置并添加到目录<font color="#b2a2c7">添加</font>：将照片添加到目录而不移动<h2 id="三-筛选和照片分类"><a href="#三-筛选和照片分类" class="headerlink" title="(三)筛选和照片分类"></a>(三)筛选和照片分类</h2><p><strong>可以对照片进行旗标、评定星级和添加颜色标签，以及添加人脸标签来进行标记和分类</strong></p><h3 id="1-添加旗帜"><a href="#1-添加旗帜" class="headerlink" title="1. 添加旗帜"></a>1. 添加旗帜</h3><p>可以把想要保留的照片添加旗标</p><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210211245144.png" width="80%" height="80%"></div>在过滤器中选择留用即可在当前窗口只保留被标记旗子的照片<div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210211246948.png" width="100%" height="100%"></div>### 2. 设置星级<div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210211248403.png " width="80%" height="80%"></div>### 3. 颜色标签可以对照片的类型做一个区分，区分日落、夜景等等<div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210211250975.png" width="80%" height="80%"></div>### 4. 人脸标签通过一张照片上的人脸识别，可以让Lightroom自动搜索所有的照片，并且添加人物标签。<h2 id="四-添加导出预设"><a href="#四-添加导出预设" class="headerlink" title="(四)添加导出预设"></a>(四)添加导出预设</h2><p>建议建一个原尺寸JPEG导出预设，其他根据需要添加自定义导出预设</p><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210211300675.png" width="100%" height="100%"></div>如果照片导出后预览颜色奇怪，或者在其他设备上看到的颜色和原片不—样，多半是这个色彩空间没有选择sRGB的原因<h2 id="五-添加水印"><a href="#五-添加水印" class="headerlink" title="(五)添加水印"></a>(五)添加水印</h2><p>可添加<font color="#ffc000">文字</font>/<font color="#00b0f0">图片</font>水印，导出时勾选即可</p><div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210211303104.png " width="100%" height="100%"></div><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p><a href="https://www.bilibili.com/video/BV1uv411v7Qe/">【Edi x TourBox后期训练营】如何管理和批量处理旅行照片 - 完整的图片数据整理方案_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> 摄影后期 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lightroom </tag>
            
            <tag> 后期思路 </tag>
            
            <tag> 图片管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SystemVerilog学习笔记(七)</title>
      <link href="/2022/10/20/systemverilog-xue-xi-bi-ji-qi/"/>
      <url>/2022/10/20/systemverilog-xue-xi-bi-ji-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="1-类的继承"><a href="#1-类的继承" class="headerlink" title="1. 类的继承"></a>1. 类的继承</h1><h2 id="1-1-实例1-子类没有定义new函数，会调用父类new函数"><a href="#1-1-实例1-子类没有定义new函数，会调用父类new函数" class="headerlink" title="1.1 实例1 子类没有定义new函数，会调用父类new函数"></a>1.1 实例1 子类没有定义new函数，会调用父类new函数</h2><div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210202009690.png " width="50%" height="60%"></div>**仿真结果**：&gt;p.i = 2;&gt;lp.i = 2;<h2 id="1-2-实例2"><a href="#1-2-实例2" class="headerlink" title="1.2 实例2"></a>1.2 实例2</h2><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210202022227.png" width="50%" height="60%"></div>**仿真结果**：&gt;lp.i = 3;<div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210202023256.png " width="50%" height="50%"></div>## 1.3 实例3 如果子类定义function new，仍会默认调用父类的new函数<div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210202056452.png" width="60%" height="60%"></div>**仿真结果**：&gt;p.i = 2;&gt;lp.i = 2;<h2 id="1-4-实例4"><a href="#1-4-实例4" class="headerlink" title="1.4 实例4"></a>1.4 实例4</h2><div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210202121976.png " width="100%" height="100%"></div>子类和父类出现同名函数function，如果子类没有使用supper.(functionname)，不会调用父类的此函数。如果子类里使用supper.(functionname)，即调用父类的此函数。## 1.5 实例5<div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/20221020213918.png " width="100%" height="100%"></div><ol><li>子类带参数，父类不带参数，仍会调用父类new函数。</li><li>只要父类new没有参数，就可以默认调用</li><li>子类必须调动父类的new函数，否则编译无法通过。</li><li>如果父类new函数没有参数，直接调用；如果父类new函数有参数，子类里面需要严格用supper.new</li></ol><h2 id="1-6-实例6"><a href="#1-6-实例6" class="headerlink" title="1.6 实例6"></a>1.6 实例6</h2><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210202329703.png" width="55%" height="60%"></div><p><strong>仿真结果</strong></p><blockquote><p>p.i = 2;<br>lp.i = 2;<br>after shift p.i = 8;<br>after shift lp.i = 12;</p></blockquote><p><strong>设置断点分析</strong>：</p><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210202349849.png" width="100%" height="100%"></div>**注意**：1. 子类和父类出现同名的函数或者同名的函数或者任务（同名方法），子类想要继承，需要方法名一致参数一致，调用一定写supper2. 子类的方法名称可以与父类同名，但子类的变量最好不要跟父类的变量同名<h2 id="1-7-实例7-子类的句柄能够赋值给父类的句柄，父类的句柄不能赋值给子类的句柄"><a href="#1-7-实例7-子类的句柄能够赋值给父类的句柄，父类的句柄不能赋值给子类的句柄" class="headerlink" title="1.7 实例7 子类的句柄能够赋值给父类的句柄，父类的句柄不能赋值给子类的句柄"></a>1.7 实例7 子类的句柄能够赋值给父类的句柄，父类的句柄不能赋值给子类的句柄</h2><div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210212108619.png " width="60%" height="60%"></div><div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210212108436.png " width="60%" height="60%"></div><ol><li>子类的句柄能够赋值给父类的句柄（ ==能够访问区域缩小==），父类的句柄不能赋值给子类的句柄</li><li>lp.i只能指向子类中的i，无法指向父类的i（子类的变量跟父类的变量同名，i被覆盖）；tmp.i可以指向父类的i</li><li>lp能访问子类的i、k、m，无法访问父类的i；tmp能访问父类的i、m，但找不到子类的i、k</li></ol><h1 id="2-包的使用"><a href="#2-包的使用" class="headerlink" title="2. 包的使用"></a>2. 包的使用</h1><h2 id="2-1-包的概念"><a href="#2-1-包的概念" class="headerlink" title="2.1 包的概念"></a>2.1 包的概念</h2><p>为了使得可以在多个模块（硬件）或者奕（默件)间共子用厂化乂大型,SV添加了包(package) 。包的概念参考于VHDL，用户自定义的类型譬如==类、方法、变量、结构体、枚举类==（==偏软件类，Module、inteface偏硬件就不能定义在包里面==）等都可以在package…endpackage中定义。</p><h2 id="2-2-包的使用方法"><a href="#2-2-包的使用方法" class="headerlink" title="2.2 包的使用方法"></a>2.2 包的使用方法</h2><ol><li><p>module、interface、class等可以使用包中定义或者声明的内容。</p></li><li><p>导出：可以通过域的==索引符::号==直接引用。</p><div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210212212179.png " width="60%" height="60%"></div></li><li><p>可以==指定索引==一些需要的包中定义的类型到指定的容器中(module/class/…) 。</p><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210212213098.png" width="60%" height="60%"></div></li><li><p>通过通配符$*$来将包中==所有类别导入==到指定容器中。</p></li></ol><h2 id="2-3-实例1"><a href="#2-3-实例1" class="headerlink" title="2.3 实例1"></a>2.3 实例1</h2><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210212210008.png" width="50%" height="50%"></div><h1 id="3-问答题"><a href="#3-问答题" class="headerlink" title="3. 问答题"></a>3. 问答题</h1><p><strong>1.在packet和linkedpacket有关类的继承的例子中(如图)，tb中的句柄p是否可以访问父类的成员i?lp是否可以访问父类的成员i?句柄tmp是否可以访问子类的成员i?</strong></p><p><strong>代码：</strong></p><pre class=" language-systemverilog"><code class="language-systemverilog">/*Problem1在packet和linkedpacket有关类的继承的例子中(如图)，tb中的句柄p是否可以访问父类的成员i?lp是否可以访问父类的成员i?句柄tmp是否可以访问子类的成员i?*/class packet;    integer i = 1;    integer m = 2;    function new(int val);        i = val + 1;    endfunction    function shift();        i = i << 1;    endfunction    endclass    class linkedpacket extends packet;    integer i = 3;    integer k = 5;    function new (val);        super.new(val);        if (val >= 2)            i = val;    endfunction    function shift();        super.shift();        i = i << 2;    endfunctionendclassmodule tb;    initial begin        packet p = new(3);        linkedpacket lp = new(1);        packet tmp;        tmp = lp;        //tb中的句柄p是否可以访问父类的成员i?    $display("p.i = %0d",p.i);    //lp是否可以访问父类的成员i?     $display("lp.i = %0d",lp.i);//lp.i只能指向子类中的i，无法指向父类的i（子类的变量跟父类的变量同名，i被覆盖）    $display("lp.m = %0d",lp.m);//但lp可以访问父类的其他成员    //句柄tmp是否可以访问子类的成员i?    $display("tmp.i = %0d",tmp.i);    //$display("tmp.k = %0d",tmp.k); //ERROR：Could not find member 'k' in class 'packet', at "class_test.sv", 7.        endendmodule</code></pre><p><strong>仿真结果：</strong></p><blockquote><p>p.i = 4      tb中的句柄p是否可以访问父类的成员i<br>lp.i = 3     lp.i只能指向子类中的i，无法指向父类的i（子类的变量跟父类的变量同名，i被覆盖）<br>lp.m = 2  但lp可以访问父类的其他成员<br>tmp.i = 2  tmp能访问父类的i、m，但找不到子类的i、k</p></blockquote><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210221243924.png" width="60%" height="60%"></div><p><strong>2.试着在对应的位置填入代码，即如何导入pkg_a中的类型packet_a，从pkg_b中导入packet_b，以及从pkg_b中导入静态变量shared?</strong></p><p><strong>代码：</strong></p><pre class=" language-systemverilog"><code class="language-systemverilog">package pkt_a;    class packet_a;        int pkg_a;    endclass    typedef struct{        int data;        int command;        }struct_a;        int va = 1;        int shared = 10;endpackagepackage pkt_b;    class packet_b;        int pkg_b;    endclass    typedef struct{        int data;        int command;        }struct_b;        int vb = 2;        int shared = 20;endpackage                module tb;    class packet_tb;    endclass    typedef struct{        int data;        int command;    }struct_tb;        class packet_a;        int tb_a;    endclass    class packet_b;        int tb_b;    endclass    //how to import type from packages can be seen as follows    //精确导出    import pkt_a::va;    import pkt_b::vb;    //import pkt_a::shared;//从pkt_a取出shared    import pkg_b::shared;//从pkt_b取出shared        ////全部导出    //import pkt_a::*;    //import pkt_b::*;        initial begin         packet_a pa = new();        packet_b pb = new();        packet_tb ptb = new();        $display("pkg_a::va = %0d,pkg_b:: = %0d",va ,vb);        $display("shared = %0d", shared);        //$display("shared = %0d", pkt_b::shared);    end    endmodule</code></pre><p><strong>仿真结果：</strong></p><blockquote><p>pkg_a::va = 1,pkg_b:: = 2<br>shared = 20</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数字IC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SystemVerilog验证 </tag>
            
            <tag> 类(class) </tag>
            
            <tag> 包(package) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SystemVerilog学习笔记(六)</title>
      <link href="/2022/10/19/systemverilog-xue-xi-bi-ji-liu/"/>
      <url>/2022/10/19/systemverilog-xue-xi-bi-ji-liu/</url>
      
        <content type="html"><![CDATA[<p><strong>类</strong>是一种可以包含数据和方法(function,task)的类型。<br>例如一个数据包，可能被定义为一个类，类中可以包含指令、地址、队列ID、时间戳和数据等成员。</p><p>类的三要素：<strong>封装、继承、多态</strong></p><p><strong>OOP（面向对象编程）术语</strong><br><strong>类(class) :  包含成员变量和成员方法。<br>对象(object)</strong>:类在例化后的实例。<br><strong>句柄(handle)</strong> :指向对象的指针。<br><strong>原型(prototype)</strong> :程序的声明部分，包含程序名、返回类型和参数列表。</p><h1 id="1-类、模块、结构体比较"><a href="#1-类、模块、结构体比较" class="headerlink" title="1. 类、模块、结构体比较"></a>1. 类、模块、结构体比较</h1><div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210190953671.png " width="60%" height="60%"></div>c1、c2称为句柄（类似于c中的指针），句柄是否例化通过是否有new的动作判断。new是在仿真时让仿真器创建一个相应实例（如果没有定义new函数，系统也会自动添加一个function new）。调用new函数后，开辟空间存放存放变量。new函数没有返回值，无需表明返回值类型，甚至无需声明void。当创建了一个实际对象时，new函数的返回值为对象的头部句柄（指针）<div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210190954540.png" width="40%" height="40%"></div>仿真目的是仿真真实的硬件，没有run任何时间单位前，整个硬件的结构就确定下来了。在仿真前，模块是有值的，而对象的创建是在仿真以后才会执行：<div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210190955582.png " width="90%" height="90%"></div><div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210190955905.png " width="90%" height="90%"></div>仿真run 0(很小的时间单位)后：<div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210190956769.png " width="90%" height="90%"></div>同样地在进行仿真前，结构体也会有值（initial中的结构体静态变量同样如此），可进行如下验证：<div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210190957043.png " width="60%" height="60%"></div>在仿真开始前：<div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210190958060.png" width="90%" height="90%"></div><p>对new函数函数赋初值(new函数可以传参数)<br>对packet_c创建100个实例如下：</p><div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191046905.png " width="60%" height="60%"></div>**c1最终指向最后一个实例，前面99个实例无法找回。**<p><strong>总结：</strong></p><ol><li>SV并不像C++语言一样要求复杂的存储空间开辟和销毁的手段，而是采用了像Java—样空间自动开辟和回收的手段。</li><li>因此SV的类在定义时，只需要定义构建函数(constructor)而不需要定义析构函数(destructor) 。</li><li>类在定义时，需要定义构建函数，如果未定义，则系统会自动帮助定义一个空的构建函数（没有形式参数，函数体亦为空)。</li></ol><h1 id="2-句柄的拷贝"><a href="#2-句柄的拷贝" class="headerlink" title="2. 句柄的拷贝"></a>2. 句柄的拷贝</h1><div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191328440.jpg " width="60%" height="60%"></div><div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191335916.png " width="100%" height="100%"></div><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191335243.png" width="100%" height="100%"></div>两个句柄一个对象，几个new几个对象。（赋值的是句柄，不是对象!）<div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191336888.png " width="80%" height="80%"></div># 3. 静态变量&amp;动态变量**静态变量**：仿真开始前已经分配空间**动态变量**：仿真开始时才分配空间默认类里面所有成员(成员变量、成员方法或者其他)均是动态的，如果想要使用静态的，可用static<div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191341299.png" width="50%" height="50%"></div><div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191343949.png " width="100%" height="100%"></div><p>此时句柄悬空，能否找到data？</p><div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191424199.png " width="60%" height="60%"></div><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191424614.png" width="40%" height="40%"></div>编译器在编译时分析，句柄指向data是一个静态变量，仿真时data不会存放到任何实例化对象里面（c1.data、c2.data，任何一个data变量的存放空间不会在任何一个实例化的对象里面，如果存放在实例化对象里面，则空间各自独立。真正的空间在编译过程中开辟，可以姑且理解为放在类的下面）因此，编译器在编译时告诉我们说c1句柄指向的是packet这个类，data是一个静态变量。接下来仿真过程中找data时，不管c1有无指向对象，真正要找的变量放在类的域里面。<p><strong>总结：</strong></p><ol><li>类的成员(变量/方法)默认都是动态(automatic)生命周期，即每一个对象的变量和方法都会为其开辟新的空间。</li><li>如果多个对象为了共享一个成员(变量/方法)，那么可以为其添加关键字static。</li><li>多个对象因此可以共享同一个成员变量或者方法。</li><li>访问该成员时，无需进行对象的例化。</li><li>成员方法也可以声明为静态。</li><li>静态方法无法访问非静态成员(变量/方法)，否则会发生编译错误。</li></ol><h1 id="4-this"><a href="#4-this" class="headerlink" title="4. this"></a>4. this</h1><ol><li>this是用来明确索引当前所在对象的成员(变量/参数/方法。</li><li>this只可以用来在类的非静态成员、约束和覆盖组中使用。</li><li>this的使用可以明确所指向变量的作用域。</li></ol><pre class=" language-systemverilog"><code class="language-systemverilog">class Demo ;    integer x;    function new (integer x) ;        this.x =x;    endfunction    endclass</code></pre><p>this<br>赋值拷贝<br>链表</p><h1 id="5-浅拷贝与深拷贝"><a href="#5-浅拷贝与深拷贝" class="headerlink" title="5.浅拷贝与深拷贝"></a>5.浅拷贝与深拷贝</h1><p><strong>浅拷贝</strong>：只能拷贝成员里面的变量<br><strong>深拷贝</strong>：递进式拷贝，拷贝句柄及其指定对象。深拷贝与浅拷贝空间独立。</p><div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191548706.png " width="60%" height="60%"></div><h1 id="6-数据的隐藏和封装"><a href="#6-数据的隐藏和封装" class="headerlink" title="6. 数据的隐藏和封装"></a>6. 数据的隐藏和封装</h1><ol><li>类的成员(变量/方法)默认情况下，即是公共属性的。这表示对于类自身和外部均可以访问该成员。</li><li>对于成员的限定，如果使用local，则只有该类可以访问此成员，而子类或者外部均无法访问。</li><li>对于成员的限定，如果使用protected，则表示该类和其子类均可以访问此成员，而外部无法访问。</li></ol><pre class=" language-systemverilog"><code class="language-systemverilog">class Packet;    local integer i ;    function integer compare (Packet other) ;        compare = (this.i =other.i) ;    endfunctionendclass</code></pre><ol start="4"><li>对于商业开发，类的提供方会限制一些类成员的外部访问权限，继而隐藏类成员的更多细节。这种方式也使得类的外部访问接口更为精简，减轻了类的维护工作量，也使得类在修改时便于与旧版本保持兼容。数据隐藏的方式使得类的测试和维护都变得更为简单。</li></ol><h1 id="7-问答题"><a href="#7-问答题" class="headerlink" title="7. 问答题"></a>7. 问答题</h1><p><strong>1.类和结构体的联系和差别有哪些?类和模块(module)的联系和差别有哪些?</strong><br>    <strong>类与结构体:</strong><br>    同：都可以包含指令、地址、队列ID、时间戳和数据等成员。<br>    异：(1)类需要调用new函数进行例化，才会开辟空间存放存放变量。而结构体在仿真前就开辟空间存放变量；(2)类可以包含数据和方法(function,task)的类型。<br>    <strong>类与模块：</strong><br>    同：都可以包含数据和方法(function,task)的类型。<br>    异：(1)类中的成员变量和方法默认是动态的，而模块默认是静态的；(2)在仿真前，模块是有值的，而类中对象的创建是在仿真以后才会执行</p><p><strong>3.如果有同名的模块，那么在编译过程中应该怎么解决“同名”问题?</strong><br>    可以用 this来明确索引当前所在对象的成员(变量/参数)方法。this只可以用来在类的非静态成员、约束和覆盖组中使用。</p><pre class=" language-systemverilog"><code class="language-systemverilog">class Demo ;    integer x;    function new (integer x) ;        this.x =x;    endfunction    endclass</code></pre><p>可参考：<a href="https://zhuanlan.zhihu.com/p/480524030">结构体、模块和类的联系和区别？ 类的学习小结 - 知乎 (zhihu.com)</a></p><div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191616982.png " width="60%" height="60%"></div>]]></content>
      
      
      <categories>
          
          <category> 数字IC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字前端 </tag>
            
            <tag> SystemVerilog验证 </tag>
            
            <tag> 类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拍摄技巧(一)_日转夜延时</title>
      <link href="/2022/10/19/pai-she-ji-qiao-yi-ri-zhuan-ye-yan-shi/"/>
      <url>/2022/10/19/pai-she-ji-qiao-yi-ri-zhuan-ye-yan-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="（一）拍摄计划"><a href="#（一）拍摄计划" class="headerlink" title="（一）拍摄计划"></a>（一）拍摄计划</h1><p>制定拍摄计划，日落前2个小时到达拍摄点。</p><h1 id="（二）器材准备"><a href="#（二）器材准备" class="headerlink" title="（二）器材准备"></a>（二）器材准备</h1><p>相机、三脚架、清洁工具、快门线、CPL偏振镜、GND渐变镜</p><h1 id="（三）相机设置"><a href="#（三）相机设置" class="headerlink" title="（三）相机设置"></a>（三）相机设置</h1><p><strong>手动对焦</strong><br><strong>手动曝光</strong>（或者光圈优先）<br><strong>白平衡手动</strong><br>使每一张照片视觉上看上去都是同一色彩，不会出现前期太蓝、后期太黄<br><strong>CPL偏振镜</strong><br>增强水面反光和天空细节 </p><div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191237680.png " width="100%" height="100%"></div>**GND渐变滤镜**减光，压暗天空，提高水面曝光<div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210191238230.png" width="100%" height="100%"></div>**间隔时间的计算**根据延时视频帧率、时长计算拍摄张数，再根据拍摄时间计算间隔时间<h1 id="（四）注意事项"><a href="#（四）注意事项" class="headerlink" title="（四）注意事项"></a>（四）注意事项</h1><p><strong>时刻关注相机曝光</strong><br>曝光不足可降低快门速度(不要在相机即将拍摄的时候调整，尽量避免相机滑动)<br><strong>关闭机身防抖</strong><br>相机主动调增画面造成影响<br><strong>蓝调阶段曝光变化快</strong><br>当光线下降过快，当前光圈、快门、ISO下，可提高ISO代替调整快门速度，防止降低快门速度，快门速度接近间隔拍摄时间时。<br>进入夜景阶段，曝光过长，可提高间隔时间。</p><p><a href="https://www.bilibili.com/video/BV16K4y1h7eq/?spm_id_from=333.788.recommend_more_video.1">我拍到了天空的七种颜色，从日落到夜景，日转夜延时摄影全程记录，沉浸在美景中无法自拔_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> 摄影后期 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拍摄技巧 </tag>
            
            <tag> 日转夜延时 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SystemVerilog课程笔记(五)</title>
      <link href="/2022/10/17/systemverilog-ke-cheng-bi-ji-wu/"/>
      <url>/2022/10/17/systemverilog-ke-cheng-bi-ji-wu/</url>
      
        <content type="html"><![CDATA[<h1 id="1-构建generator"><a href="#1-构建generator" class="headerlink" title="1. 构建generator"></a>1. 构建generator</h1><p>stimulator只发送数据，构建generator产生数据发送给stimulator<br>数组与队列用法见[[SystemVerilog学习笔记(五)]]</p><h2 id="1-1改造"><a href="#1-1改造" class="headerlink" title="1.1改造"></a>1.1改造</h2><p>定义<span style="background:#fff88f">put_pkt</span>函数，将结构体p放入队列pkts里面</p><blockquote><p>function void put_pkt(input rt_packet_t p);<br>pkts.push_back(p);<br>endfunction</p></blockquote><p>定义<span style="background:#fff88f">get_pkt</span>任务，将p从队列pkts里面取出</p><blockquote><p>task get_pkt(output rt_packet_t p);<br>    wait(pkts.size() &gt;0 )//队列不为空<br>      p = pkts.pop_front();<br>  endtask</p></blockquote><p>数据发送过程</p><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211051352379.png" width="60%" height="60%"></div>## 1.2改造后的tb.sv```systemverilogtypedef struct{  bit [3:0] src;  bit [3:0] dst;  bit [7:0] data [];}rt_packet_t;//定义结构体，结构体成员为发送端口，目标端口，发送数据<p>//********************************** stimulator **********************************//<br>module rt_stimulator(<br>  input clock<br>  ,input reset_n<br>  ,output logic [15:0] din<br>  ,output logic [15:0] frame_n<br>  ,output logic [15:0] valid_n<br>  ,input [15:0] dout<br>  ,input [15:0] valido_n<br>  ,input [15:0] busy_n<br>  ,input [15:0] frameo_n<br>);<br>//for debug purpose from waveform//定义检测状态的变量<br>  typedef enum {DRV_RESET,DRV_IDLE,DRV_ADDR,DRV_PAD,DRV_DATA} drv_state_t;<br>  drv_state_t dbg_state;<br>  byte unsigned dbg_din_chnl0_data; </p><p>//receive p from generator<br>  rt_packet_t pkts[$];//定义stimulator中的的队列okts<br>  function void put_pkt(input rt_packet_t p);<br>    pkts.push_back(p);//将generator中传过来的p放入stimulator的pkts中(在pkts队列尾插入p)<br>  endfunction</p><p>//reset阶段，复位时，reset_n为低电平,frame_n和valid_n为高电平<br>initial begin : drive_reset_proc<br>  drive_reset();<br>end</p><p>task drive_reset();<br>  @(negedge reset_n);<br>  dbg_state &lt;= DRV_RESET;<br>  din &lt;= 0;<br>  frame_n &lt;= ‘1;//等效16’hFFFF<br>  valid_n &lt;= ‘1;<br>endtask</p><p>// drive chaannel 0 - chanel 15 (din[15:0])定义数据输出地址及数据<br>bit [3:0] daddr;<br>byte unsigned data[];</p><p>initial begin : drive_chnl0_proc<br>    rt_packet_t p;<br>  @(negedge reset_n);<br>  repeat(10) @(posedge clock);//延迟10个时钟周期<br>  forever begin<br>    wait(pkts.size()&gt;0);<br>    p = pkts.pop_front();//将p从队列pkts里面取出<br>    drive_chnl(p.src,p.dst,p.data);//从P中拿到发送端口，目标端口，发送数据<br>    end<br>    //drive_chnl(0,3,’{8’h33,8’h77});//name mapping<br>    //drive_chnl(0,5,’{8’h55,8’h66});//name mapping<br>end<br>initial begin : drive_chnl3_proc<br>  @(negedge reset_n);<br>  repeat(10) @(posedge clock);//延迟10个时钟周期<br>    drive_chnl(3,6,’{8’h77,8’h88,8’h22});//name mapping<br>end</p><p>task automatic drive_chnl(bit[3:0] saddr, bit [3:0] daddr, byte unsigned data[]);<br>  $display(“[DRV]src_chnl[%0d],dest_chnl[%0d] data trans started”,saddr,daddr);<br>    // drive address phase 输入地址位阶段<br>for(int i=0;i&lt;4;i++)begin  //4 clock<br>  @(posedge clock);<br>  dbg_state &lt;=DRV_ADDR;<br>  din[saddr] &lt;= daddr[i];<br>  valid_n[saddr] &lt;= $urandom_range(0,1);//valid_n在din的地址输入时间段可为任意值x<br>  frame_n[saddr] &lt;= 1’b0;//frame_n需要为低<br>end<br>    // drive pad phase //隔离阶段<br>  for (int i=0;i&lt;5;i++)begin  //5 clock<br>    @(posedge clock);<br>    dbg_state &lt;=DRV_PAD;<br>    din[saddr] &lt;= 1’b1;<br>    valid_n[saddr] &lt;= 1’b1;//valid_n需为高电平<br>    frame_n[saddr] &lt;= 1’b0; //frame_n需为低电平<br>  end<br>    // drive data phase 传输数据阶段<br>  foreach(data[id])begin<br>    for(int i=0;i&lt;8;i++)begin<br>     @(posedge clock);<br>      dbg_state &lt;=DRV_DATA;<br>      dbg_din_chnl0_data &lt;= data[id];<br>      din[saddr] &lt;= data[id][i];<br>      valid_n[saddr] &lt;=1’b0;<br>      frame_n[saddr] &lt;= (id == data.size()-1 &amp;&amp; i == 7) ? 1’b1 : 1’b0;//packet最后一位输出数据时frameo_n为高<br>    end<br>  end<br>// drive idle phase 闲置（没有数据传输）阶段<br>  @(posedge clock);<br>  dbg_state &lt;=DRV_IDLE;<br>  dbg_din_chnl0_data &lt;= 0;<br>  din[saddr] &lt;= 1’b0;<br>  valid_n[saddr] &lt;= 1’b1;<br>  frame_n[saddr] &lt;= 1’b1;<br>  $display(“[DRV]src_chnl[%0d],dest_chnl[%0d] data trans finished”,saddr,daddr);<br>endtask<br>endmodule</p><p>//********************************** generator **********************************//<br>module rt_generator;//generator产生数据交给stimulator<br>  rt_packet_t pkts[$];//定义队列</p><p>  function void put_pkt(input rt_packet_t p);<br>    pkts.push_back(p);//将p放入队列pkts里面（在pkts队列尾插入p）<br>  endfunction</p><p>  task get_pkt(output rt_packet_t p);<br>    wait(pkts.size() &gt;0 )//队列不为空<br>      p = pkts.pop_front();//将p从队列pkts里面取出，提取队列首元素<br>  endtask</p><p>  //generate a random packet<br>  function void gen_pkt(int src = -1, int dst = -1);<br>  endfunction<br>endmodule</p><p>//********************************** tb **********************************//<br>module tb;</p><p>bit clk,rstn;<br>logic [15:0] din, frame_n, valid_n;<br>logic [15:0] dout, valido_n, busy_n, frameo_n;</p><p>// 产生时钟，周期为10ns<br>initial<br>    forever #5ns clk &lt;= !clk;</p><p>// 产生复位信号<br>  initial begin<br>    #2ns rstn &lt;= 1;<br>    #10ns rstn &lt;= 0;<br>    #10ns rstn &lt;= 1;<br>  end</p><p>//例化router为DUT<br>router dut(<br>  .reset_n(rstn),<br>  .clock(clk),<br>  .*  //其余端口名称均相同<br>);</p><p>//例化stimulator<br>rt_stimulator stim(<br>  .reset_n(rstn),<br>  .clock(clk),<br>  .*<br>);</p><p>//例化generator<br>rt_generator gen();</p><p>initial begin:generate_data_proc//产生数据<br>    rt_packet_t p;<br>    p =  ‘{0,3,’{8’h33,8’h77}};<br>    gen.put_pkt(p);//调用genarator里面的put_pkt函数<br>    gen.put_pkt(‘{0,5,’{8’h55,8’h66}});<br>end<br>initial begin:genarator_to_stimulator_proc//取出genarator中的数据给stimulator<br>    rt_packet_t p;<br>    forever begin<br>        gen.get_pkt(p);<br>        stim.put_pkt(p);<br>    end<br>end</p><p>endmodule                      </p><pre><code>## 1.3仿真结果同前面一样&lt;div align=center&gt;&lt;img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211051044480.png" width="100%" height="100%"&gt;&lt;/div&gt;## 1.4问题但是如果生成数据采用如下方式，不同source_chnl不能同时发送数据（&lt;span style="background:rgba(240, 200, 0, 0.2)"&gt;上一节是因为采用了两个initial begin end语句块才能并行发送&lt;/span&gt;）&gt;gen.put_pkt('{0,3,'{8'h33,8'h77}});&gt;gen.put_pkt('{0,5,'{8'h55,8'h66}});&gt;gen.put_pkt('{3,6,'{8'h77,8'h88,8'h22}});&gt;//source_chnl0和source_chnl3不能同时发送仿真结果如下&lt;div align=center&gt;&lt;img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211051554321.png " width="100%" height="100%"&gt;&lt;/div&gt;# 2. 来自于不同的source chnl可以并行发送## 2.1改造**增加要求**：如果两个chnl没有冲突，可以同时发送**具体为：**来自于不同的source chnl就可以并行发送source chnl、destination chnl不一样可以并行发送**方法：*** **定义关联数组**int src_chnl_status[int];  //关联数组* **定义判断src_chnl是否空闲的任务**task判断src chnl是否被占用，是否需要等待。src_chnl_status关联数组里面不含p.src，(表示未占用任何dest_chnl,一开始不满足）。反之，如果含有，表示当前正在使用src_chnl,对应dest_chnl就是p.dst（p.src端口在向p.dst端口发送数据）。如果在给0,1,2...dest_chnl发送数据（被占用），需要等待,，否则不需要等待。直到src_chnl_status[p.src] == -1(自定义的dest_chnl端口数之外任意的数，表示未占用任何dest_chnl)&gt;task automatic wait_src_chnl_avail(rt_packet_t p);    if(!src_chnl_status.exists(p.src))//src_chnl_status关联数组里面不含p.src，(表示未占用任何dest_chnl,一开始不满足）        src_chnl_status[p.src] = p.dst;//表示当前正在使用src_chnl,对应dest_chnl就是p.dst（p.src端口在向p.dst端口发送数据）    else if(src_chnl_status[p.src] &gt;= 0)//如果在给0,1,2...dest_chnl发送数据（被占用），需要等待,，否则不需要等待        wait(src_chnl_status[p.src] == -1);//直到src_chnl_status[p.src] == -1(自定义的dest_chnl端口数之外任意的数，表示未占用任何dest_chnl)endtask* **采用fork join none后台线程，判断src chnl是否被占用，是否需要等待**&gt;fork//后台触发线程，触发线程在后台运行，继续执行剩下内容        begin            wait_src_chnl_avail(p);//判断src chnl是否被占用，是否需要等待            drive_chnl(p.src, p.dst, p.data);//从P中拿到发送端口，目标端口，发送数据            set_src_chnl_avail(p);        end    join_none* 然后把src_chnl置位&gt;function automatic set_src_chnl_avail(rt_packet_t p);    src_chnl_status[p.src] = -1;//如果chnl发送完后，把src_chnl置回来(自定义的dest_chnl端口数之外任意的数，表示未占用任何dest_chnl)endfunction## 2.2改造后的tb.sv```systemverilogtypedef struct{  bit [3:0] src;  bit [3:0] dst;  bit [7:0] data [];}rt_packet_t;//定义结构体，结构体成员为发送端口，目标端口，发送数据//********************************** stimulator **********************************//module rt_stimulator(  input clock  ,input reset_n  ,output logic [15:0] din  ,output logic [15:0] frame_n  ,output logic [15:0] valid_n  ,input [15:0] dout  ,input [15:0] valido_n  ,input [15:0] busy_n  ,input [15:0] frameo_n);//for debug purpose from waveform//定义检测状态的变量  typedef enum {DRV_RESET,DRV_IDLE,DRV_ADDR,DRV_PAD,DRV_DATA} drv_state_t;  drv_state_t dbg_state;    byte unsigned dbg_din_chnl0_data;     int src_chnl_status[int];  //关联数组，后面int：src_chnl的number；前面int：dest_chnl的Number ？？    //receive p from generator  rt_packet_t pkts[$];//定义stimulator中的的队列okts  function void put_pkt(input rt_packet_t p);    pkts.push_back(p);//将generator中传过来的p放入stimulator的pkts中(在pkts队列尾插入p)  endfunction//reset阶段，复位时，reset_n为低电平,frame_n和valid_n为高电平initial begin : drive_reset_proc   drive_reset();endtask drive_reset();  @(negedge reset_n);  dbg_state &lt;= DRV_RESET;  din &lt;= 0;  frame_n &lt;= '1;//等效16'hFFFF  valid_n &lt;= '1;endtask// 发送数据bit [3:0] daddr;byte unsigned data[];initial begin : drive_chnl_proc    //rt_packet_t p;  @(negedge reset_n);  repeat(10) @(posedge clock);//延迟10个时钟周期  forever begin    automatic rt_packet_t p;//声明一个动态的    wait(pkts.size()&gt;0);    p = pkts.pop_front();//将p从队列pkts里面取出        fork//后台触发线程，触发线程在后台运行，继续执行剩下内容        begin            wait_src_chnl_avail(p);//判断src chnl是否被占用，是否需要等待            drive_chnl(p.src, p.dst, p.data);//从P中拿到发送端口，目标端口，发送数据            set_src_chnl_avail(p);        end    join_none        end    //drive_chnl(0,3,'{8'h33,8'h77});//name mapping    //drive_chnl(0,5,'{8'h55,8'h66});//name mappingendtask automatic wait_src_chnl_avail(rt_packet_t p);//判断src chnl是否被占用，是否需要等待    if(!src_chnl_status.exists(p.src))//src_chnl_status关联数组里面不含p.src，(表示未占用任何dest_chnl,一开始不满足）        src_chnl_status[p.src] = p.dst;//表示当前正在使用src_chnl,对应dest_chnl就是p.dst（p.src端口在向p.dst端口发送数据）    else if(src_chnl_status[p.src] &gt;= 0)//如果在给0,1,2...dest_chnl发送数据（被占用），需要等待,，否则不需要等待        wait(src_chnl_status[p.src] == -1);//直到src_chnl_status[p.src] == -1(自定义的dest_chnl端口数之外任意的数，表示未占用任何dest_chnl)endtaskfunction automatic set_src_chnl_avail(rt_packet_t p);    src_chnl_status[p.src] = -1;//如果chnl发送完后，把src_chnl置回来(自定义的dest_chnl端口数之外任意的数，表示未占用任何dest_chnl)endfunctiontask automatic drive_chnl(bit[3:0] saddr, bit [3:0] daddr, byte unsigned data[]);  $display("@%0t:[DRV]src_chnl[%0d],dest_chnl[%0d] data trans started",$time,saddr,daddr);    // drive address phase 输入地址位阶段for(int i=0;i&lt;4;i++)begin  //4 clock  @(posedge clock);  dbg_state &lt;=DRV_ADDR;  din[saddr] &lt;= daddr[i];  valid_n[saddr] &lt;= $urandom_range(0,1);//valid_n在din的地址输入时间段可为任意值x  frame_n[saddr] &lt;= 1'b0;//frame_n需要为低end    // drive pad phase //隔离阶段  for (int i=0;i&lt;5;i++)begin  //5 clock    @(posedge clock);    dbg_state &lt;=DRV_PAD;    din[saddr] &lt;= 1'b1;    valid_n[saddr] &lt;= 1'b1;//valid_n需为高电平    frame_n[saddr] &lt;= 1'b0; //frame_n需为低电平  end    // drive data phase 传输数据阶段  foreach(data[id])begin    for(int i=0;i&lt;8;i++)begin     @(posedge clock);      dbg_state &lt;=DRV_DATA;      dbg_din_chnl0_data &lt;= data[id];      din[saddr] &lt;= data[id][i];      valid_n[saddr] &lt;=1'b0;      frame_n[saddr] &lt;= (id == data.size()-1 &amp;&amp; i == 7) ? 1'b1 : 1'b0;//packet最后一位输出数据时frameo_n为高    end  end// drive idle phase 闲置（没有数据传输）阶段  @(posedge clock);  dbg_state &lt;=DRV_IDLE;  dbg_din_chnl0_data &lt;= 0;  din[saddr] &lt;= 1'b0;  valid_n[saddr] &lt;= 1'b1;  frame_n[saddr] &lt;= 1'b1;  $display("@%0t:[DRV]src_chnl[%0d],dest_chnl[%0d] data trans finished",$time,saddr,daddr);endtaskendmodule//********************************** generator **********************************//module rt_generator;//generator产生数据交给stimulator  rt_packet_t pkts[$];//定义队列  function void put_pkt(input rt_packet_t p);    pkts.push_back(p);//将p放入队列pkts里面（在pkts队列尾插入p）  endfunction    task get_pkt(output rt_packet_t p);    wait(pkts.size() &gt;0 )//队列不为空      p = pkts.pop_front();//将p从队列pkts里面取出，提取队列首元素  endtask  //generate a random packet  function void gen_pkt(int src = -1, int dst = -1);  endfunctionendmodule//********************************** tb **********************************//module tb;bit clk,rstn;logic [15:0] din, frame_n, valid_n;logic [15:0] dout, valido_n, busy_n, frameo_n;// 产生时钟，周期为10nsinitial     forever #5ns clk &lt;= !clk;// 产生复位信号  initial begin    #2ns rstn &lt;= 1;    #10ns rstn &lt;= 0;    #10ns rstn &lt;= 1;  end//例化router为DUTrouter dut(             .reset_n(rstn),  .clock(clk),  .*  //其余端口名称均相同);//例化stimulatorrt_stimulator stim(  .reset_n(rstn),  .clock(clk),  .*);//例化generatorrt_generator gen();initial begin:generate_data_proc//产生数据    rt_packet_t p;    gen.put_pkt('{0,3,'{8'h33,8'h77}});//调用genarator里面的put_pkt函数    gen.put_pkt('{0,5,'{8'h55,8'h66}});    gen.put_pkt('{3,6,'{8'h77,8'h88,8'h22}});    gen.put_pkt('{4,7,'{8'haa,8'hcc,8'h33}});endinitial begin:genarator_to_stimulator_proc//取出genarator中的数据给stimulator    rt_packet_t p;    forever begin        gen.get_pkt(p);        stim.put_pkt(p);    endendendmodule </code></pre><h2 id="2-3仿真结果"><a href="#2-3仿真结果" class="headerlink" title="2.3仿真结果"></a>2.3仿真结果</h2><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211051538925.png"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210201409514.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210201543806.png"></p><h1 id="3-增加接口-interface"><a href="#3-增加接口-interface" class="headerlink" title="3. 增加接口(interface)"></a>3. 增加接口(interface)</h1><p>interface用法见[[SystemVerilog学习笔记(三)]]</p><h2 id="3-1改进"><a href="#3-1改进" class="headerlink" title="3.1改进"></a>3.1改进</h2><p>增加接口模块</p><blockquote><p>interface rt_interface();<br>logic clock;<br>logic reset_n;<br>logic [15:0] din;<br>logic [15:0] frame_n;<br>logic [15:0] valid_n;<br>logic [15:0] dout;<br>logic [15:0] valido_n;<br>logic [15:0] busy_n;<br>logic [15:0] frameo_n;<br>endinterface</p></blockquote><h2 id="3-2改造后的tb-sv"><a href="#3-2改造后的tb-sv" class="headerlink" title="3.2改造后的tb.sv"></a>3.2改造后的tb.sv</h2><pre class=" language-systemverilog"><code class="language-systemverilog">typedef struct{  bit [3:0] src;  bit [3:0] dst;  bit [7:0] data [];}rt_packet_t;//定义结构体，结构体成员为发送端口，目标端口，发送数据interface rt_interface();    logic clock;    logic reset_n;    logic [15:0] din;    logic [15:0] frame_n;    logic [15:0] valid_n;    logic [15:0] dout;    logic [15:0] valido_n;    logic [15:0] busy_n;    logic [15:0] frameo_n;endinterface//********************************** stimulator **********************************//module rt_stimulator(rt_interface intf);//for debug purpose from waveform//定义检测状态的变量  typedef enum {DRV_RESET,DRV_IDLE,DRV_ADDR,DRV_PAD,DRV_DATA} drv_state_t;  drv_state_t dbg_state;    byte unsigned dbg_din_chnl0_data;     int src_chnl_status[int];  //关联数组，后面int：src_chnl的number；前面int：dest_chnl的Number ？？    //receive p from generator  rt_packet_t pkts[$];//定义stimulator中的的队列okts  function void put_pkt(input rt_packet_t p);    pkts.push_back(p);//将generator中传过来的p放入stimulator的pkts中(在pkts队列尾插入p)  endfunction//reset阶段，复位时，reset_n为低电平,frame_n和valid_n为高电平initial begin : drive_reset_proc   drive_reset();endtask drive_reset();  @(negedge intf.reset_n);  dbg_state <= DRV_RESET;  intf.din <= 0;  intf.frame_n <= '1;//等效16'hFFFF  intf.valid_n <= '1;endtask// 发送数据bit [3:0] daddr;byte unsigned data[];initial begin : drive_chnl_proc    //rt_packet_t p;  @(negedge intf.reset_n);  repeat(10) @(posedge intf.clock);//延迟10个时钟周期  forever begin    automatic rt_packet_t p;//声明一个动态的    wait(pkts.size()>0);    p = pkts.pop_front();//将p从队列pkts里面取出        fork//后台触发线程，触发线程在后台运行，继续执行剩下内容        begin            wait_src_chnl_avail(p);//判断src chnl是否被占用，是否需要等待            drive_chnl(p.src, p.dst, p.data);//从P中拿到发送端口，目标端口，发送数据            set_src_chnl_avail(p);        end    join_none        end    //drive_chnl(0,3,'{8'h33,8'h77});//name mapping    //drive_chnl(0,5,'{8'h55,8'h66});//name mappingendtask automatic wait_src_chnl_avail(rt_packet_t p);//判断src chnl是否被占用，是否需要等待    if(!src_chnl_status.exists(p.src))//src_chnl_status关联数组里面不含p.src，(表示未占用任何dest_chnl,一开始不满足）        src_chnl_status[p.src] = p.dst;//表示当前正在使用src_chnl,对应dest_chnl就是p.dst（p.src端口在向p.dst端口发送数据）    else if(src_chnl_status[p.src] >= 0)//如果在给0,1,2...dest_chnl发送数据（被占用），需要等待,，否则不需要等待        wait(src_chnl_status[p.src] == -1);//直到src_chnl_status[p.src] == -1(自定义的dest_chnl端口数之外任意的数，表示未占用任何dest_chnl)endtaskfunction automatic set_src_chnl_avail(rt_packet_t p);    src_chnl_status[p.src] = -1;//如果chnl发送完后，把src_chnl置回来(自定义的dest_chnl端口数之外任意的数，表示未占用任何dest_chnl)endfunctiontask automatic drive_chnl(bit[3:0] saddr, bit [3:0] daddr, byte unsigned data[]);  $display("@%0t:[DRV]src_chnl[%0d],dest_chnl[%0d] data trans started",$time,saddr,daddr);    // drive address phase 输入地址位阶段for(int i=0;i<4;i++)begin  //4 clock  @(posedge intf.clock);  dbg_state <=DRV_ADDR;  intf.din[saddr] <= daddr[i];  intf.valid_n[saddr] <= $urandom_range(0,1);//valid_n在din的地址输入时间段可为任意值x  intf.frame_n[saddr] <= 1'b0;//frame_n需要为低end    // drive pad phase //隔离阶段  for (int i=0;i<5;i++)begin  //5 clock    @(posedge intf.clock);    dbg_state <=DRV_PAD;    intf.din[saddr] <= 1'b1;    intf.valid_n[saddr] <= 1'b1;//valid_n需为高电平    intf.frame_n[saddr] <= 1'b0; //frame_n需为低电平  end    // drive data phase 传输数据阶段  foreach(data[id])begin    for(int i=0;i<8;i++)begin     @(posedge intf.clock);      dbg_state <=DRV_DATA;      dbg_din_chnl0_data <= data[id];      intf.din[saddr] <= data[id][i];      intf.valid_n[saddr] <=1'b0;      intf.frame_n[saddr] <= (id == data.size()-1 && i == 7) ? 1'b1 : 1'b0;//packet最后一位输出数据时frameo_n为高    end  end// drive idle phase 闲置（没有数据传输）阶段  @(posedge intf.clock);  dbg_state <=DRV_IDLE;  dbg_din_chnl0_data <= 0;  intf.din[saddr] <= 1'b0;  intf.valid_n[saddr] <= 1'b1;  intf.frame_n[saddr] <= 1'b1;  $display("@%0t:[DRV]src_chnl[%0d],dest_chnl[%0d] data trans finished",$time,saddr,daddr);endtaskendmodule//********************************** generator **********************************//module rt_generator;//generator产生数据交给stimulator  rt_packet_t pkts[$];//定义队列  function void put_pkt(input rt_packet_t p);    pkts.push_back(p);//将p放入队列pkts里面（在pkts队列尾插入p）  endfunction    task get_pkt(output rt_packet_t p);    wait(pkts.size() >0 )//队列不为空      p = pkts.pop_front();//将p从队列pkts里面取出，提取队列首元素  endtask  //generate a random packet  function void gen_pkt(int src = -1, int dst = -1);  endfunctionendmodule//********************************** tb **********************************//module tb;bit clk,rstn;logic [15:0] din, frame_n, valid_n;logic [15:0] dout, valido_n, busy_n, frameo_n;// 产生时钟，周期为10nsinitial     forever #5ns clk <= !clk;// 产生复位信号  initial begin    #2ns rstn <= 1;    #10ns rstn <= 0;    #10ns rstn <= 1;  end//例化router为DUTrouter dut(             .reset_n(rstn),  .clock(clk),  .frame_n(intf.frame_n),  .valid_n(intf.valid_n),  .dout(intf.dout),  .busy_n(intf.busy_n),  .valido_n(intf.valido_n),  .frameo_n(intf.frameo_n));rt_interface intf();//例化接口    assign intf.reset_n = rstn;    assign intf.clock = clk;    //例化stimulatorrt_stimulator stim(intf);//例化generatorrt_generator gen();    initial begin:generate_data_proc//产生数据    rt_packet_t p;    gen.put_pkt('{0,3,'{8'h33,8'h77}});//调用genarator里面的put_pkt函数    gen.put_pkt('{0,5,'{8'h55,8'h66}});    gen.put_pkt('{3,6,'{8'h77,8'h88,8'h22}});    gen.put_pkt('{4,7,'{8'haa,8'hcc,8'h33}});endinitial begin:genarator_to_stimulator_proc//取出genarator中的数据给stimulator    rt_packet_t p;    forever begin        gen.get_pkt(p);        stim.put_pkt(p);    endendendmodule </code></pre><h2 id="3-3仿真结果"><a href="#3-3仿真结果" class="headerlink" title="3.3仿真结果"></a>3.3仿真结果</h2><p>只增加了接口，仿真结果未变</p><div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211052013674.png " width="100%" height="100%"></div>硬件层次结构如下<div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211052014621.png" width="60%" height="60%"></div># 4. 初步TestBench概览<div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211052040259.png" width="80%" height="80%"></div><h1 id="5-增加monitor"><a href="#5-增加monitor" class="headerlink" title="5. 增加monitor"></a>5. 增加monitor</h1><h2 id="5-1-改造"><a href="#5-1-改造" class="headerlink" title="5.1 改造"></a>5.1 改造</h2><p>增加组件monitor，监测输入数据和输出数据<br>监测数据输入的task：</p><pre class=" language-systemverilog"><code class="language-systemverilog">task automatic mon_chnl_in (bit[3:0]id);//监测数据输入的任务    rt_packet_t pkt;//定义结构体变量    forever begin    //clear content for the same struct variable。清除pkt    pkt.data.delete();    pkt.src = id;//第id个输入端口    //monitor specific channel-in data and put it into the queue    // monitor address phase    @(negedge intf.frame_n[id]);//监测frame_n下降沿(frame_n由时钟驱动)    $display ("@%0t: [MON] src_chn1[%0d] & dest_chn1[%0d] data trans started",$time,pkt.src,pkt.dst);    for(int i=0; i<4; i++)begin        @(negedge intf.clock);//frame_n下降沿后监测4个clk negedge        pkt.dst[i]= intf.din[id];        end    //pass pad phase 不考虑pad阶段是否满足协议要求    repeat(5) @(negedge intf.clock);    do begin        pkt.data = new [pkt.data.size + 1](pkt.data);//创建动态数组并复制pkt.data        for ( int i=0; i<8; i++) begin            @(negedge intf.clock); //在8个clk negedge监测8bit数据            pkt.data[pkt.data.size-1][i] = intf.din[id];        end    end while(!intf.frame_n[id]);    in_pkts[id].push_back(pkt);//将monitor拿到的数据放入in_pkts    $display("@%0t: [MON] src_chn1[%0d] & dest_chn1[%0d] data trans [%0p] finished",$time,pkt.src,pkt.dst,pkt.data);    endendtask</code></pre><p>监测数据输入的task：</p><pre class=" language-systemverilog"><code class="language-systemverilog">task automatic mon_chnl_out(bit[ 3:0]id);//监测数据输出的任务    rt_packet_t pkt;    forever begin        //clear content for the same struct variable        pkt.data.delete();        pkt.src = 0;        pkt.dst = id;        @(negedge intf.frameo_n[id]);        $display( "@%0t: [MON] CH_OUT dest_chn1[%0d] data trans started",$time,pkt.dst);        do begin        pkt.data = new [ pkt.data.size + 1](pkt.data);        for(int i=0;i<8; i++) begin            @(negedge intf.clock iff !intf.valido_n[id]);//clock与valido_n信号同时为低            pkt.data[pkt.data.size-1][i]= intf.dout [id];        end    end while(!intf.frameo_n[id]);    out_pkts[id].push_back(pkt);    $display("@%0t: [MON] CH_OUT dest_chn1[%0d] data trans [%0p] finished",$time,pkt.dst,pkt.data);    //monitor specific channel-out data and put it into the queue    endendtask</code></pre><h2 id="5-2-改造后的tb-sv"><a href="#5-2-改造后的tb-sv" class="headerlink" title="5.2 改造后的tb.sv"></a>5.2 改造后的tb.sv</h2><pre class=" language-systemverilog"><code class="language-systemverilog">typedef struct{  bit [3:0] src;  bit [3:0] dst;  bit [7:0] data [];}rt_packet_t;//定义结构体，结构体成员为发送端口，目标端口，发送数据interface rt_interface();    logic clock;    logic reset_n;    logic [15:0] din;    logic [15:0] frame_n;    logic [15:0] valid_n;    logic [15:0] dout;    logic [15:0] valido_n;    logic [15:0] busy_n;    logic [15:0] frameo_n;endinterface//********************************** stimulator **********************************//module rt_stimulator(    rt_interface intf);//for debug purpose from waveform//定义检测状态的变量  typedef enum {DRV_RESET,DRV_IDLE,DRV_ADDR,DRV_PAD,DRV_DATA} drv_state_t;  drv_state_t dbg_state;    byte unsigned dbg_din_chnl0_data;   int src_chnl_status[int];  //关联数组，后面int：src_chnl的number；前面int：dest_chnl的Number ？？    //generator传送p给stimulator  rt_packet_t pkts[$];//定义stimulator中的的队列pkts  function void put_pkt(input rt_packet_t p);    pkts.push_back(p);//将generator中传过来的p放入stimulator的pkts中(在pkts队列尾插入p)  endfunction//reset阶段，复位时，reset_n为低电平,frame_n和valid_n为高电平initial begin : drive_reset_proc   drive_reset();endtask drive_reset();  @(negedge intf.reset_n);  dbg_state <= DRV_RESET;  intf.din <= 0;  intf.frame_n <= '1;//等效16'hFFFF  intf.valid_n <= '1;endtask// 发送数据initial begin : drive_chnl_proc    //rt_packet_t p;  @(negedge intf.reset_n);  repeat(10) @(posedge intf.clock);//延迟10个时钟周期  forever begin    automatic rt_packet_t p;//声明一个动态的    wait(pkts.size()>0);    p = pkts.pop_front();//将p从队列pkts里面取出    fork//后台触发线程，触发线程在后台运行，继续执行剩下内容        begin            wait_src_chnl_avail(p);//判断src chnl是否被占用，是否需要等待            drive_chnl(p.src, p.dst, p.data);//从P中拿到发送端口，目标端口，发送数据            set_src_chnl_avail(p);        end    join_none    endendtask automatic wait_src_chnl_avail(rt_packet_t p);//判断src chnl是否被占用，是否需要等待    if(!src_chnl_status.exists(p.src))//src_chnl_status关联数组里面不含p.src，(表示未占用任何dest_chnl,一开始不满足）        src_chnl_status[p.src] = p.dst;//表示当前正在使用src_chnl,对应dest_chnl就是p.dst（p.src端口在向p.dst端口发送数据）    else if(src_chnl_status[p.src] >= 0)//如果在给0,1,2...dest_chnl发送数据（被占用），需要等待,，否则不需要等待        wait(src_chnl_status[p.src] == -1);//直到src_chnl_status[p.src] == -1(自定义的dest_chnl端口数之外任意的数，表示未占用任何dest_chnl)endtaskfunction automatic set_src_chnl_avail(rt_packet_t p);    src_chnl_status[p.src] = -1;//如果chnl发送完后，把src_chnl置回来(自定义的dest_chnl端口数之外任意的数，表示未占用任何dest_chnl)endfunctiontask automatic drive_chnl(bit[3:0] saddr, bit [3:0] daddr, byte unsigned data[]);  $display("@%0t: [DRV]src_chnl[%0d],dest_chnl[%0d] data trans started",$time,saddr,daddr);    // drive address phase 输入地址位阶段for(int i=0;i<4;i++)begin  //4 clock  @(posedge intf.clock);  dbg_state <=DRV_ADDR;  intf.din[saddr] <= daddr[i];  intf.valid_n[saddr] <= $urandom_range(0,1);//valid_n在din的地址输入时间段可为任意值x  intf.frame_n[saddr] <= 1'b0;//frame_n需要为低end    // drive pad phase //隔离阶段  for (int i=0;i<5;i++)begin  //5 clock    @(posedge intf.clock);    dbg_state <=DRV_PAD;    intf.din[saddr] <= 1'b1;    intf.valid_n[saddr] <= 1'b1;//valid_n需为高电平    intf.frame_n[saddr] <= 1'b0; //frame_n需为低电平  end    // drive data phase 传输数据阶段  foreach(data[id])begin    for(int i=0;i<8;i++)begin     @(posedge intf.clock);      dbg_state <=DRV_DATA;      dbg_din_chnl0_data <= data[id];      intf.din[saddr] <= data[id][i];      intf.valid_n[saddr] <=1'b0;      intf.frame_n[saddr] <= (id == data.size()-1 && i == 7) ? 1'b1 : 1'b0;//packet最后一位输出数据时frameo_n为高    end  end// drive idle phase 闲置（没有数据传输）阶段  @(posedge intf.clock);  dbg_state <=DRV_IDLE;  dbg_din_chnl0_data <= 0;  intf.din[saddr] <= 1'b0;  intf.valid_n[saddr] <= 1'b1;  intf.frame_n[saddr] <= 1'b1;  $display("@%0t: [DRV]src_chnl[%0d],dest_chnl[%0d] data trans finished",$time,saddr,daddr);endtaskendmodule//********************************** generator **********************************//module rt_generator;//generator产生数据交给stimulator  rt_packet_t pkts[$];//定义队列  function void put_pkt(input rt_packet_t p);    pkts.push_back(p);//将p放入队列pkts里面（在pkts队列尾插入p）  endfunction    task get_pkt(output rt_packet_t p);    wait(pkts.size() >0 )//队列不为空      p = pkts.pop_front();//将p从队列pkts里面取出，提取队列首元素  endtask  //generate a random packet  function void gen_pkt(int src = -1, int dst = -1);  endfunctionendmodule//********************************** monitor **********************************//module rt_monitor(rt_interface intf);    rt_packet_t in_pkts[16][$];    rt_packet_t out_pkts[16][$];    initial begin : mon_chnl_proc        foreach(in_pkts[i]) begin            automatic int chid = i;            fork            mon_chnl_in(chid);//每个输入端口均调用mon_chnl_in任务，监测数据输入            mon_chnl_out(chid);//每个输出端口均调用mon_chnl_out任务，监测数据输入            join_none        end    end    task automatic mon_chnl_in (bit[3:0]id);//监测数据输入的任务    rt_packet_t pkt;//定义结构体变量    forever begin    //clear content for the same struct variable。清除pkt    pkt.data.delete();    pkt.src = id;//第id个输入端口    //monitor specific channel-in data and put it into the queue    // monitor address phase    @(negedge intf.frame_n[id]);//监测frame_n下降沿(frame_n由时钟驱动)        for(int i=0; i<4; i++)begin        @(negedge intf.clock);//frame_n下降沿后监测4个clk negedge        pkt.dst[i]= intf.din[id];        end  $display ("@%0t: [MON] src_chn1[%0d] & dest_chn1[%0d] data trans started",$time,pkt.src,pkt.dst);    //pass pad phase 不考虑pad阶段是否满足协议要求    repeat(5) @(negedge intf.clock);    do begin        pkt.data = new [pkt.data.size + 1](pkt.data);//创建动态数组并复制pkt.data        for ( int i=0; i<8; i++) begin            @(negedge intf.clock); //在8个clk negedge监测8bit数据            pkt.data[pkt.data.size-1][i] = intf.din[id];        end    end while(!intf.frame_n[id]);    in_pkts[id].push_back(pkt);//将monitor拿到的数据放入in_pkts    $display("@%0t: [MON] src_chn1[%0d] & dest_chn1[%0d] data trans [%0p] finished",$time,pkt.src,pkt.dst,pkt.data);    endendtasktask automatic mon_chnl_out(bit[ 3:0]id);//监测数据输出的任务    rt_packet_t pkt;    forever begin        //clear content for the same struct variable        pkt.data.delete();        pkt.src = 0;        pkt.dst = id;        @(negedge intf.frameo_n[id]);        $display( "@%0t: [MON] CH_OUT dest_chn1[%0d] data trans started",$time,pkt.dst);        do begin        pkt.data = new [ pkt.data.size + 1](pkt.data);        for(int i=0;i<8; i++) begin            @(negedge intf.clock iff !intf.valido_n[id]);//clock与valido_n信号同时为低            pkt.data[pkt.data.size-1][i]= intf.dout [id];        end    end while(!intf.frameo_n[id]);    out_pkts[id].push_back(pkt);    $display("@%0t: [MON] CH_OUT dest_chn1[%0d] data trans [%0p] finished",$time,pkt.dst,pkt.data);    //monitor specific channel-out data and put it into the queue    endendtaskendmodule//********************************** tb **********************************//module tb;bit clk,rstn;logic [15:0] din, frame_n, valid_n;logic [15:0] dout, valido_n, busy_n, frameo_n;// 产生时钟，周期为10nsinitial     forever #5ns clk <= !clk;// 产生复位信号  initial begin    #2ns rstn <= 1;    #10ns rstn <= 0;    #10ns rstn <= 1;  end//例化router为DUTrouter dut(             .reset_n(rstn),  .clock(clk),  .frame_n(intf.frame_n),  .valid_n(intf.valid_n),  .din(intf.din),  .dout(intf.dout),  .busy_n(intf.busy_n),  .valido_n(intf.valido_n),  .frameo_n(intf.frameo_n));rt_interface intf();//例化接口    assign intf.reset_n = rstn;    assign intf.clock = clk;    //例化stimulatorrt_stimulator stim(intf);//例化Monitorrt_monitor mon(intf);//例化generatorrt_generator gen();    initial begin:generate_data_proc//产生数据    rt_packet_t p;    gen.put_pkt('{0,3,'{8'h33,8'h77}});//调用genarator里面的put_pkt函数    gen.put_pkt('{0,5,'{8'h55,8'h66}});    gen.put_pkt('{3,6,'{8'h77,8'h88,8'h22}});    gen.put_pkt('{4,7,'{8'haa,8'hcc,8'h33}});endinitial begin:genarator_to_stimulator_proc//取出genarator中的数据给stimulator    rt_packet_t p;    forever begin        gen.get_pkt(p);        stim.put_pkt(p);    endendendmodule </code></pre><h2 id="5-3-仿真结果"><a href="#5-3-仿真结果" class="headerlink" title="5.3 仿真结果"></a>5.3 仿真结果</h2><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211161422827.png" width="50%" height="50%"></div><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211161639835.png" width="60%" height="60%"></div><h1 id="6-初步TestBench概览"><a href="#6-初步TestBench概览" class="headerlink" title="6. 初步TestBench概览"></a>6. 初步TestBench概览</h1><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211171916069.png" width="80%" height="80%"></div>]]></content>
      
      
      <categories>
          
          <category> 数字IC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字前端 </tag>
            
            <tag> SystemVerilog验证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建遇到的问题及解决方法</title>
      <link href="/2022/10/16/bo-ke-da-jian-yu-dao-de-wen-ti-ji-jie-jue-fang-fa/"/>
      <url>/2022/10/16/bo-ke-da-jian-yu-dao-de-wen-ti-ji-jie-jue-fang-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="一-域名解析-amp-自定义github-page托管的博客域名"><a href="#一-域名解析-amp-自定义github-page托管的博客域名" class="headerlink" title="(一)域名解析&amp;自定义github page托管的博客域名"></a>(一)域名解析&amp;自定义github page托管的博客域名</h1><p>首先购买一个域名，然后进行域名解析<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210211644329.png"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210211645561.png"><br>按照下图操作，博客地址的ip可通过如下方式获取：</p><ol><li>键盘快捷键win+r输入cmd回车</li><li>dos窗口后输入ping ==gokingGit==.github.io(==gokingGit==是注册github项目的名字，即你的用户名)<br>因为你刚才创建的项目已经被放到github服务器上面了，所以你这样相当于租用了github的服务器<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210211645052.png"></li></ol><p>再进入github仓库里面，右上方点击“Settings”，左下方找到“Pages”点击后，在“Custom&nbsp;domain”（自定义域名）下方文本栏中填写域名，勾选“Enforce&nbsp;HTTPS”（强制使用https协议），点击“Save”（保存），蓝色字体为博客发布的网址，点击查看，网址一般为“https://域名/”<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210211646001.png"></p><h1 id="二-自定义域名失效"><a href="#二-自定义域名失效" class="headerlink" title="(二)自定义域名失效"></a>(二)自定义域名失效</h1><p>==问题描述==<br>我们在执行“hexo&nbsp;d”，部署到git仓库时，发现之前设置的自定义域名失效，恢复为默认域名（仓库名），每次更新部署都需要重新设置。**<br>==解决方案==</p><ol><li>找到 hexo 博客根目录下的 source 文件夹。注意，不是主题的 source 文件夹。</li><li>新建一个文件，名为 CNAME ，内容为你的域名（不包括www.或http等等）。<br>==注意！==</li><li>名为 CNAME，全部大写，<strong>没有后缀</strong>。  </li><li>内容只包含一个域名，且<strong>不含 www. 或 http</strong> 等。  </li><li>放到根目录下的source文件夹中。<br>如图：<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210211533295.png"><br><a href="https://blog.csdn.net/weixin_41747528/article/details/102772937">解决 Hexo 部署 Github Pages 自定义域名失效的问题(即使已添加 CNAME）_桌子LZT的博客-CSDN博客</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 猎奇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>车规芯片(三）常用ECC算法简述</title>
      <link href="/2022/10/13/che-gui-xin-pian-san-chang-yong-ecc-suan-fa-jian-shu/"/>
      <url>/2022/10/13/che-gui-xin-pian-san-chang-yong-ecc-suan-fa-jian-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="ECC工作原理"><a href="#ECC工作原理" class="headerlink" title="ECC工作原理"></a>ECC工作原理</h1><p><a href="https://blog.csdn.net/qq_39560607/article/details/81714141?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166571376316782425174007%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166571376316782425174007&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-81714141-null-null.142%5Ev56%5Econtrol,201%5Ev3%5Econtrol_2&amp;utm_term=ecc%E7%BA%A0%E9%94%99&amp;spm=1018.2226.3001.4187">ECC检验与纠错_Christal_RJ的博客-CSDN博客</a><br>ECC有三种常用的算法，包括汉明码(hamming code)、RS码(Reed Solomon code)和BCH码。其中汉明码是FSMC模块的硬件ECC所采用的校验方式。</p><h1 id="ECC常见算法"><a href="#ECC常见算法" class="headerlink" title="ECC常见算法"></a>ECC常见算法</h1><h2 id="汉明码"><a href="#汉明码" class="headerlink" title="汉明码"></a>汉明码</h2><h3 id="以1-Byte的数据包为例"><a href="#以1-Byte的数据包为例" class="headerlink" title="以1 Byte的数据包为例"></a>以1 Byte的数据包为例</h3><p>为计算ECC值，数据包中的比特数据要先进行分割，如1/2组(Halfs)、1/4组(Fourths)、1/8(Bits)组等，直到其精度达到单个比特为止，以8 bit即1 Byte的数据包为例进行说明，</p>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210132031028.png" width="500" height="300" title="8比特Data汉明校验元计算">        每$2^n-1$比特数据计算得到n比特ECC值，而该汉明算法需要一对ECC值(偶校验值ECCe和奇校验值ECCo，如上图所示，^表示异或)，因此共需要2n比特。计算之后，原数据包和ECC数值被写入。稍后，原数据包读取出，此时ECC值将重新计算。如果新计算的ECC不同于先前编入的ECC，那么表明数据在读写过程中出错。```ad-exampletitle: 示例type=例：原始数据为01010101，计算并存入的ECC值是ECCe=000、ECCo=000。若其中有1个单一的比特出现错误，出错后的数据是01010001。计算新ECC值如下：            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210132129859.png" width="500" height="300">        ```<p><strong>检验是否发生错误</strong><br>通过计算Error进行判断：<br>    Error[2:0]=ECCe <strong>⊕</strong> ECCo <strong>⊕</strong> ECCe’ <strong>⊕</strong> ECCo’<br>Error=111表示发生一位错误，Error=000表示没有发生错误，而 Error不是上述两个值时，表示发生2位及以上错误，出现的可能性非常低。</p>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210132131177.png" width="100" height="150">        <p><strong>检测错误发生位置</strong><br>通过计算Error_Loc进行判断：<br>    Error_Loc[2:0]=ECCo<strong>⊕</strong>ECCo’ = 000<strong>⊕</strong>010 = 010<br>Error_Loc=010，表示Data的第二位（data[3]）发生错误，对应取反即可。<br>按照此思路，8比特Data汉明校验元生成电路如下图所示：</p>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210132142743.jpg" width="400" height="300" title="8比特Data汉明校验元生成电路">        <p>8比特Data汉明校验元生成电路由14个异或门组成</p><h3 id="以4-Byte的数据包为例"><a href="#以4-Byte的数据包为例" class="headerlink" title="以4 Byte的数据包为例"></a>以4 Byte的数据包为例</h3><p>将汉明校验的计算推广到4个字节作为一个分组块，现在字节和比特排列如下图所示：</p>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210140854286.png" width="500" height="200">        <p>现在计算偶校验值ECCe和奇校验值ECCo如下：</p>            <meta charset="utf-8">        <title>HTML</title>                        <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210140900859.jpg" width="510" height="100">        <p><strong>行校验码</strong>：<br>    行偶校验码：<br>        Byte-Even half = B1<strong>⊕</strong>B0<br>        Byte-Even bits  = B2<strong>⊕</strong>B0<br>    行奇校验码：<br>        Byte-Odd half = B3<strong>⊕</strong>B2<br>        Byte-Odd bits  = B3<strong>⊕</strong>B1<br>    其中，Bi = Di[7]<strong>⊕</strong>Di[6]<strong>⊕</strong>Di[5]<strong>⊕</strong>Di[4]<strong>⊕</strong>Di[3]<strong>⊕</strong>Di[2]<strong>⊕</strong>Di[1]<strong>⊕</strong>Di[0]</p><p><strong>列校验码</strong>：<br>    列偶校验码：<br>        Bit-Even half      = D[3]<strong>⊕</strong>D[2]<strong>⊕</strong>D[1]<strong>⊕</strong>D[0]<br>        Bit-Even fourth = D[5]<strong>⊕</strong>D[4]<strong>⊕</strong>D[1]<strong>⊕</strong>D[0]<br>        Bit-Even bits       = D[6]<strong>⊕</strong>D[4]<strong>⊕</strong>D[2]<strong>⊕</strong>D[0]<br>    列奇校验码：<br>        Bit-Odd half      = D[7]<strong>⊕</strong>D[6]<strong>⊕</strong>D[5]<strong>⊕</strong>D[4]<br>        Bit-Odd fourth = D[7]<strong>⊕</strong>D[6]<strong>⊕</strong>D[3]<strong>⊕</strong>D[2]<br>        Bit-Odd bits       = D[7]<strong>⊕</strong>D[5]<strong>⊕</strong>D[3]<strong>⊕</strong>D[1]<br>    其中，D[i]=D3[i]<strong>⊕</strong>D2[i]<strong>⊕</strong>D1[i]<strong>⊕</strong>DO[i]（每个字节对应位置都加入计算）<br>    <br>    <br>        <meta charset="utf-8"><br>        <title>HTML</title><br>    <br>        <br>            <img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210140916084.png" width="750" height="900"><br>        </p>![]()例：假设4个字节数据Byte3~Byte1分别是01010101,11001100,10001000,00100010，计算得到的ECCe=00000, ECCo=00000，若此时 Byte1发生错误变成10000000(第3位从1翻转成0)，计算得到新的ECCe=10100，ECCo'=01011，因此通过计算Error=11111，表示发生一位错误，计算Error_Loc=01011,表示该位错误发生在01字节即 Byte1的第011位即第3位<h2 id="BCH码"><a href="#BCH码" class="headerlink" title="BCH码"></a>BCH码</h2><p>BCH码是循环码中的一个重要子类，它具有纠正多个错误的能力,广泛应用于移动通信和卫星通信中。BCH码有着严密的代数结构，是目前研究得比较透彻的一种码。关于BCH码编码的原理详解可参考：<a href="https://zhuanlan.zhihu.com/p/95909150">【举例子详细分析】BCH码(BCH code)</a></p><h2 id="RS码"><a href="#RS码" class="headerlink" title="RS码"></a>RS码</h2><p>里德-所罗门(Reed-Solomon，RS）码是BCH码的一个重要分类，RS码是一种非二进制的BCH码，具有较强的纠错能力。</p><h2 id="LDPC码"><a href="#LDPC码" class="headerlink" title="LDPC码"></a>LDPC码</h2><p>LDPC码即低密度奇偶校验码（Low Density Parity Check Code，LDPC），它由Robert G.Gallager博士于1963年提出的一类具有稀疏校验矩阵的线性分组码，不仅有逼近Shannon限的良好性能，而且译码复杂度较低，结构灵活，是近年信道编码领域的研究热点。<br>&nbsp;&nbsp;LDPC码是一种分组码，其校验矩阵只含有很少量非零元素（稀疏矩阵）。&nbsp;&nbsp;</p><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p>[1]陈武. Nand Flash纠错码的设计研究[D].浙江大学,2011.</p>]]></content>
      
      
      <categories>
          
          <category> 数字IC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 车规芯片 </tag>
            
            <tag> 汉明码 </tag>
            
            <tag> RS码 </tag>
            
            <tag> BCH码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>车规芯片(二)  ECC概述</title>
      <link href="/2022/10/10/che-gui-xin-pian-er-ecc-gai-shu/"/>
      <url>/2022/10/10/che-gui-xin-pian-er-ecc-gai-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>ECC 是“<strong>Error Correcting Code</strong>”的简写，中文名称是“<strong>错误检查和纠正</strong>”，是一种能够实现“错误检查和纠正”的技术。<br>在数字电路中，最小的数据单位就是叫“比特（bit）”，也叫数据“位”，“比特”也是内存中的最小单位，它是通过“1”和“0”表示数据高、低电平信号的。空间中的无线电磁干扰、电路噪声会导致内存与CPU在进行数据交互的时候发生<strong>比特翻转</strong>(“0”变为“1”,“1”变为“0”)。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210101914584.png"><br>若某一位存储出了错误，就会使其中存储的相应数据发生改变而导致应用程序发生错误。大多数内存错误可通过<strong>重启</strong>解决，重启后内存里的数据被重新写入一遍。对于某些服务器来说，宕机一次带来的损失是巨大的，因此服务器往往会使用稳定性更高的<strong>ECC内存</strong>，这种内存回以主动发现数据传输过程中出现的错误，并将错误纠正。<br>对数据的校验常用的有<strong>奇偶校验</strong>、<strong>CRC校验</strong>等，而在NAND&nbsp;Flash处理中，一般使用一种比较专用的校验——<strong>ECC</strong>。ECC能纠正单比特错误和检测双比特错误，而且计算速度很快，但对1比特以上的错误无法纠正，对2比特以上的错误不保证能检测。</p><h1 id="最简单的措施"><a href="#最简单的措施" class="headerlink" title="最简单的措施"></a>最简单的措施</h1><p>为避免内存出错的情况，最简单的方法是在传输过程中，一组数据传输三遍。如果某组数据发生错误，通过对比其余两组数据，以其中相同的那两个为准，可定位错误的位置并纠正(只针对三组数据同一位置只有一个错误的情况，同时发生两个错误且同时位于同一位置的概率很低)。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210101459072.gif"><br>如果三组数据同一位置都发生了比特翻转，在纠错的过程中就会把错误的数据当成正确的数据，导致数据出错。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210101507147.gif"><br>但同时发生两个错误且同时位于同一位置的概率很低，这种方法最大的缺点在于浪费带宽，所有户数中只有1/3是有效的。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210101625760.png"><br>为了减少纠错码的占比，又能纠正错误，奇偶校验法被提出。</p><h1 id="奇偶校验法（parity-check）"><a href="#奇偶校验法（parity-check）" class="headerlink" title="奇偶校验法（parity check）"></a>奇偶校验法（parity check）</h1><p>二级制数只有0和1，在数据开头增加一位“纠错码”，然后数出原始数据中1的个数。比如一个字节中存储了某一数值，数其中“1”的个数：若“1”为偶数个，纠错码定义为0。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210101652124.png"><br>若“1”为奇数个，纠错码定义为1，把总数据的1的个数填补成偶数。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210101652603.png"><br>所以接收方接收到数据后，如果数据中“1”的个数是偶数个，则数据没有错误。如果是奇数个，则数据发生了错误，因此需要重新传输新数据。当纠错码自己发生了比特翻转，仍能够检测出数据发生了错误。这是因为<strong>奇偶校验不是用一个数据去保护其他数据，而是通过1个数据政变整组数据的奇偶性，纠错码本身就存在于这组数据中。</strong><br>但奇偶校验存在不足：当内存查到某个数据位有错误时，却并不一定能确定在哪一个位，也就不一定能修正错误，所以带有奇偶校验的内存的主要功能仅仅是“发现错误”，并不能纠正部分简单的错误。而且，如果同时有两个位发生比特翻转，“1”的总个数还是偶数，这种情况便检测不出数据是否发生错误。针对奇偶校验码的缺陷，<a href="https://baike.baidu.com/item/%E7%90%86%E6%9F%A5%E5%BE%B7%C2%B7%E5%8D%AB%E6%96%AF%E9%87%8C%C2%B7%E6%B1%89%E6%98%8E/9114683">理查德·卫斯里·汉明</a>在其基础上发明了汉明码。</p><h1 id="汉明码"><a href="#汉明码" class="headerlink" title="汉明码"></a>汉明码</h1><h2 id="汉明码的思想"><a href="#汉明码的思想" class="headerlink" title="汉明码的思想"></a>汉明码的思想</h2><p>这种纠错的基本思想是如何多次使用奇偶校验来<strong>二分</strong>查找出错误所在。</p><h2 id="汉明码基本原理"><a href="#汉明码基本原理" class="headerlink" title="汉明码基本原理"></a>汉明码基本原理</h2><p>汉明码能用很少的纠错码对大量的数据进行错误的查找和纠正，以16bit数据为例：<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210101926363.png" alt="16bit数据|200"><br>其中，4位数据为纠错码，11位数据为有效数据(第0位为全局的奇偶校验位)，这就是所说的（15,11）汉明码。</p><p><strong>1号纠错码</strong>用来对<strong>2、4列</strong>的数据进行奇偶校验：<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210101943671.png" alt="1号纠错码|200"><br><strong>2号纠错码</strong>用来对<strong>3、4列</strong>的数据进行奇偶校验：<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210101946937.png" alt="2号纠错码|200"><br><strong>4号纠错码</strong>用来对<strong>2、4行</strong>的数据进行奇偶校验：<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210101949763.png" alt="4号纠错码|200"><br><strong>8号纠错码</strong>用来对<strong>3、4行</strong>的数据进行奇偶校验：<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210101951310.png" alt="8号纠错码|200"></p><p>汉明码基本纠错原理如下所示：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iframe</span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>50%<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100%<span class="token punctuation">"</span></span><span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210102009260.mp4<span class="token punctuation">"</span></span><span class="token attr-name">allowfullscreen</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>iframe</span><span class="token punctuation">></span></span></code></pre><p>对于第0位数据，它是不在四位纠错码的纠错范围内的，它的错误与否不会影响奇偶校验的结果。同样，让第0位数据不存储原始数据，作为对全局的奇偶校验码。这样的好处是能够规避掉0号位无法保护的问题，又能检验出全局是否存在数据错误(只存在一个错误的前提下)。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210102014166.png" alt="第0位数据|200"></p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>数据中有一个bit发生翻转，找出错误位置<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210102020115.png" alt="例子|200"><br>答案为：<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210102021404.png" alt="答案|200"></p><h2 id="多个数据发生错误的情况"><a href="#多个数据发生错误的情况" class="headerlink" title="多个数据发生错误的情况"></a>多个数据发生错误的情况</h2><p>假设16bit数据中有两个bit发生翻转,<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210102027912.png" alt="2bit翻转|500"><br>可通过汉明码基本原理找到错误的bit位为第10位<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210102030354.png" alt="错误bit位|200"><br>但是，分析第0位又得知，全部共有偶数个“1”，说明全局没有数据错误。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210102032795.png" alt="|200"><br>二者结论相矛盾，说明发生了两个错误。虽然没有办法定位错误数据的位置，但知道发生了2个数据错误的情况，可重新传输数据。<br>当存在3个数据错误时，汉明码无法解决。但是同时出现3个错误的向能性非常低，我们要考虑的应该是降低错误的发生概率，避免不要出现3个错误的情况。<strong>纠错码存在的意义是用尽可能少的数据去解决不回避免的错误。</strong></p><h2 id="汉明码的位置"><a href="#汉明码的位置" class="headerlink" title="汉明码的位置"></a>汉明码的位置</h2><p>汉明码本质上和二分法原理接近，所以校验位正好是在数据的一半。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210121426624.png"><br>如果传输更多数据，只需要在每个2的第n次方上放置一位纠错码。而<strong>每多一位校验码，数据块大小就能翻倍</strong>，校验码占比就更小，换言之，信息率越高。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210121445923.gif"><br>当然，数据越多时，出现两个或者更多错误的可能性也越大，汉明码便无法处理，所以实际操作时需要使用一个合适的数据块大小。随着纠错码的发展，这样的问题可以采用更先进的代码解决。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210121432072.png"></p><h1 id="汉明码的硬件实现"><a href="#汉明码的硬件实现" class="headerlink" title="汉明码的硬件实现"></a>汉明码的硬件实现</h1><p>汉明码的广泛应用不只是因为其能以较少的纠错码去检验较多数据位，还因为汉明码的硬件实现简单。<br>将上述16bit数据的位置角标改为对应进制数，可以发现：</p><hr><p>1号纠错码的检验区域中（1号区域），所有位置角标的第1位数都是1，区域外其余角标第1位数均为0；<br>2号纠错码的检验区域中（2号区域），所有位置角标的第2位数都是1，区域外其余角标第2位数均为0；<br>4号纠错码的检验区域中（3号区域），所有位置角标的第3位数都是1，区域外其余角标第3位数均为0；<br>8号纠错码的检验区域中（4号区域），所有位置角标的第4位数都是1，区域外其余角标第4位数均为0；</p><hr><p>把所有包含1的位置数字全部提取出来，从上到下排列，可以发现，i（i = 1,2,3,4）号区域中的“1”在排列数字第 i 号位上为1，而其他区域的数据在这一位上刚好是0。这一列数即告诉了我们一号区域里有2个1，第2列数告诉了我们2号区域有4个1，第3列数告诉了我们3号区域有4个1，第4列数告诉我们4号区域也有4个1。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210102101266.png" alt="|500"><br>将每一列数的“0”和“1”六个数依次进行异或运算，如果1和0的个数是偶数，异或运算结果为0。由于四个区域的1的个数都是偶数。所以最终的结果就是0000。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210102114175.png" alt="XOR运算|500"><br>而这时候如果有任意一位0比特翻转成了1，这个数的角标就会直接穿插在6个数中间，相当于用0000去和它异或，结果会直接变成错误的数据位。我们一下就能找到是哪个数据发生了错误。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210102118936.png" alt="|400"></p><p>如果某个1变成0，这6个数会少一个，其实和增加一位是一样的，根据异或的性质，结果仍是错误的数据位。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210102120788.png" alt="|400"><br>所以，汉明码的纠错不需要一步一步地演算推理，只需要提取出所有1的位置，把它们的位置全部按照按顺序做一次异或运算，就可以直接定位错误的位置并更正。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210102126979.png" alt="汉明码纠错步骤"></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://www.bilibili.com/video/BV1GF411V7sC/?spm_id_from=333.999.0.0">【硬件科普】ECC内存是如何发现错误并纠正的？_哔哩哔哩_bilibili</a><br><a href="https://www.bilibili.com/video/BV1WK411N7kz/?spm_id_from=333.999.0.0">【官方双语】汉明码Pa■t1，如何克服噪■_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> 数字IC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 车规芯片 </tag>
            
            <tag> ECC算法 </tag>
            
            <tag> 汉明码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SystemVerilog学习笔记(五)</title>
      <link href="/2022/10/07/systemverilog-xue-xi-bi-ji-wu/"/>
      <url>/2022/10/07/systemverilog-xue-xi-bi-ji-wu/</url>
      
        <content type="html"><![CDATA[<h1 id="1-组合-x2F-非组合型"><a href="#1-组合-x2F-非组合型" class="headerlink" title="1. 组合/非组合型"></a>1. 组合/非组合型</h1><h2 id="1-1-非组合型-unpacked"><a href="#1-1-非组合型-unpacked" class="headerlink" title="1.1 非组合型(unpacked)"></a>1.1 非组合型(unpacked)</h2><p>数组中的成员之间存储数据都是互相独立的。如</p><div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210081324489.png " width="60%" height="60%"></div>SV保留了非组合型的数组声明方式，并且扩展了允许的类型，包括event,logic,bit,byte, int, longint, shortreal和real类型。数组的索引```systemverilogint a1 [7:0][1023:0];//unpacked arrayint a2 [1:8][1:1024]; //unpacked arraya2 = a1; //copy an entire arraya2[3] = a1[0] ; // copy a slice of an array , a2[3]=a2[3] [1024] ```数组的声明的两种方式```systemveriloglogic [31:0] data [1024];logic [31:0]data [0: 1023];//可看做一维数组，数组每个单元为32位logic类型。同样也可看作一个二维数组，每个元素是一位```<h2 id="1-2-组合型-packed"><a href="#1-2-组合型-packed" class="headerlink" title="1.2 组合型(packed)"></a>1.2 组合型(packed)</h2><p>组合型(packed)除了可以运用的数组声明，也可以用来定义结构体的存储方式:</p><pre class=" language-systemverilog"><code class="language-systemverilog">typedef struct packed {logic [ 7:0]crc;1ogic [63:0]data ;//此处两个数字为连续存放}data _word;data word [7:0]darray; // 1-D packed array of//packed structures</code></pre><p>组合型数组和其数组片段也可以灵活选择，用来拷贝和赋值等组</p><pre class=" language-systemverilog"><code class="language-systemverilog">logic [3:0][7:0]data; //2-D packed arraywire [31:0] out = data;//whole arraywire sign = data[3][7]; //bit-selectwire [3:0] nib = data [01][3:0]; //part-selectbyte high byte;assign high byte = data[31] ; //8-bit slicelogic [15:0] word;assign word = data[1:0]; // 2slices</code></pre><p>四值逻辑数组存放空间较二值逻辑数组所需空间翻倍</p><h2 id="1-3-差别"><a href="#1-3-差别" class="headerlink" title="1.3 差别"></a>1.3 差别</h2><p>组合型数组的维度声明在数组名左边，高位同样在左，低维在右</p><h2 id="1-4-数组初始化"><a href="#1-4-数组初始化" class="headerlink" title="1.4 数组初始化"></a>1.4 数组初始化</h2><p>组合型(packed)数组初始化时，同向量初始化一致:<br>非组合型(unpacked)数组初始化时，则需要通过’{来对数组的每一个维度进行赋值。</p><pre class=" language-systemverilog"><code class="language-systemverilog">int d [0:1][0:3] = '{ ' { 7,3,0,5}, '{2,0,1,6} };//d[0][01 = 7//d[0][1] = 3//d[0][2] = 0//d[0][3] = 5//d[1][0] = 2 //d[1][1] = 0//d[1][2] = 1//d[1][3] = 6</code></pre><h2 id="1-5-赋值"><a href="#1-5-赋值" class="headerlink" title="1.5 赋值"></a>1.5 赋值</h2><p>非组合型数组在初始化时，也可以类似结构体初始化，通过′{}和default关键词即可以完成<br>非组合型数组的数据成员或者数组本身均可以为其赋值<br>赋值方法</p><h1 id="2-拷贝"><a href="#2-拷贝" class="headerlink" title="2. 拷贝"></a>2. 拷贝</h1><h2 id="2-1-组合型与组合型"><a href="#2-1-组合型与组合型" class="headerlink" title="2.1 组合型与组合型"></a>2.1 组合型与组合型</h2><p>对于组合型数组，由于数组会被视为向量，因此当赋值左右两侧操作数的大小和维度不相同时，也可以做赋值。<br>如果当尺寸不相同时，则会通过截取或者扩展右侧操作数的方式来对左侧操作数赋值。</p><pre class=" language-systemverilog"><code class="language-systemverilog">bit [1:0][15:0]a; //32 bit 2-state vectorlogic [3:0][7:0] b; //32 bit 4-state vector    logic [15:0] c; //16 bit 4-state vectorlogic [39:0] d; //40 bit 4-state vectorb = a; //assign 32-bit array to 32-bit arrayc = a; //upper 16 bits will be truncated，高16位将被舍去d = a; //upper 8 bits wil1 be zero filled，高八位将被赋0</code></pre><h2 id="2-2-非组合型与非组合型"><a href="#2-2-非组合型与非组合型" class="headerlink" title="2.2 非组合型与非组合型"></a>2.2 非组合型与非组合型</h2><p>对于非组合型数组，在发生数组间拷贝时，则要求做左右两侧操作数的维度和大小必须严格一致。</p><pre class=" language-systemverilog"><code class="language-systemverilog">logic [31:0] a [2:0][9:0];logic [O: 31] b [1:3][1:10];a = b; //assign unpacked array to unpacked array</code></pre><h2 id="2-3-组合型与非组合型"><a href="#2-3-组合型与非组合型" class="headerlink" title="2.3 组合型与非组合型"></a>2.3 组合型与非组合型</h2><p>非组合型数组无法直接赋值给组合型数组，同样地，组合型数组也无法直接赋值给非组合型数组。</p><h2 id="2-4-数组的索引——foreach循环结构"><a href="#2-4-数组的索引——foreach循环结构" class="headerlink" title="2.4 数组的索引——foreach循环结构"></a>2.4 数组的索引——foreach循环结构</h2><p>SV添加foreach循环来对一维或者多维数组进行循环索引，<br>而不<br>需要指定该数组的维度大小。</p><pre class=" language-systemverilog"><code class="language-systemverilog">int sum [1:8][1:3];foreach ( sum[i,j])sum[i][j] = i +j; //initialize array</code></pre><p>foreach循环结构中的变量<strong>无需声明</strong>。<br>foreach循环结构中的变量是只读的，其<strong>作用域只在此循环结构中</strong>。</p><h1 id="3-动态数组"><a href="#3-动态数组" class="headerlink" title="3. 动态数组"></a>3. 动态数组</h1><h2 id="3-1-声明方式"><a href="#3-1-声明方式" class="headerlink" title="3.1 声明方式"></a>3.1 声明方式</h2><p>动态数组在声明时需要使用[]，这表示不会在编译时为其制定尺寸，而是在仿真运行时来确定。<br>动态数组一开始为空，而需要使用new[]来为其分配空间</p><h2 id="3-2-使用实例"><a href="#3-2-使用实例" class="headerlink" title="3.2 使用实例"></a>3.2 使用实例</h2><div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210081344286.png " width="60%" height="60%"></div><h1 id="4-队列"><a href="#4-队列" class="headerlink" title="4. 队列"></a>4. 队列</h1><h2 id="4-1-声明方式"><a href="#4-1-声明方式" class="headerlink" title="4.1 声明方式"></a>4.1 声明方式</h2><p>通过[$]来声明队列，队列的索引值从0到$。</p><h2 id="4-2-使用实例"><a href="#4-2-使用实例" class="headerlink" title="4.2 使用实例"></a>4.2 使用实例</h2><div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210081344016.png " width="60%" height="60%"></div><hr><div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210081349124.png " width="60%" height="60%"></div><h1 id="5-关联数组"><a href="#5-关联数组" class="headerlink" title="5. 关联数组"></a>5. 关联数组</h1><p>SV引入了关联数组，可以用来存放散列的数据成员。散列的索引类型除了为整形以外还可以为字符串或者其它类型，而散列存储的数据成员也可以为任意类型。</p><h2 id="5-1-使用实例"><a href="#5-1-使用实例" class="headerlink" title="5.1 使用实例"></a>5.1 使用实例</h2><pre class=" language-systemverilog"><code class="language-systemverilog">module&nbsp;tb;  &nbsp;&nbsp;initial&nbsp;begin  &nbsp;&nbsp;bit&nbsp;[31:0]&nbsp;mem&nbsp;[int&nbsp;unsigned];  &nbsp;&nbsp;int&nbsp;unsigned&nbsp;data,&nbsp;addr;  &nbsp;&nbsp;repeat(5)begin  &nbsp;&nbsp;&nbsp;&nbsp;std::randomize(addr,data)&nbsp;with&nbsp;{addr[31:8]&nbsp;==&nbsp;0;&nbsp;addr[1:0]&nbsp;==&nbsp;0;&nbsp;data&nbsp;inside&nbsp;{[1:10]};&nbsp;};  &nbsp;&nbsp;&nbsp;&nbsp;$display("address&nbsp;:&nbsp;'h%0x,&nbsp;data&nbsp;:&nbsp;'h%0x",&nbsp;addr,&nbsp;data);  &nbsp;&nbsp;&nbsp;&nbsp;mem[addr]&nbsp;=&nbsp;data;  &nbsp;&nbsp;&nbsp;&nbsp;foreach(mem[idx])  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$display("mem&nbsp;adress&nbsp;:&nbsp;'h'%0x,&nbsp;data&nbsp;:&nbsp;'h%0x",&nbsp;idx,&nbsp;mem[idx]);  &nbsp;&nbsp;end  end  endmodule</code></pre><p>仿真结果：</p><div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210081533507.png " width="40%" height="40%"></div>从结果可看出，index并不连续对于结果的打印，同样可采用如下方法：```systemverilog&nbsp;&nbsp;&nbsp;&nbsp;if(mem.first(addr))begin  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$display("foreach_loop&nbsp;mem&nbsp;address&nbsp;:&nbsp;'h%0x&nbsp;data&nbsp;:&nbsp;'h%0x",addr,mem[addr]);  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(mem.next(addr)); //如果还能继续索引到地址值，继续循环 &nbsp;&nbsp;&nbsp;&nbsp;end```仿真结果<div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210081536016.png " width="60%" height="60%"></div>此外，在索引时，索引地址不连续，可增加判断索引地址是否存在```systemverilog&nbsp;&nbsp;if&nbsp;(mem.exists('h10))  &nbsp;&nbsp;&nbsp;&nbsp;$display("ACCESS&nbsp;mem&nbsp;address&nbsp;:&nbsp;'h%0x,&nbsp;data&nbsp;:&nbsp;'h%0x",&nbsp;'h10,&nbsp;mem['h10]);  &nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$display("ACCESS&nbsp;mem&nbsp;address&nbsp;:&nbsp;'h%0x&nbsp;is&nbsp;illegal&nbsp;adress",&nbsp;'h10);```仿真结果：<div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210081539044.png " width="60%" height="60%"></div><h1 id="6-数组的方法"><a href="#6-数组的方法" class="headerlink" title="6. 数组的方法"></a>6. 数组的方法</h1><h2 id="6-1-数组缩减"><a href="#6-1-数组缩减" class="headerlink" title="6.1 数组缩减"></a>6.1 数组缩减</h2><p>基本的数组缩减方法是把一个数组缩减成一个值。<br>最常用的缩减方法是sum，它对数组中的所有元素求和。</p><pre class=" language-systemverilog"><code class="language-systemverilog">byte b[$] = {2，3，4，5};int W;w = b.sum();  // 14=2+3+4+5w = b.product(); // 120 = 2 *3*4*5W = b.and();  // 0000 0000 = 2&3&4& 5</code></pre><p>其它的数组缩减方法还有product(积), and(与), or(或)和xor(异或)。</p><h2 id="6-2-数组定位"><a href="#6-2-数组定位" class="headerlink" title="6.2 数组定位"></a>6.2 数组定位</h2><p>对于非合并数组，可以使用数组定位方法，其返回值将是一个队<br>列而非一个数据成员。</p><pre class=" language-systemverilog"><code class="language-systemverilog">int f[6] = '{1,6,2,6,8,6};  // Fixed-size arrayint d[] = '{2,4,6,8,10};  // Dynamic arrayint q[$] = {1,3,5,7}，  // Queue ;tq[$] ;  // Temporary queue for resulttq = q.min();  // {1}tq = d.max();  // {10}tq = f.unique(); // {1,6,2,8} </code></pre><p>使用foreach也可以实现数组的搜索,不过使用find…with则在查找满足条件的数据成员时，更为方便。</p><div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210081547317.png " width="60%" height="60%"></div><h2 id="6-3-数组排序"><a href="#6-3-数组排序" class="headerlink" title="6.3 数组排序"></a>6.3 数组排序</h2><p>可以通过排序方法改变数组中元素的顺序，可以对它们进行正向、逆向或者乱序的排列。</p><pre class=" language-systemverilog"><code class="language-systemverilog">int a [] =       {9,1,8,3,4,4};d. reverse();  //{4,4,3,8,1,9}d.sort();      //{1,3,4,4,8,9}d.rsort();     //{9,8,4,4,3,1}d.shuffle();   //{9,4,3,8,1,4}</code></pre><h1 id="7-问答题"><a href="#7-问答题" class="headerlink" title="7. 问答题"></a>7. 问答题</h1><p>1.<strong>链表和SV中的哪些数组类型(定长数组、动态数组、队列、关联数组)相似，相似的特性有哪些?</strong><br>链表数据在实际存储时，所在的内存地址并不连续，数据随机分布在内存中的各个位置，这种存储结构成为练市存储。链式存储生成的表成为链表。但为了能够保持数据元素之间的顺序关系，每个数据元素在存储的同时，都要配备一个指针，指向它的直接后继元素，每一个数据元素都指向下一个数据元素，这些由指针相互连接的数据，就具有了线性的关联。</p><p>删除链表的元素只需要把前节点的指针域，越过要删除的节点直接指向下一个节点，然后释放被删除节点的空间。若不释放，被删节点成为野指针，造成内存泄露。<br>添加链表的元素时需要先确定要添加的位置，然后把前节点的指针域指向自身，再将自身的指针域指向下一个节点即可。</p><p>链表与数组的区别(C语言)：<br> <strong>应用场景方面</strong>：数组必须事先定义长度(元素个数)，并分配固定大小的空间，不能适应数据动态增减的情况，不能适应数据动态增减的情况。相反，链表可以动态地进行内存分配，可以适应数据动态增减的情况，且可以方便地插入、删除数据项。<br><strong>内存方面</strong>：数组从栈中分配空间，所有关于内存的申请开辟或者析构释放都由系统完成，方便快速，但是自由度小。链表从堆中分配空间，用多少，就开辟多少内存，自由度大，内存的申请管理较麻烦。<br><strong>操作效率方面</strong>：在插入或者删除数组中的元素时，其后的所有元素都要被移动。而在链表中插入或者删除某节点时，只需修改指针即可，不需要移动节点。 因此插入删除元素，链表的效率由于数组。但在访问效率方面，由于数组的内存是连续的，则可以直接使用下标访问数组电的某个元素。链表的内存是不连续的，要访问链表中的某个节点，必须从头节点开始查找。因此，链表的访问效率不如数组。</p><p>回到SystemVerilog，<strong>链表在增删元素操作上与队列相似</strong>，可以在数据中任何地方添加或者删除元素。(但值得注意的是，队列同时又具有数组的优点，可以通过索引实现对任一元素的访问，这一点优于链表。) <strong>链表在动态分配内存上同动态数组类似</strong>链表能够动态地进行内存分配，这一点同动态数组类似。使用动态数组可以在仿真时分配空间或调整宽度。动态数组在声明时使用空的下标[]，数组的宽度不在编译时给出，而在程序运行时再指定，调用new[]操作符来分配空间，同时在方括号中传递数组宽度。<br><strong>SystemVerilog虽然提供了链表数据结构，但是应该避免使用它，因为SystemVerilog提供的队列更加高效易用。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数字IC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字前端 </tag>
            
            <tag> SystemVerilog验证 </tag>
            
            <tag> 数组队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SystemVerilog课程笔记(四)</title>
      <link href="/2022/10/04/systemverilog-ke-cheng-bi-ji-si/"/>
      <url>/2022/10/04/systemverilog-ke-cheng-bi-ji-si/</url>
      
        <content type="html"><![CDATA[<h1 id="1-将initial过程块改造为task"><a href="#1-将initial过程块改造为task" class="headerlink" title="1. 将initial过程块改造为task"></a>1. 将initial过程块改造为task</h1><p>task和function用法见[[SystemVerilog学习笔记(四)]]</p><h2 id="1-1改造"><a href="#1-1改造" class="headerlink" title="1.1改造"></a>1.1改造</h2><p>将前一次的两个initial begin end 语句封装进task任务中</p><blockquote><p>initial begin : drive_reset_proc<br>drive_reset();//调用task<br>end<br>task drive_reset();<br>……//将复位信号的产生语句封装进task<br>endtask</p></blockquote><blockquote><p>initial begin : drive_chnl0_proc<br>        drive_chnl0();//调用task<br>end<br>task drive_chnl0();<br>……//将drive_chnl0语句封装进task<br>endtask</p></blockquote><h2 id="1-2改造后的tb-sv"><a href="#1-2改造后的tb-sv" class="headerlink" title="1.2改造后的tb.sv"></a>1.2改造后的tb.sv</h2><p><span style="background:rgba(240, 200, 0, 0.2)">tb.sv代码如下</span></p><pre class=" language-systemverilog"><code class="language-systemverilog">//********************************** stimulator **********************************//module rt_stimulator(  input clock  ,input reset_n  ,output logic [15:0] din  ,output logic [15:0] frame_n  ,output logic [15:0] valid_n  ,input [15:0] dout  ,input [15:0] valido_n  ,input [15:0] busy_n  ,input [15:0] frameo_n);//for debug purpose from waveform//定义检测状态的变量  typedef enum {DRV_RESET,DRV_IDLE,DRV_ADDR,DRV_PAD,DRV_DATA} drv_state_t;  drv_state_t dbg_state;    byte unsigned dbg_din_chnl0_data; initial begin : drive_reset_proc //reset阶段，复位时，reset_n为低电平,frame_n和valid_n为高电平    drive_reset();endtask drive_reset();  @(negedge reset_n);  dbg_state <= DRV_RESET;  din <= 0;  frame_n <= 1;  valid_n <= 1;endtask// drive chaannel 0 - chanel 15 (din[15:0])定义数据输出地址及数据bit [3:0] addr;byte unsigned data[];initial begin : drive_chnl0_proc    drive_chnl0();endtask drive_chnl0();  @(negedge reset_n);  repeat(10) @(posedge clock);//延迟10个时钟周期  addr = 3;//从第3位输出  data = '{8'h33,8'h77};    // drive address phase 输入地址位阶段for(int i=0;i<4;i++)begin  //4 clock  @(posedge clock);  dbg_state <=DRV_ADDR;  din[0] <= addr[i];  valid_n[0] <= $urandom_range(0,1);//valid_n在din的地址输入时间段可为任意值x  frame_n[0] <= 1'b0;//frame_n需要为低end    // drive pad phase //隔离阶段  for (int i=0;i<5;i++)begin  //5 clock    @(posedge clock);    dbg_state <=DRV_PAD;    din[0] <= 1'b1;    valid_n[0] <= 1'b1;//valid_n需为高电平    frame_n[0] <= 1'b0; //frame_n需为低电平  end    // drive data phase 传输数据阶段  foreach(data[id])begin    for(int i=0;i<8;i++)begin     @(posedge clock);      dbg_state <=DRV_DATA;      dbg_din_chnl0_data <= data[id];      din[0] <= data[id][i];      valid_n[0] <=1'b0;      frame_n <= (id == data.size()-1 && i == 7) ? 1'b1 : 1'b0;//packet最后一位输出数据时frameo_n为高    end  end// drive idle phase 闲置（没有数据传输）阶段  @(posedge clock);  dbg_state <=DRV_IDLE;  dbg_din_chnl0_data <= 0;  din[0] <= 1'b0;  valid_n[0] <= 1'b1;  frame_n <= 1'b1;endtaskendmodule//********************************** tb **********************************//module tb;bit clk,rstn;logic [15:0] din, frame_n, valid_n;logic [15:0] dout, valido_n, busy_n, frameo_n;// 产生时钟，周期为10nsinitial     forever #5ns clk <= !clk;// 产生复位信号  initial begin    #2ns rstn <= 1;    #10ns rstn <= 0;    #10ns rstn <= 1;  end//例化router为DUTrouter dut(             .reset_n(rstn),  .clock(clk),  .*  //其余端口名称均相同);//例化stimulatorrt_stimulator stim(  .reset_n(rstn),  .clock(clk),  .*);endmodule </code></pre><h2 id="1-3仿真结果"><a href="#1-3仿真结果" class="headerlink" title="1.3仿真结果"></a>1.3仿真结果</h2><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211050927657.png" width="100%" height="100%"></div><h1 id="2-任意source-channl向任意destination-channl发送数据"><a href="#2-任意source-channl向任意destination-channl发送数据" class="headerlink" title="2. 任意source_channl向任意destination_channl发送数据"></a>2. 任意source_channl向任意destination_channl发送数据</h1><h2 id="2-1改造"><a href="#2-1改造" class="headerlink" title="2.1改造"></a>2.1改造</h2><blockquote><p>task drive_chnl0(bit[3:0] saddr, bit [3:0] daddr, byte unsigned data[]);<br>……<br>endtask</p></blockquote><h2 id="2-2改造后的tb-sv"><a href="#2-2改造后的tb-sv" class="headerlink" title="2.2改造后的tb.sv"></a>2.2改造后的tb.sv</h2><pre class=" language-systemverilog"><code class="language-systemverilog">//********************************** stimulator **********************************//module rt_stimulator(  input clock  ,input reset_n  ,output logic [15:0] din  ,output logic [15:0] frame_n  ,output logic [15:0] valid_n  ,input [15:0] dout  ,input [15:0] valido_n  ,input [15:0] busy_n  ,input [15:0] frameo_n);//for debug purpose from waveform//定义检测状态的变量  typedef enum {DRV_RESET,DRV_IDLE,DRV_ADDR,DRV_PAD,DRV_DATA} drv_state_t;  drv_state_t dbg_state;    byte unsigned dbg_din_chnl0_data; //reset阶段，复位时，reset_n为低电平,frame_n和valid_n为高电平initial begin : drive_reset_proc   drive_reset();endtask drive_reset();  @(negedge reset_n);  dbg_state <= DRV_RESET;  din <= 0;  frame_n <= '1;//等效16'hFFFF  valid_n <= '1;endtask// drive chaannel 0 - chanel 15 (din[15:0])定义数据输出地址及数据bit [3:0] daddr;byte unsigned data[];initial begin : drive_chnl0_proc  @(negedge reset_n);  repeat(10) @(posedge clock);//延迟10个时钟周期    drive_chnl(0,3,'{8'h33,8'h77});//name mapping    drive_chnl(0,5,'{8'h55,8'h66});//name mappingendinitial begin : drive_chnl3_proc  @(negedge reset_n);  repeat(10) @(posedge clock);//延迟10个时钟周期    drive_chnl(3,6,'{8'h77,8'h88,8'h22});//name mappingendtask drive_chnl(bit[3:0] saddr, bit [3:0] daddr, byte unsigned data[]);  $display("[DRV]src_chnl[%0d],dest_chnl[%0d] data trans started",saddr,daddr);    // drive address phase 输入地址位阶段for(int i=0;i<4;i++)begin  //4 clock  @(posedge clock);  dbg_state <=DRV_ADDR;  din[saddr] <= daddr[i];  valid_n[saddr] <= $urandom_range(0,1);//valid_n在din的地址输入时间段可为任意值x  frame_n[saddr] <= 1'b0;//frame_n需要为低end    // drive pad phase //隔离阶段  for (int i=0;i<5;i++)begin  //5 clock    @(posedge clock);    dbg_state <=DRV_PAD;    din[saddr] <= 1'b1;    valid_n[saddr] <= 1'b1;//valid_n需为高电平    frame_n[saddr] <= 1'b0; //frame_n需为低电平  end    // drive data phase 传输数据阶段  foreach(data[id])begin    for(int i=0;i<8;i++)begin     @(posedge clock);      dbg_state <=DRV_DATA;      dbg_din_chnl0_data <= data[id];      din[saddr] <= data[id][i];      valid_n[saddr] <=1'b0;      frame_n[saddr] <= (id == data.size()-1 && i == 7) ? 1'b1 : 1'b0;//packet最后一位输出数据时frameo_n为高    end  end// drive idle phase 闲置（没有数据传输）阶段  @(posedge clock);  dbg_state <=DRV_IDLE;  dbg_din_chnl0_data <= 0;  din[saddr] <= 1'b0;  valid_n[saddr] <= 1'b1;  frame_n[saddr] <= 1'b1;  $display("[DRV]src_chnl[%0d],dest_chnl[%0d] data trans finished",saddr,daddr);endtaskendmodule//********************************** tb **********************************//module tb;bit clk,rstn;logic [15:0] din, frame_n, valid_n;logic [15:0] dout, valido_n, busy_n, frameo_n;// 产生时钟，周期为10nsinitial     forever #5ns clk <= !clk;// 产生复位信号  initial begin    #2ns rstn <= 1;    #10ns rstn <= 0;    #10ns rstn <= 1;  end//例化router为DUTrouter dut(             .reset_n(rstn),  .clock(clk),  .*  //其余端口名称均相同);//例化stimulatorrt_stimulator stim(  .reset_n(rstn),  .clock(clk),  .*);endmodule </code></pre><h2 id="2-3仿真结果"><a href="#2-3仿真结果" class="headerlink" title="2.3仿真结果"></a>2.3仿真结果</h2><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211051047693.png" width="100%" height="100%"></div><h1 id="3-关于automatic的问题"><a href="#3-关于automatic的问题" class="headerlink" title="3. 关于automatic的问题"></a>3. 关于automatic的问题</h1><h2 id="3-1给任务添加automatic"><a href="#3-1给任务添加automatic" class="headerlink" title="3.1给任务添加automatic"></a>3.1给任务添加automatic</h2><p>Module里面所有变量默认是静态变量，都是被共用的。<br>task不加automatic，任务task及其内部参数daddr，saddr等都是静态的，这个任务会被多个并行的线程所共享。当两个initial 同时调用drive_chnl这个task时，它们是共用这个task。<br>task添加automatic后，每次调用这个task时，都会单独开辟空间（包括内存及其内部参数都会有独立空间）。当两个initial 同时调用drive_chnl这个task时，它们独立调用task。</p><blockquote><p>task automatic drive_chnl(bit[3:0] saddr, bit [3:0] daddr, byte unsigned data[]);</p></blockquote><h2 id="3-2添加automatic后的tb-sv"><a href="#3-2添加automatic后的tb-sv" class="headerlink" title="3.2添加automatic后的tb.sv"></a>3.2添加automatic后的tb.sv</h2><pre class=" language-systemverilog"><code class="language-systemverilog">//********************************** stimulator **********************************//module rt_stimulator(  input clock  ,input reset_n  ,output logic [15:0] din  ,output logic [15:0] frame_n  ,output logic [15:0] valid_n  ,input [15:0] dout  ,input [15:0] valido_n  ,input [15:0] busy_n  ,input [15:0] frameo_n);//for debug purpose from waveform//定义检测状态的变量  typedef enum {DRV_RESET,DRV_IDLE,DRV_ADDR,DRV_PAD,DRV_DATA} drv_state_t;  drv_state_t dbg_state;    byte unsigned dbg_din_chnl0_data; //reset阶段，复位时，reset_n为低电平,frame_n和valid_n为高电平initial begin : drive_reset_proc   drive_reset();endtask drive_reset();  @(negedge reset_n);  dbg_state <= DRV_RESET;  din <= 0;  frame_n <= '1;//等效16'hFFFF  valid_n <= '1;endtask// drive chaannel 0 - chanel 15 (din[15:0])定义数据输出地址及数据bit [3:0] daddr;byte unsigned data[];initial begin : drive_chnl0_proc  @(negedge reset_n);  repeat(10) @(posedge clock);//延迟10个时钟周期    drive_chnl(0,3,'{8'h33,8'h77});//name mapping    drive_chnl(0,5,'{8'h55,8'h66});//name mappingendinitial begin : drive_chnl3_proc  @(negedge reset_n);  repeat(10) @(posedge clock);//延迟10个时钟周期    drive_chnl(3,6,'{8'h77,8'h88,8'h22});//name mappingendtask automatic drive_chnl(bit[3:0] saddr, bit [3:0] daddr, byte unsigned data[]);  $display("[DRV]src_chnl[%0d],dest_chnl[%0d] data trans started",saddr,daddr);    // drive address phase 输入地址位阶段for(int i=0;i<4;i++)begin  //4 clock  @(posedge clock);  dbg_state <=DRV_ADDR;  din[saddr] <= daddr[i];  valid_n[saddr] <= $urandom_range(0,1);//valid_n在din的地址输入时间段可为任意值x  frame_n[saddr] <= 1'b0;//frame_n需要为低end    // drive pad phase //隔离阶段  for (int i=0;i<5;i++)begin  //5 clock    @(posedge clock);    dbg_state <=DRV_PAD;    din[saddr] <= 1'b1;    valid_n[saddr] <= 1'b1;//valid_n需为高电平    frame_n[saddr] <= 1'b0; //frame_n需为低电平  end    // drive data phase 传输数据阶段  foreach(data[id])begin    for(int i=0;i<8;i++)begin     @(posedge clock);      dbg_state <=DRV_DATA;      dbg_din_chnl0_data <= data[id];      din[saddr] <= data[id][i];      valid_n[saddr] <=1'b0;      frame_n[saddr] <= (id == data.size()-1 && i == 7) ? 1'b1 : 1'b0;//packet最后一位输出数据时frameo_n为高    end  end// drive idle phase 闲置（没有数据传输）阶段  @(posedge clock);  dbg_state <=DRV_IDLE;  dbg_din_chnl0_data <= 0;  din[saddr] <= 1'b0;  valid_n[saddr] <= 1'b1;  frame_n[saddr] <= 1'b1;  $display("[DRV]src_chnl[%0d],dest_chnl[%0d] data trans finished",saddr,daddr);endtaskendmodule//********************************** tb **********************************//module tb;bit clk,rstn;logic [15:0] din, frame_n, valid_n;logic [15:0] dout, valido_n, busy_n, frameo_n;// 产生时钟，周期为10nsinitial     forever #5ns clk <= !clk;// 产生复位信号  initial begin    #2ns rstn <= 1;    #10ns rstn <= 0;    #10ns rstn <= 1;  end//例化router为DUTrouter dut(             .reset_n(rstn),  .clock(clk),  .*  //其余端口名称均相同);//例化stimulatorrt_stimulator stim(  .reset_n(rstn),  .clock(clk),  .*);endmodule </code></pre><h2 id="3-3仿真结果"><a href="#3-3仿真结果" class="headerlink" title="3.3仿真结果"></a>3.3仿真结果</h2><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211051044480.png" width="100%" height="100%"></div><h1 id="4-初步TestBench平台概览"><a href="#4-初步TestBench平台概览" class="headerlink" title="4. 初步TestBench平台概览"></a>4. 初步TestBench平台概览</h1><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211032052337.png" width="80%" height="80%"></div>]]></content>
      
      
      <categories>
          
          <category> 数字IC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字前端 </tag>
            
            <tag> SystemVerilog验证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SystemVerilog课程笔记(三)</title>
      <link href="/2022/10/04/systemverilog-ke-cheng-bi-ji-san/"/>
      <url>/2022/10/04/systemverilog-ke-cheng-bi-ji-san/</url>
      
        <content type="html"><![CDATA[<h1 id="1-DUT——router功能概述"><a href="#1-DUT——router功能概述" class="headerlink" title="1. DUT——router功能概述"></a>1. DUT——router功能概述</h1><h2 id="1-1管脚图"><a href="#1-1管脚图" class="headerlink" title="1.1管脚图"></a>1.1管脚图</h2><p>以router（路由器）为例</p><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210041439616.png" width="60%" height="60%"></div>## 1.2输入输出信号**左边**是输入：16位的din（数据输入）、16位的frame_n（数据帧有效，低电平有效）、16位的valid_n（有效信号，低电平有效）、reset_n（低电平复位）和clock（时钟）**右边**是输出：16位的dout（数据输出）、16位的dout（数据输出）、16位的frameo_n（数据帧输出有效）、16位的valido_n（输出有效信号，低电平有效）## 1.3模块功能16个输入的通道，选一个通道作为输入通道，同样的，16个输出的通道，也是选一个通道作为输出通道，数据是一bit一bit地传输。例如，选择din[7]为数据的输入通道，所以frame_n[7]和valid_n[7]就是控制信号；选择dout[3]为数据的输出通道，所以frameo_n[3]和valido_n[3]就是控制信号。因此数据会从7号输入通道输入，然后从3号通道输出，路由器的功能就是这么简单。## 1.4输入信号协议<div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210041525871.png " width="100%" height="100%"></div> **din信号**1.din[i]中的i表示从哪路输入，**din中的第一段4bit的数据表示输出地址（低位开始）**，从哪路输出2.地址传输完毕后拉高进入隔离段3.隔离段结束后开始传输数据（低位开始）**frame_n信号**1.下降沿指示packet的第一位数据2.上升沿指示packet的最后一位数据**valid_n信号**1.其在din的地址输入时间段可为任意值x2.在隔离段pad拉高3.其拉低时表示数据有效，因此在payload段若其拉高，则din数据无效4.数据输入完毕后拉高## 1.5输出信号协议<div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210041531905.png " width="100%" height="100%"></div>输出信号时序图如上，比较简单，当valido_n和frameo_n均为低时数据有效，除了packet最后一位输出数据时frameo_n为高&nbsp;。## 1.6复位信号协议<div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210041534779.png " width="100%" height="100%"></div>以上为其复位协议时序图，有以下几点需要注意：1.复位时，reset_n为低电平,frame_n和valid_n为高电平2.有效复位**至少保持1个clk**3.复位后**至少等待15个时钟**周期后才可以发送数据<h1 id="2-实验代码"><a href="#2-实验代码" class="headerlink" title="2. 实验代码"></a>2. 实验代码</h1><pre class=" language-systemverilog"><code class="language-systemverilog">//********************************** stimulator **********************************//module rt_stimulator(  input clock  ,input reset_n  ,output logic [15:0] din  ,output logic [15:0] frame_n  ,output logic [15:0] valid_n  ,input [15:0] dout  ,input [15:0] valido_n  ,input [15:0] busy_n  ,input [15:0] frameo_n);//for debug purpose from waveform//定义检测状态的变量  typedef enum {DRV_RESET,DRV_IDLE,DRV_ADDR,DRV_PAD,DRV_DATA} drv_state_t;  drv_state_t dbg_state;    byte unsigned dbg_din_chnl0_data; initial begin : drive_reset_proc //reset阶段，复位时，reset_n为低电平,frame_n和valid_n为高电平  @(negedge reset_n);  dbg_state <= DRV_RESET;  din <= 0;  frame_n <= 1;  valid_n <= 1;end// drive chaannel 0 - chanel 15 (din[15:0])定义数据输出地址及数据bit [3:0] addr;byte unsigned data[];initial begin : drive_chnl0_proc  @(negedge reset_n);  repeat(10) @(posedge clock);//延迟10个时钟周期  addr = 3;//从第3位输出  data = '{8'h33,8'h77};    // drive address phase 输入地址位阶段for(int i=0;i<4;i++)begin  //4 clock  @(posedge clock);  dbg_state <=DRV_ADDR;  din[0] <= addr[i];  valid_n[0] <= $urandom_range(0,1);//valid_n在din的地址输入时间段可为任意值x  frame_n[0] <= 1'b0;//frame_n需要为低end    // drive pad phase //隔离阶段  for (int i=0;i<5;i++)begin  //5 clock    @(posedge clock);    dbg_state <=DRV_PAD;    din[0] <= 1'b1;    valid_n[0] <= 1'b1;//valid_n需为高电平    frame_n[0] <= 1'b0; //frame_n需为低电平  end    // drive data phase 传输数据阶段  foreach(data[id])begin    for(int i=0;i<8;i++)begin     @(posedge clock);      dbg_state <=DRV_DATA;      dbg_din_chnl0_data <= data[id];      din[0] <= data[id][i];      valid_n[0] <=1'b0;      frame_n <= (id == data.size()-1 && i == 7) ? 1'b1 : 1'b0;//packet最后一位输出数据时frameo_n为高    end  end// drive idle phase 闲置（没有数据传输）阶段  @(posedge clock);  dbg_state <=DRV_IDLE;  dbg_din_chnl0_data <= 0;  din[0] <= 1'b0;  valid_n[0] <= 1'b1;  frame_n <= 1'b1;endendmodule//********************************** tb **********************************//module lab3tb;bit clk,rstn;logic [15:0] din, frame_n, valid_n;logic [15:0] dout, valido_n, busy_n, frameo_n;// 产生时钟，周期为10nsinitial     forever #5ns clk <= !clk;// 产生复位信号  initial begin    #2ns rstn <= 1;    #10ns rstn <= 0;    #10ns rstn <= 1;  end//例化router为DUTrouter dut(             .reset_n(rstn),  .clock(clk),  .*  //其余端口名称均相同);//例化stimulatorrt_stimulator stim(  .reset_n(rstn),  .clock(clk),  .*);endmodule </code></pre><h1 id="3-仿真结果"><a href="#3-仿真结果" class="headerlink" title="3. 仿真结果"></a>3. 仿真结果</h1><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210042153244.png" width="100%" height="100%"></div><p>另，关于vim编辑器</p><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210042205029.png" width="100%" height="100%"></div><h1 id="4-初步TestBench平台概览"><a href="#4-初步TestBench平台概览" class="headerlink" title="4. 初步TestBench平台概览"></a>4. 初步TestBench平台概览</h1><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211052041415.png" width="80%" height="80%"></div>]]></content>
      
      
      <categories>
          
          <category> 数字IC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字前端 </tag>
            
            <tag> SystemVerilog验证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>色彩美学(一)_色彩理论基础</title>
      <link href="/2022/10/03/se-cai-mei-xue-yi-se-cai-li-lun-ji-chu/"/>
      <url>/2022/10/03/se-cai-mei-xue-yi-se-cai-li-lun-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="色彩基础知识"><a href="#色彩基础知识" class="headerlink" title="色彩基础知识"></a>色彩基础知识</h1><h2 id="主色"><a href="#主色" class="headerlink" title="主色"></a>主色</h2><p>主色顾名思义即主要色彩，一幅作品的主色代表者作品的主题，往往最直接影响作品给人的感官感受。主色可以通过一下方式区分：<br><strong>1.整个画面中，面积大，且纯度高的色彩，这个就是主色。</strong><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210031259383.png"><br>图中红色就是主色，若换成蓝色，传达的就是商务严肃感，而不是略带危险刺激的感受了。</p><p><strong>2.整个画面中，相比面积大，但纯度低或者明度低的色彩，虽然面积稍小，但画面中你一眼就看到的色彩，就是主色。</strong><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210031300552.png"><br>画面中灰绿色面积虽然大，但因为黄色的巴士纯度更高，更夺人眼球，所以整幅作品中，黄色是主色。</p><p><strong>3.主色也存在双主色的情况。两种色彩面积是等量的，可以给人留下深刻的印象。双主色的搭配，往往显得更具有个性。</strong><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210031300689.png"><br>图中蓝灰色和红色的面积是等量的，是双主色搭配，去掉任何一种颜色画面效果都会打折扣。</p><h2 id="辅色"><a href="#辅色" class="headerlink" title="辅色"></a>辅色</h2><p>辅助色的目的是配合主色使主题形象更加完整，那么如何配合主色进行搭配呢?<br>1.<strong>同类色</strong>：辅助色选择主色的同类色，可达成画面统一和谐。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210031304192.png"><br>主色是中间的红色，辅助色是橙色，橙色的运用使红色更为突出，典型的同类色辅助色，也可以叫做背景色辅助色，整个画面显得极为和谐。</p><p>2.<strong>对比色</strong>：选择主色对比色，画面刺激、活泼，也很稳定。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210031307670.png"></p><h2 id="点缀色"><a href="#点缀色" class="headerlink" title="点缀色"></a>点缀色</h2><p>颜色面积最小，出现次数多，与别的颜色反差大，具有引导视线作用，影响主色作用小，只是提醒人们注意。<br><strong>点缀色特点</strong><br><strong>(1)颜色跳跃</strong><br><strong>(2)引起阅读性</strong><br><strong>(3)与其他颜色反差较大</strong><br><img src="https://pic1.zhimg.com/80/v2-5d2205f462305db5b18255d46f8a1044_720w.webp"></p><p>这幅作品中的点缀色是多个颜色，颜色跳跃，形成自有的风格，同时引导大家阅读下方的文字。</p><h2 id="色轮"><a href="#色轮" class="headerlink" title="色轮"></a>色轮</h2><p>红+黄色＝橙，黄+蓝＝绿，蓝+红＝紫，如果我们将这些颜色混合在一起，我们可以得到更多颜色，如黄绿色和橙红色，总之，它们形成了所谓的色轮。<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210031315701.png"></p><h1 id="色彩三要素"><a href="#色彩三要素" class="headerlink" title="色彩三要素"></a>色彩三要素</h1><h2 id="色相-Hue"><a href="#色相-Hue" class="headerlink" title="色相(Hue)"></a>色相(Hue)</h2><p>是指<strong>色彩的相貌</strong>，色相被用来区分颜色，根据光的不同波长，色彩具有红色、黄色或绿色等性质，这被称之为色相。</p><h2 id="明度-Value"><a href="#明度-Value" class="headerlink" title="明度(Value)"></a>明度(Value)</h2><p>是色彩<strong>从亮到暗的明暗程度</strong>，黑色的绝对明度被定义为 0 （理想黑）,而白色的绝对明度被定义为 100 （理想白），其他系列灰色则介于两者之间。</p><h2 id="纯度-Saturation"><a href="#纯度-Saturation" class="headerlink" title="纯度(Saturation)"></a>纯度(Saturation)</h2><p>纯度通常是指色彩的<strong>鲜艳度</strong>。从科学的角度看，一种颜色的鲜艳度取决于这一色相发射光的单一程度。色彩的纯度强弱，是指色相感觉明确或含糊、鲜艳或混浊的程度。<br><img src="https://mmbiz.qpic.cn/mmbiz_png/G1micJgRNZtbYDOViadyuC0hwdkSDFKWJbciaCyWlspL3ucXzpibfQJv6lndHzajKr4FYaqicBW3IXgibYaR9Ogl99FQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"></p><h1 id="色彩空间"><a href="#色彩空间" class="headerlink" title="色彩空间"></a>色彩空间</h1><h2 id="HSB"><a href="#HSB" class="headerlink" title="HSB"></a>HSB</h2><p>在 HSB 模式中，H（Hues）表示色相，S（Saturation）表示饱和度，B（Brightness）表示亮度。</p><h2 id="RGB"><a href="#RGB" class="headerlink" title="RGB"></a>RGB</h2><p>三原色红、绿、蓝叠加最终为白色（加色模式）。常用于光源光情况下，例如显示屏幕。</p><h2 id="CMYK"><a href="#CMYK" class="headerlink" title="CMYK"></a>CMYK</h2><p>三基色洋红、黄、青叠加最终为黑色（减色模式）。常用于反射光情况下，例如印刷。</p><h2 id="LAB"><a href="#LAB" class="headerlink" title="LAB"></a>LAB</h2><p>LAB 色彩模型是由亮度（L）和有关色彩的 A，B 三个要素组成。L 表示亮度（Luminosity），A 表示从洋红色至绿色的范围，B表示从黄色至蓝色的范围。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/G1micJgRNZtbYDOViadyuC0hwdkSDFKWJb0qnt8icKpDa7O9b3tXV7KpicFImobmcp0C8HibzBUIKA9miaGoDuOvKicbg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"></p><h1 id="色彩象征"><a href="#色彩象征" class="headerlink" title="色彩象征"></a>色彩象征</h1><p><strong>1）灰⾊</strong>：正式、重⼒、成熟</p><p><strong>2）棕⾊</strong>：保守、亲切、稳定</p><p><strong>3）粉⾊</strong>：⼥性、天真、⻘春</p><p><strong>4）⻩⾊</strong>：注意、提醒、快乐</p><p><strong>5）紫⾊</strong>：奢华、浪漫、创意<br>是一种充满神秘的颜色，在自然界中较少见到，所以被引申为象征高贵的色彩。在UI设计中的应用场景为紫+粉常用于女性化的产品调性。</p><p><strong>6）⽩⾊</strong>：新鲜、清洁、健康<br>白色常常被认为是无色”即不是色彩。在UI设计中的应用场景，常用于背景色，缓和各种颜色的冲突，以衬托其他色彩，提高画面明度，提高文字可读性。</p><p><strong>7）⿊⾊</strong>：正式、权⼒、⽼练<br>是一种充满质感的颜色，它是所有色彩中最有力量的，能很快吸引用户的注意力。在UI中的应用场景，常和其他色彩百搭，比如黑色+金色，黑色+红色等等，以及现在UI设计中的暗黑模式。</p><p><strong>8）蓝⾊</strong>：信任、舒适、放松<br>纯净的蓝色通常让人联想到海洋和天空，让人的内心感到平和，有助于人的头脑变得冷静，减少工作中的烦躁和冲动。在UI设计中应用场景，常用于工具、商务、科技类等产品，B端设计也经常运用。</p><p><strong>9）绿⾊</strong>：⽣⻓、⾃然、成功<br>绿色是大自然中最常见的颜色，代表着健康、生命、青春、宁静、自然、和平、安全、舒适，是一种充满希望的颜色。在设计中的应用场景，健康、医疗、运动及少儿类产品使用较多，一般在软件中表示安全、成功。</p><p><strong>10）橙⾊</strong>：信⼼、能量、乐观<br>它烘托出的活跃气氛没有危险的感觉，反而是一种友好。<br>在UI设计中应用场景，电商、金融以及服务类的产品使用较多，比如淘宝。</p><p><strong>11）红⾊</strong>：危险、重要、激情<br>最醒目和强势的颜色，甚至能引起一些生理反应，例如心跳呼吸加快等。在UI设计中应用场景，红色常用于电商、金融、服务等行业。红色也最能烘托气氛，在中国传统节日里都使用热闹的红色来装饰，比如新年春节阶段。同时红色也代表了警示、告诫，所以在界面设计中常用红色的文字和按钮来警示用户慎重操作。</p><h1 id="Reference："><a href="#Reference：" class="headerlink" title="Reference："></a>Reference：</h1><p><a href="https://zhuanlan.zhihu.com/p/52546255">色彩搭配入门：从区分主色、辅助色、点缀色开始！ - 知乎 (zhihu.com)</a><br><a href="https://mp.weixin.qq.com/s/tcpOwSgd-BEgqkjiWptTvQ">你一定要知道的色彩知识 (qq.com)</a></p><p>0</p>]]></content>
      
      
      <categories>
          
          <category> 猎奇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 颜色美学 </tag>
            
            <tag> 色彩理论 </tag>
            
            <tag> 色彩空间 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>香水入门</title>
      <link href="/2022/10/02/xiang-shui-ru-men/"/>
      <url>/2022/10/02/xiang-shui-ru-men/</url>
      
        <content type="html"><![CDATA[<h1 id="一-简介"><a href="#一-简介" class="headerlink" title="(一)简介"></a>(一)简介</h1><p>香水是由80～90%的变性酒精为溶剂，加上各种香料调制而成。</p><h1 id="二-浓度规格"><a href="#二-浓度规格" class="headerlink" title="(二)浓度规格"></a>(二)浓度规格</h1><p>香水按香精浓度划分了五个等级：从低到高依次为：清淡香水、古龙水、淡香水、淡香精、浓香精。<br><strong>1.清淡香水</strong><br>香精含量为1%~3%，留香较短<br><strong>2.古龙水(EAU&nbsp;DE&nbsp;COLOGNE)</strong><br>简称EDC，香精含量很低，为2%-5%，持续时间1-2h。<br> <strong>3.淡香水(EAU&nbsp;DE&nbsp;TOILETTE)</strong><br>简称EDT，toilette为法语，是指梳洗打扮，可以理解为打扮的时候使用的香水，香水里最常见的浓度。香精含量为5%-10%，持续时间3-4h<br> <strong>4.淡香精(EAU&nbsp;DE&nbsp;PARFUME)</strong><br>简称EDP，又称浓香水、浓香氛、淡香精。香精含量为10-15%，留香时间5h左右<br><strong>5.香精/浓香精(PARFUME&nbsp;/&nbsp;EXTRAIT)</strong><br>香料含量最高的香水，及其稀少，属于收藏级香水，香精的用料和品质都是最高的。香精含量为15-25%，持续时间5-7h<br><strong>Tips:</strong><br>在一般人的印象中，古龙是指男性使用的香水，实际上是因为以前男性常用的香水多为古龙浓度。</p><h1 id="三-层次结构"><a href="#三-层次结构" class="headerlink" title="(三)层次结构"></a>(三)层次结构</h1><h2 id="前调-top-：0～10min"><a href="#前调-top-：0～10min" class="headerlink" title="前调(top)：0～10min"></a>前调(top)：0～10min</h2><p>香水刚喷出来酒精挥发以后（30S）所闻到的气味。前调的香料极易挥发，一般维持时间很短，10Min到30Min不等，同时中调和后调也会一起挥发，一起组成对一款香水的“<strong>初印象</strong>”。</p><h2 id="中调-middle-：2-4h"><a href="#中调-middle-：2-4h" class="headerlink" title="中调(middle)：2~4h"></a>中调(middle)：2~4h</h2><p>中调是一款香水的主题、核心。前调挥发后，中调开始显现。中调是一款香水的核心组成，是主调，一般会持续好几个小时</p><h2 id="尾调-x2F-基调-base-：4h以后"><a href="#尾调-x2F-基调-base-：4h以后" class="headerlink" title="尾调/基调(base)：4h以后"></a>尾调/基调(base)：4h以后</h2><p>香水的基调，也是我们所说的余香，挥发得最慢，香水挥发至快闻不到了、留在皮肤上的气味就是后调，是最贴肤的气味。一般有人夸你身上的味道很淡很好闻的时候，他们闻到的基本上是这个味道，因为后调的香味是最舒适、最能接受的。</p><h1 id="三-香水派别"><a href="#三-香水派别" class="headerlink" title="(三)香水派别"></a>(三)香水派别</h1><h2 id="商业香"><a href="#商业香" class="headerlink" title="商业香"></a>商业香</h2><p>指的是最常见的时装或美妆品牌推出的香水，像Prada、Dior、Burberry、这类品牌。它侧重考虑的是消费者的喜好，做出来香水消费者喜不喜欢、会不会买账，能不能卖得出去这些问题。</p><h2 id="沙龙香"><a href="#沙龙香" class="headerlink" title="沙龙香"></a>沙龙香</h2><p>区别于商业香的创作源头来自于市场需求，沙龙香源自于调香师艺术表达的需求。沙龙香是古法艺术的回归，是对调香师灵感的绝对尊重。比较小众。</p><h1 id="四-香调分类"><a href="#四-香调分类" class="headerlink" title="(四)香调分类"></a>(四)香调分类</h1><h2 id="芬芳"><a href="#芬芳" class="headerlink" title="芬芳"></a>芬芳</h2><p><strong>花香调</strong>：是最常见的香调，也是最早使用在香水中的香调。男香中使用较少，但男香中加入少量花香，能体现出男性的沉稳和大气。<br><strong>柑橘调</strong>：采用一些柑橘类水果为香调的香料<br><strong>果香调</strong>：果香调香料是所有非柑橘类水果，很多果香调的香水会选用热带水果、桃子、梨、苹果、草莓等水果的香气渲染香水。但能表达这类香气的原料特点是留香时间短，挥发性较强，给人的感觉是干净、清爽、舒服、通透、清新。<br>一般很少有单纯的果香调香水，大多用在香水的前调上。</p><h2 id="清新"><a href="#清新" class="headerlink" title="清新"></a>清新</h2><p><strong>绿叶调</strong>：以草本和绿叶散发出来的绿草香为主旋律，这种香调常常让人想起绿意盎然的森林、草地，属于清爽干净的香气，一般男性或中性的香水中使用表现在前调和中调上，相反女香中则不太会专门做绿叶调的香水，常常以绿叶调的清爽自然辅助其他香调，令人感觉沁人心脾、放松自然。<br><strong>水生调</strong>：闻起来的感觉通常是清新怡人的，比如海风的气味、湿润的空气、雨后清风吹进屋子时湿润的味道，清晨绿叶上的露珠等等。<br>Tips：香水小白最好刚开始不要买水生调的香水，容易晕香。晕香的相关问题我放在最后了。<br><strong>甘苔调</strong>：也就是西普调，西普调香水既有草木之清新、花果之甜美，亦有苔藓之浓郁也有雨后森林里的清新之感。它甜美、复杂而又神秘，最动人之处，在于那一点点复杂的难以驾驭感，是一种女性气息十足的香调。</p><h2 id="古典"><a href="#古典" class="headerlink" title="古典"></a>古典</h2><p><strong>木质调</strong>：常常出现在香水的中调和基调，木质调常用的有雪松、广藿香、檀香木、香根草等原料，这类原料气味温暖、干燥，留香时间长，也会常常与其他香调配合使用来表达不同的诉求。<br><strong>皮革调</strong>：为主导与烟草、木香、烟熏搭配，以男香居多，展现出男性的洒脱不羁、勇敢、阳刚、感性的特质。<br>皮革调在市面上感觉很少，它的接受度比较低。</p><h2 id="浓郁"><a href="#浓郁" class="headerlink" title="浓郁"></a>浓郁</h2><p><strong>东方调</strong>：是使用东方树木或辛香料、树脂、麝香等动物性香料制造而成，香甜浓郁的香气最能体现女性的性感妩媚。东方调香水具有温暖、辛辣、性感、诱惑、异域风情的特点。<br><strong>馥奇香调</strong>：带有明显的黑香豆和苔香香气，且伴有青翠的草木香韵。这一类型香调常用于男士香水，香气厚重浓郁，温暖而性感，给人以阳刚的男人味。<br><strong>美食调</strong>：这是近年来才开始流行的香调，运用了焦糖、巧克力、香草、蜂蜜、爆米花、棉花糖及各种水果创作的香调，美食调的香水具有独特的温暖香气，可以唤醒我们童年的美好回忆。适合青春无敌的小女孩，也适合童心未泯的女性。</p><h1 id="五-常见术语"><a href="#五-常见术语" class="headerlink" title="(五)常见术语"></a>(五)常见术语</h1><p><strong>1.持久度/留香时间</strong>：指香水的香味能保留的最大时间，也就是三调的香味释放完的时间，它与香水中的香精含量成正比。通常高浓度的Parfum和EDP要比低浓度的EDT、EDC留香时间更久</p><p><strong>2.扩散性</strong>：指香水在周围空气中的扩散能力，扩散性强的香水，能让人很远就能闻到，扩散性弱的香水只能紧贴皮肤才能闻到。香水中酒精的作用是帮助香精挥发，因此香精浓度较低的EDT、EDC都有较好的扩散性，但由于挥发过快，持久度则相应比较差。</p><p><strong>3.街香</strong>：指特别流行，很多人都会使用的常见香水。街香之所以能成为街香，说明香水本身很成功，味道很讨喜，大多数人都能接受。</p><p><strong>4.Flanker</strong>：指的是同系列香水、支线香水。例如Gucci&nbsp;的Bloom系列</p><p><strong>5.线性香水</strong>：指的是没有明显的前中后三调的香水，它们从头到尾只有一个味道，可能的原因：<br>（1）香水所用的原料的挥发速度差不多<br>（2）香水用的原料单一，层次感弱<br>市面上线性香不是主流产品，比较适合不喜欢香气变化，只钟情于某一种香味的人。或者如果要出席一些比较严肃不适合香水味道变化的场合，可以考虑使用线性香。</p><p><strong>6.简装香水</strong>：供给专柜用于试喷的香水。一般只有简陋的纸盒或没有盒子，甚至有些盖子也没有，瓶身上一般会标注“tester&nbsp;not&nbsp;for&nbsp;sale”</p><p><strong>7.分装香水</strong>：是指将正品香水分装至小瓶中，以少量多样的原则，供人试香。让消费者能够以较低的价格体验更多的味道，同时方便随身携带。</p><p><strong>8.散装香水</strong>：是指香水以散装的形式按毫升销售，消费者可以自由决定要多少毫升，要什么香型，用什么样的香水瓶分装。很多街边会有的香水店都是销售散装香水。</p><p><strong>9.商业香</strong>：指的是最常见的时装或美妆品牌推出的香水，像Prada、Dior、Burberry、这类品牌。它侧重考虑的是消费者的喜好，做出来香水消费者喜不喜欢、会不会买账，能不能卖得出去这些问题。</p><p><strong>10.沙龙香</strong>：区别于商业香的创作源头来自于市场需求，沙龙香源自于调香师艺术表达的需求。沙龙香是古法艺术的回归，是对调香师灵感的绝对尊重。比较小众。<br>常见的几个沙龙品牌：Jo&nbsp;Malone、Atelier&nbsp;Cologne、Diptyque、Byredo、Le&nbsp;Labo等，Jo&nbsp;Malone算是沙龙香里最商业的，其他几个牌子感觉也逐渐被大家熟知。</p><p><strong>11.小众香</strong>：就是指少见的、冷门的品牌，是相对的。</p><p><strong>12.调和香</strong>：是指由几种香味按一定比例，混合调制的香味。市面上的香水都是调和香，需要用到几十种甚至上百种香料。</p><p><strong>13.名人香水</strong>：是指某个名人用他的名字成立的香水品牌，生产的香水也即名人香水。例如碧昂斯、贝克汉姆香水等。</p>]]></content>
      
      
      <categories>
          
          <category> 猎奇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 香水 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JPEG压缩原理</title>
      <link href="/2022/10/02/jpeg-ya-suo-yuan-li/"/>
      <url>/2022/10/02/jpeg-ya-suo-yuan-li/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021529515.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021529542.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021529575.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021529611.png"></p>]]></content>
      
      
      <categories>
          
          <category> 猎奇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> JPEG压缩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2D-DCT变换（二）硬件实现</title>
      <link href="/2022/10/02/2d-dct-bian-huan-er-ying-jian-shi-xian/"/>
      <url>/2022/10/02/2d-dct-bian-huan-er-ying-jian-shi-xian/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021526576.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021526623.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021526667.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021526701.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021526727.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021526786.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021526839.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021526878.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021526906.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021526942.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021526975.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数字IC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> DCT变换 </tag>
            
            <tag> verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2D-DCT变换（一）公式推导</title>
      <link href="/2022/10/02/2d-dct-bian-huan-yi-gong-shi-tui-dao/"/>
      <url>/2022/10/02/2d-dct-bian-huan-yi-gong-shi-tui-dao/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021528034.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021528068.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数字IC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> DCT变换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电力半导体第九章笔记</title>
      <link href="/2022/10/02/dian-li-ban-dao-ti-di-jiu-zhang-bi-ji/"/>
      <url>/2022/10/02/dian-li-ban-dao-ti-di-jiu-zhang-bi-ji/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021105981.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021105008.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021105066.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021105099.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021105128.png"></p>]]></content>
      
      
      <categories>
          
          <category> 半导体器件工艺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电力半导体 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电力半导体第八章笔记</title>
      <link href="/2022/10/02/dian-li-ban-dao-ti-di-ba-zhang-bi-ji/"/>
      <url>/2022/10/02/dian-li-ban-dao-ti-di-ba-zhang-bi-ji/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021104927.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021104957.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021104997.png"></p>]]></content>
      
      
      <categories>
          
          <category> 半导体器件工艺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电力半导体 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电力半导体第七章笔记</title>
      <link href="/2022/10/02/dian-li-ban-dao-ti-di-qi-zhang-bi-ji/"/>
      <url>/2022/10/02/dian-li-ban-dao-ti-di-qi-zhang-bi-ji/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021104846.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021104871.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021104933.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021104970.png"></p>]]></content>
      
      
      <categories>
          
          <category> 半导体器件工艺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电力半导体 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电力半导体第六章笔记</title>
      <link href="/2022/10/02/dian-li-ban-dao-ti-di-liu-zhang-bi-ji/"/>
      <url>/2022/10/02/dian-li-ban-dao-ti-di-liu-zhang-bi-ji/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021102384.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021102413.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021102453.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021102497.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021102541.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021102584.png"></p>]]></content>
      
      
      <categories>
          
          <category> 半导体器件工艺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电力半导体 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电力半导体第五章笔记</title>
      <link href="/2022/10/02/dian-li-ban-dao-ti-di-wu-zhang-bi-ji/"/>
      <url>/2022/10/02/dian-li-ban-dao-ti-di-wu-zhang-bi-ji/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021100879.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021100908.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021100972.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021100008.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021100042.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021100110.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021100158.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021100188.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021100226.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021100270.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021100303.png"></p>]]></content>
      
      
      <categories>
          
          <category> 半导体器件工艺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电力半导体 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电力半导体第四章笔记</title>
      <link href="/2022/10/02/dian-li-ban-dao-ti-di-si-zhang-bi-ji/"/>
      <url>/2022/10/02/dian-li-ban-dao-ti-di-si-zhang-bi-ji/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021057289.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021057315.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021057361.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021057418.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021057450.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021057491.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021057528.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021057554.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021057587.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021057623.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021057662.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021057695.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021057729.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021057764.png"></p>]]></content>
      
      
      <categories>
          
          <category> 半导体器件工艺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电力半导体 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电力半导体第三章笔记</title>
      <link href="/2022/10/02/dian-li-ban-dao-ti-di-san-zhang-bi-ji/"/>
      <url>/2022/10/02/dian-li-ban-dao-ti-di-san-zhang-bi-ji/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021053816.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021053846.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021053883.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021053922.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021053968.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021053009.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021053033.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021053078.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021053123.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021053168.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021053207.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021053252.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021053284.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021053333.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021053380.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021053408.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021053467.png"></p>]]></content>
      
      
      <categories>
          
          <category> 半导体器件工艺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电力半导体 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电力半导体第二章笔记</title>
      <link href="/2022/10/02/dian-li-ban-dao-ti-di-er-zhang-bi-ji/"/>
      <url>/2022/10/02/dian-li-ban-dao-ti-di-er-zhang-bi-ji/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021046741.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021046279.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021046316.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021046354.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021046386.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021046411.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021046444.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021046472.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021046495.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021046524.png"></p>]]></content>
      
      
      <categories>
          
          <category> 半导体器件工艺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电力半导体 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电力半导体第一章笔记</title>
      <link href="/2022/10/02/dian-li-ban-dao-ti-di-yi-zhang-bi-ji/"/>
      <url>/2022/10/02/dian-li-ban-dao-ti-di-yi-zhang-bi-ji/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021034442.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021034477.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021034517.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021034566.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021034603.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021034656.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021034693.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021034726.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021034759.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021034802.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021034876.png"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210021034907.png"></p>]]></content>
      
      
      <categories>
          
          <category> 半导体器件工艺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电力半导体 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字集成电路第十一章笔记</title>
      <link href="/2022/10/01/shu-zi-ji-cheng-dian-lu-di-shi-yi-zhang-bi-ji/"/>
      <url>/2022/10/01/shu-zi-ji-cheng-dian-lu-di-shi-yi-zhang-bi-ji/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012332635.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012332662.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012332699.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012332761.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012332790.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012332827.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012332862.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 数字IC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字集成电路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字集成电路第十章笔记</title>
      <link href="/2022/10/01/shu-zi-ji-cheng-dian-lu-di-shi-zhang-bi-ji/"/>
      <url>/2022/10/01/shu-zi-ji-cheng-dian-lu-di-shi-zhang-bi-ji/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012330044.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012330073.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012330115.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012330154.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012330226.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012330264.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012330305.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012330346.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012330382.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012330418.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012330455.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012330495.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012330541.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012330585.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012330621.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 数字IC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字集成电路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字集成电路第九章笔记</title>
      <link href="/2022/10/01/shu-zi-ji-cheng-dian-lu-di-jiu-zhang-bi-ji/"/>
      <url>/2022/10/01/shu-zi-ji-cheng-dian-lu-di-jiu-zhang-bi-ji/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012328203.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012328233.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012328274.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012328312.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012328367.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012328403.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 数字IC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字集成电路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字集成电路第八章笔记</title>
      <link href="/2022/10/01/shu-zi-ji-cheng-dian-lu-di-ba-zhang-bi-ji/"/>
      <url>/2022/10/01/shu-zi-ji-cheng-dian-lu-di-ba-zhang-bi-ji/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012326990.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012326013.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012326054.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012326089.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012326146.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012326180.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012326219.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012326278.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012326315.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012326364.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012326397.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012326437.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012326468.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012326510.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012326545.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 数字IC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字集成电路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字集成电路第四章笔记</title>
      <link href="/2022/10/01/shu-zi-ji-cheng-dian-lu-di-si-zhang-bi-ji/"/>
      <url>/2022/10/01/shu-zi-ji-cheng-dian-lu-di-si-zhang-bi-ji/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012324749.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012324773.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012324052.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012324100.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012324133.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 数字IC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字集成电路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字集成电路第三章笔记</title>
      <link href="/2022/10/01/shu-zi-ji-cheng-dian-lu-di-san-zhang-bi-ji/"/>
      <url>/2022/10/01/shu-zi-ji-cheng-dian-lu-di-san-zhang-bi-ji/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012320441.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012320474.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012320514.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012320557.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012320604.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012320641.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 数字IC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字集成电路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字集成电路第五章笔记</title>
      <link href="/2022/10/01/shu-zi-ji-cheng-dian-lu-di-wu-zhang-bi-ji/"/>
      <url>/2022/10/01/shu-zi-ji-cheng-dian-lu-di-wu-zhang-bi-ji/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012325778.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012325799.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012325829.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012325867.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012325907.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012325953.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012325988.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012325028.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012325072.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012325111.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012325152.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012325242.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 数字IC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字集成电路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字集成电路第二章笔记</title>
      <link href="/2022/10/01/shu-zi-ji-cheng-dian-lu-di-er-zhang-bi-ji/"/>
      <url>/2022/10/01/shu-zi-ji-cheng-dian-lu-di-er-zhang-bi-ji/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012318974.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012318865.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012319327.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202210012319018.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 数字IC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字集成电路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>半导体工艺第八章笔记</title>
      <link href="/2022/09/30/ban-dao-ti-gong-yi-di-ba-zhang-bi-ji/"/>
      <url>/2022/09/30/ban-dao-ti-gong-yi-di-ba-zhang-bi-ji/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202209302344148.jpg"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202209302345772.jpg"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202209302345788.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 半导体器件工艺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 半导体工艺 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>半导体工艺第七章笔记</title>
      <link href="/2022/09/30/ban-dao-ti-gong-yi-di-qi-zhang-bi-ji/"/>
      <url>/2022/09/30/ban-dao-ti-gong-yi-di-qi-zhang-bi-ji/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202209302344701.jpg"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202209302344837.jpg"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202209302344154.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 半导体器件工艺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 半导体工艺 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>半导体工艺第六章笔记</title>
      <link href="/2022/09/30/ban-dao-ti-gong-yi-di-liu-zhang-bi-ji/"/>
      <url>/2022/09/30/ban-dao-ti-gong-yi-di-liu-zhang-bi-ji/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202209302343000.jpg"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202209302343914.jpg"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202209302343684.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 半导体器件工艺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 半导体工艺 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>半导体工艺第五章笔记</title>
      <link href="/2022/09/30/ban-dao-ti-gong-yi-di-wu-zhang-bi-ji/"/>
      <url>/2022/09/30/ban-dao-ti-gong-yi-di-wu-zhang-bi-ji/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202209302342870.jpg"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202209302342907.jpg"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202209302342208.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 半导体器件工艺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 半导体工艺 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>半导体工艺第四章笔记</title>
      <link href="/2022/09/30/ban-dao-ti-gong-yi-di-si-zhang-bi-ji/"/>
      <url>/2022/09/30/ban-dao-ti-gong-yi-di-si-zhang-bi-ji/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202209302342219.jpg"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202209302342079.jpg"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202209302342816.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 半导体器件工艺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 半导体工艺 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>半导体工艺第三章笔记</title>
      <link href="/2022/09/30/ban-dao-ti-gong-yi-di-san-zhang-bi-ji/"/>
      <url>/2022/09/30/ban-dao-ti-gong-yi-di-san-zhang-bi-ji/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202209302340315.jpg"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202209302340203.jpg"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202209302340734.jpg"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202209302341954.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 半导体器件工艺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 半导体工艺 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>半导体工艺第二章笔记</title>
      <link href="/2022/09/30/ban-dao-ti-gong-yi-di-er-zhang-bi-ji/"/>
      <url>/2022/09/30/ban-dao-ti-gong-yi-di-er-zhang-bi-ji/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202209302336093.jpg"><br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/2.2.jpg"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202209302337934.jpg"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202209302337834.jpg"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202209302337937.jpg"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202209302337141.jpg"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202209302337116.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 半导体器件工艺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 半导体工艺 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>半导体工艺第一章笔记</title>
      <link href="/2022/09/30/ban-dao-ti-gong-yi-di-yi-zhang-bi-ji/"/>
      <url>/2022/09/30/ban-dao-ti-gong-yi-di-yi-zhang-bi-ji/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202209302248182.jpg"></p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202209302248815.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 半导体器件工艺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 半导体工艺 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>车规芯片(一）汽车功能安全概述</title>
      <link href="/2022/09/29/che-gui-xin-pian-yi-qi-che-gong-neng-an-quan-gai-shu/"/>
      <url>/2022/09/29/che-gui-xin-pian-yi-qi-che-gong-neng-an-quan-gai-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="汽车安全的必要性"><a href="#汽车安全的必要性" class="headerlink" title="汽车安全的必要性"></a>汽车安全的必要性</h1><p>随着汽车智能化和电气化技术的快速普及，车内控制器和各种电子部件越来越多，而各类电子部件都存在系统性失效和随机硬件失效的风险，因此相应的汽车功能安全变得越来越重要。</p><h1 id="汽车安全分类"><a href="#汽车安全分类" class="headerlink" title="汽车安全分类"></a>汽车安全分类</h1><p>==汽车安全主要包括碰撞安全、高压安全、功能安全、信息安全、使用安全几大分类==。<br>而车规功能安全重点关注车辆电子电气失效导致对人的伤害。<br>功能安全针对的是车辆一个或者多个电子电气相关系统的故障行为而引起的可能的危害</p><h1 id="电子系统失效分类"><a href="#电子系统失效分类" class="headerlink" title="电子系统失效分类"></a>电子系统失效分类</h1><p>电子系统失效的分类分成==系统性失效==和==随机失效==两大类。</p><ul><li>系统性失效具体指人为的失效。它主要由严格的开发流程和独立的评估体系来管理和防止。</li><li>随机失效指的是硬件中电子部件特别是芯片在生命周期中无法预测的失效。芯片的随机失效在&nbsp;ISO26262标准中主要依托&nbsp;IEC62380和西门子&nbsp;SN29500这两个参考标准用&nbsp;FIT来量化。特别是数字芯片当其使用的==逻辑门超过&nbsp;5千万级别、&nbsp;RAM超过&nbsp;2G或&nbsp;Flash超过&nbsp;1G时==，失效率将达到&nbsp;200FIT以上。因此需要通过安全机制去检测故障和满足量化安全指标的难度大大提高。</li></ul><p>注：1 FIT（失效率，failures in time）指的是1个（单位）的产品在1×10^9小时内出现1次失效（或故障）的情况。</p><h1 id="ISO26262"><a href="#ISO26262" class="headerlink" title="ISO26262"></a>ISO26262</h1><p>在汽车电子行业，功能安全国际标准ISO 26262 是汽车行业的安全标准，涵盖了生产车辆中的电气和电子系统。功能安全国际标准ISO26262和对应国标GB/T34590将功能安全定义为：避免因电子电气系统故障而导致不合理的风险。即随机硬件失效和系统性失效不会导致安全系统的错误功能，从而导致人的伤害死亡，或环境污染，或设备财产损失等。</p><ul><li>ISO26262的由来<br>在1900年代后期，化工厂造成了大规模事故，例如意大利的塞维索事故和印度的博帕尔事故</li><li>功能安全的目的是”将风险降低到可接受的水平”<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202209292223517.png" alt="风险分类|600"></li></ul><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202209292225099.png" alt="Asil等级|600"><br>ISO26262的特殊之处在于它不仅提供标准通常规范的行为准则，而且对可接受的风险提出如何去量化的指导意见。</p><h1 id="汽车安全完整性等级"><a href="#汽车安全完整性等级" class="headerlink" title="汽车安全完整性等级"></a>汽车安全完整性等级</h1><ul><li>ISO 26262标准使用==汽车安全完整性等级 (ASIL A–D) ==来衡量风险。 </li><li>等级划分：ASIL共分五个等级QM，ASIL-A，B，C和D。ASIL D代表最高的汽车危害等级，而ASIL A代表最低的汽车危害等级。还有一个称为QM（质量管理级别）的级别，它表示不要求任何安全要求的危害。ASIL-D代表最高的汽车功能安全要求。</li></ul><p>以&nbsp;ASIL-D为例，它的单点故障指标要求被安全机制覆盖超过&nbsp;99%，而多点故障指标要求被安全机制覆盖超过&nbsp;90%。标准还额外对残余故障的失效率做出规定，&nbsp;ASIL-B和&nbsp;C要求小于&nbsp;100FIT，而&nbsp;ASIL-D更严苛地要求小于&nbsp;10FIT。</p><p>安全气囊，防抱死制动和动力转向等系统需要ASIL-D级（对安全性要求最高的严格性），因为与故障相关的风险最高。在安全范围的另一端，诸如尾灯之类的组件仅需要ASIL-A级。前大灯和刹车灯通常为ASIL-B，而巡航控制系统通常为ASIL-C。</p><p>ASIL根据伤害的严重性S、可能性E和可控性C来确定安全要求。它的具体定级需要通过==HARA危害分析风险评估==来确定。</p><h1 id="HARA危害分析风险评估"><a href="#HARA危害分析风险评估" class="headerlink" title="HARA危害分析风险评估"></a>HARA危害分析风险评估</h1><p>==HARA==（Hazard Analysis and Risk Assessment）是指危害分析和风险评估。危害分析：危险分析是整个过程的第一步，用来评估风险的ASIL等级。危险分析的目的是确定ASIL水平和所需的安全状态。风险评估（包含两方面）：危害识别：识别可能造成危害的危害和风险因素。风险分析和评估：通过S、E和C分析和评估与该风险相关的风险。</p><p>汽车功能安全HARA危害分析风险评估：<br>严重性S：S0<del>S3，表示人员可能造成伤害的级别。<br>可能性E：E0</del>E4，表示这个风险在实际应用中发生的概率。<br>可控性C：C0~C3，表示这个风险发生后人员采取措施控制后可以避免伤害的能力。<br>通过HARA分析，确定安全目标、安全状态、FTTI故障容错时间间隔和ASIL等级。</p><p><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202209300840698.png" alt="HARA参数分析|500"></p><ul><li>S3，E4和C3（3个参数的极值）的组合表示高度危险的情况。因此，被评估的组件被标识为ASIL D，这意味着在发生故障的情况下容易发生严重威胁生命的事件，并要求采取最严格的安全措施。</li><li>相反，S1，E1和C1的组合（就安全性至关紧要而言，这三个参数的最低水平）要求QM级别，这意味着该组件是无害的，并且不强调要在安全性要求下管理的安全要求ISO 26262。</li><li>同样，中级水平（S2，E4和C3或S2，E3和C2）的组合定义了ASIL C或ASILA。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数字IC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 功能安全仿真 </tag>
            
            <tag> 车规芯片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SystemVerilog学习笔记(四)</title>
      <link href="/2022/09/25/systemverilog-xue-xi-bi-ji-si/"/>
      <url>/2022/09/25/systemverilog-xue-xi-bi-ji-si/</url>
      
        <content type="html"><![CDATA[<h1 id="1-验证环境结构"><a href="#1-验证环境结构" class="headerlink" title="1. 验证环境结构"></a>1. 验证环境结构</h1><h2 id="1-1-测试平台"><a href="#1-1-测试平台" class="headerlink" title="1.1 测试平台"></a>1.1 测试平台</h2><p>测试平台(testbench)是整个验证系统的总称。</p><ul><li>包括验证结构中的各个组件、组件之间的连接关系、测试平台的配置和控制。<ul><li>从更系统的意义来讲，它还包括编译仿真的流程、结果分析报告和覆盖率检查等。</li><li>从狭义上讲，我们主要关注验证平台的结构和组件部分，他们可以产生设计所需要的各种输入，也会在此基础上进行设计功能的检查。</li></ul></li><li>测试平台结构图<div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211211657013.png " width="60%" height="60%"></div>  * 各个组件之间是相互独立的  * 验证组件与设计之间需要连接  * 验证组件之间也需要进行通信  * 验证环境也需要时钟和复位信号的驱动</li><li>验证语言<ul><li>SystemVerilog的使用比例明显占据主导地位。</li><li>SystemC和C/C++在验证部分也有其应用空间。</li><li>方法学(UVM)的统一已经完成。</li></ul></li></ul><h1 id="2-验证环境组件"><a href="#2-验证环境组件" class="headerlink" title="2. 验证环境组件"></a>2. 验证环境组件</h1><h2 id="2-1-激励发生器"><a href="#2-1-激励发生器" class="headerlink" title="2.1 激励发生器"></a>2.1 激励发生器</h2><ul><li>概念<br>Stimulator(激励发生器）是验证环境的重要部件，在一些场合中，它也被称为driver (驱动器)、BFM(bus functionmodel，总线功能模型), behavioral(行为模型)或者generator(发生器)。</li><li>主要职责<br>Stimulator的主要职责是<strong>模拟与DUT相邻设计的接口协议</strong>。Stimulator不应该违反协议，但不拘束于真实的硬件行为，还可以给出更多丰富的只要协议允许的激励场景。</li><li>接口<br>Stimulator的接口主要是同DUT之间连接<br>较精细的stimulator还可以有其它的配置接口用来控制接口的数据生成。<br>Stimulatort也可以有存储接口数据生成历史的功能。</li><li>分类<ul><li>initiator (发起器)</li><li>responder(响应器)</li></ul></li></ul><h2 id="2-2-检测器"><a href="#2-2-检测器" class="headerlink" title="2.2 检测器"></a>2.2 检测器</h2><ul><li>主要功能<br>Monitor(监测器)的主要功能是用来观察DUT的边界或者内部信号<ul><li>观察DUT边界信号。<br>  对于系统信号如时钟，可以监测其频率变化;对于总线信号，可以监测总线的传输类型和数据内容，以及检查总线时序是否符合协议。</li><li>观察DUT内部信号。<br>  从灰盒验证的手段来看，往往需要探视DUT内部信号，用来指导stimulator的激励发送，或者完成覆盖率收集，又或者完成内部功能的检查。</li></ul></li></ul><h2 id="2-3-比较器"><a href="#2-3-比较器" class="headerlink" title="2.3 比较器"></a>2.3 比较器</h2><ul><li>主要功能<br>模拟设计行为和功能检查</li><li>比较方式<ul><li>线上比较(online check)<br>  在仿真时收集数据和在线比较，并且实时报告。</li><li>线下比较(offline check)<br>  将仿真时收集到的数据记录在文件中，在仿真结束后，通过脚本或者其它手段，进行数据比较。</li></ul></li></ul><h2 id="2-4-任务和函数"><a href="#2-4-任务和函数" class="headerlink" title="2.4 任务和函数"></a>2.4 任务和函数</h2><h3 id="2-4-1-任务Task"><a href="#2-4-1-任务Task" class="headerlink" title="2.4.1 任务Task"></a>2.4.1 任务Task</h3><ul><li>任务的定义可以指定参数，input、output、inout及ref皆可。</li><li>任务可以消耗仿真时间。</li><li>任务可以调用其它任务或者函数。</li><li>虽然task不会返回值，但是我们依然可以利用return来使task结束。<br><strong>不使用return</strong>：</li></ul><pre class=" language-systemverilog"><code class="language-systemverilog">`timescale 1ns/1psmodule test;  task mytask(input [7:0] x                  ,input [7:0] y                  ,output [15:0] z);  #5ns;  z = x*y - 1;  #5ns;  endtask    byte unsigned a = 3 ;    byte unsigned b = 4 ;    byte unsigned c;  initial begin    mytask(a,b,c);    repeat(5)begin      #1ns;      $display("@time %t c = %0d", $time, c);  end  endendmodule返回结果time  11000 c=11time  12000 c=11time  13000 c=11time  14000 c=11time  15000 c=11</code></pre><p><strong>使用return</strong>:</p><pre class=" language-systemverilog"><code class="language-systemverilog">`timescale 1ns/1psmodule test;  task mytask(input [7:0] x                  ,input [7:0] y                  ,output [15:0] z);  #5ns;  z = x*y - 1;  return;  #5ns;  endtask    byte unsigned a = 3 ;    byte unsigned b = 4 ;    byte unsigned c;  initial begin    mytask(a,b,c);    repeat(5)begin      #1ns;      $display("@time %t c = %0d", $time, c);  end  endendmodule返回结果time  6000 c=11time  7000 c=11time  8000 c=11time  9000 c=11time  10000 c=11</code></pre><h3 id="2-4-2-函数Funnction"><a href="#2-4-2-函数Funnction" class="headerlink" title="2.4.2 函数Funnction"></a>2.4.2 函数Funnction</h3><ul><li>参数方向声明<br>参数方向可声明为input、output、inout、ref，默认input类型。</li><li>函数返回方式<ul><li>可以使用return直接返回值<br>  return会立即返回</li><li>可以将值赋给与函数同名的变量<br>  赋值给函数同名变量后将继续执行后续代码。</li></ul></li><li>代码示例</li></ul><pre class=" language-systemverilog"><code class="language-systemverilog">module test;  function automatic void myfunc1 (input [7:0] x                                  ,input [7:0] y                                  ,output [15:0] z);  z = x*y - 1;  endfunction  function [15:0] myfunc2 (input [7:0] x                          ,input [7:0] y);  myfunc2 = x*y - 1;  endfunction  initial begin    byte unsigned a = 3 ;    byte unsigned b = 4 ;    byte unsigned c1 , c2;    myfunc1(a,b,c1);    $display("c = %0d" , c1);    c2 = myfunc2(a , b);    $display("c = %0d" , c2);  endendmodule返回结果：c = 11c = 11</code></pre><h3 id="2-4-3-任务和函数的区别"><a href="#2-4-3-任务和函数的区别" class="headerlink" title="2.4.3 任务和函数的区别"></a>2.4.3 任务和函数的区别</h3><p><strong>仿真时间</strong>：function不会消耗仿真时间，而task则可能会消耗仿真时间。<br><strong>调用</strong>：function无法调用task，而task可以调用function。<br><strong>数据返回</strong>：一个可以返回数据的function只能返回一个单─数值，而任务或者void function不会返回数值。一个可以返回数据的function可以作为一个表达式中的操作数，而该操作数的值即function的返回值。</p><h2 id="2-5-参数传递"><a href="#2-5-参数传递" class="headerlink" title="2.5 参数传递"></a>2.5 参数传递</h2><ul><li>参数默认方向<br>参数方向可声明为input、output、inout、ref，<strong>默认input类型</strong>。</li><li>默认数据类型<br>若没有声明数据类型，<strong>默认为1位宽的logic</strong>。</li><li>参数默认值*<br>带有参数默认值的方法被调用时，如果这些参数没有被传递值，那么编译器将会为这些参数传入对应的默认值。<div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211211657429.png " width="60%" height="60%"></div></li><li>参数与传递方式<ul><li>位置调用  <div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211211658865.png " width="60%" height="60%"></div></li><li>名字调用  <div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211211658908.png " width="60%" height="60%"></div></li></ul></li></ul><h1 id="3-问答题："><a href="#3-问答题：" class="headerlink" title="3. 问答题："></a>3. 问答题：</h1><ul><li>激励器(stimulator)对于它所生成的激励，有什么办法将其所有激励数据保存下来?<br>  Stimulatort也可以有存储接口数据生成历史的功能。</li><li>function和task的比较?<br>  <strong>仿真时间</strong>：function不会消耗仿真时间，而task则可能会消耗仿真时间。<br>  <strong>调用</strong>：function无法调用task，而task可以调用function。<br>  <strong>数据返回</strong>：一个可以返回数据的function只能返回一个单─数值，而任务或者void function不会返回数值。一个可以返回数据的function可以作为一个表达式中的操作数，而该操作数的值即function的返回值。</li><li>参数方向有哪些?差别在哪里?<br>  参数方向可声明为input、output、inout、ref，<strong>默认input类型</strong><ul><li><strong>input</strong>：输入端口</li><li><strong>output</strong>：输出端口</li><li><strong>inout</strong>：双向连接端口</li><li><strong>ref</strong>：input，output，inout作为参数传递的过程中是作为参数值传递的，数据在调用过程中均需要被复制。而ref参数传递的则为传递参数的引用地址，参数的传递方式指定为引用而不是复制，比input，output和inout更好用。可以把数组传递给子程序，在任务里可以修改变量而且修改结果对调用他的函数是可见的。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数字IC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字前端 </tag>
            
            <tag> SystemVerilog验证 </tag>
            
            <tag> 任务函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/09/24/hello-world/"/>
      <url>/2022/09/24/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SV课程中使用的虚拟机命令</title>
      <link href="/2022/09/21/sv-ke-cheng-zhong-shi-yong-de-xu-ni-ji-ming-ling/"/>
      <url>/2022/09/21/sv-ke-cheng-zhong-shi-yong-de-xu-ni-ji-ming-ling/</url>
      
        <content type="html"><![CDATA[<ul><li>pwd</li><li>mkdir project</li><li>cd project</li><li>cp -rf /mnt/hgfs/ShareFolder/v0.labs(文件名) .</li><li>ll</li><li>gvim &amp; 保持不在后台运行<br>  vim编辑器中敲入VT</li><li>cp V0_lab/rtl/router.v w2lab/</li><li>cp V0_lab/rtl/router.v w3lab/</li><li>vcs -full64 router.v -top router<br>  编译设计文件<br>  -full64：vcs版本为64位<br>  -top router：顶层文件为router</li><li>history</li><li>vcs -full64 -debug_access+all router.v -top router<br>  -debug_access+all：添加相关调试选项</li><li>./simv -gui &amp;<br>  ./：表示在当前目录下有simv文件<br>  -gui:表示以图形界面方式展示</li><li>touch tb.sv</li><li>vcs -full64 -debug_access+all -sverilog -timescale=1ns/1ps router.v tb.sv -top tb<br>  -sverilog：为识别sv文件<br>  -timescale=1ns/1ps 所有design、tb文件统一timescale</li><li>vsim -gui &amp; 打开queata工具<ul><li>vlog -sv xxx.sv在questa中编译xxx.sv</li><li>vsim -voptargs=+acc -classdebug work.tb 仿真work中的tb文件</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数字IC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字前端 </tag>
            
            <tag> SystemVerilog验证 </tag>
            
            <tag> 虚拟机命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SystemVerilog学习笔记(三)</title>
      <link href="/2022/09/19/systemverilog-xue-xi-bi-ji-san/"/>
      <url>/2022/09/19/systemverilog-xue-xi-bi-ji-san/</url>
      
        <content type="html"><![CDATA[<h1 id="1-设计特性"><a href="#1-设计特性" class="headerlink" title="1. 设计特性"></a>1. 设计特性</h1><h2 id="1-1-面向可综合设计的主要优化"><a href="#1-1-面向可综合设计的主要优化" class="headerlink" title="1.1 面向可综合设计的主要优化"></a>1.1 面向可综合设计的主要优化</h2><h3 id="1-1-1-过程语句块新特性"><a href="#1-1-1-过程语句块新特性" class="headerlink" title="1.1.1 过程语句块新特性"></a>1.1.1 过程语句块新特性</h3><p>always语句块被细分为了:</p><ul><li><strong>组合逻辑语句块always_comb</strong><ul><li>always_comb可以自动嵌入敏感列表。</li><li>always_comb可以禁止共享变量，即赋值左侧的变量无法被另一个过程块所赋值。</li><li>软件工具会检查该过程块，如果其所表示的不是组合逻辑，那么会发出警告。</li><li>always_comb在仿真0时刻会自动触发一次，无论在0时刻是否有敏感信号列表中的信号发生变化。</li><li>与Verilog @* 的敏感列表声明方式不同处<ul><li>@* 不要求可综合的建模要求，但always_comb则会限制其他过程块对同一变量进行赋值。</li><li>@* 的敏感列表可能不完全，@* 只会将该函数的形式参数自动声明到敏感列表，而不会将该函数展开。</li><li>always_comb则将被调用函数中可能参与运算的其它信号也声明到敏感列表中。<div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211211652671.png " width="50%" height="50%"></div></li></ul></li></ul></li><li><strong>锁存逻辑语句块always_latch</strong><ul><li>always latch表示锁存逻辑，且自动插入敏感列表。</li><li>EDA工具会检查always_latch过程块是否真正实现了锁存逻辑。<div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211211652701.png " width="50%" height="50%"></div></li></ul></li><li><strong>时序逻辑语句块always_ff</strong><ul><li>always_ff用来表示时序逻辑。</li><li>敏感列表必须指明posedge或者negedge(综合要求)，从而使得EDA工具实现同步或者异步的复位逻辑。</li><li>EDA工具也会验明always_ff过程块语句是否实现了时序逻辑。</li></ul></li></ul><h3 id="1-1-2-赋值操作符"><a href="#1-1-2-赋值操作符" class="headerlink" title="1.1.2 赋值操作符"></a>1.1.2 赋值操作符</h3><ul><li>SV可以通过’0，’1，’z和′x来分别填充0，1，z和x。</li><li>SV在比较数据时，可以通过== ?来进行通配比较。在比较操作符的右侧操作数，如果在某些位置有X或者Z，那么它表示的是在该位置上会与左侧操作数的相同位置的任何值相匹配。<div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211211653920.png " width="60%" height="60%"></div></li><li>SV添加了inside操作符，用来检查数值是否在一系列值的集合当中。<div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211211653179.png " width="50%" height="50%"></div></li></ul><h3 id="1-1-3-增强的case与语句"><a href="#1-1-3-增强的case与语句" class="headerlink" title="1.1.3 增强的case与语句"></a>1.1.3 增强的case与语句</h3><p>仿真和综合可以会将case语句做不同的翻译。Verilog定义case语句在执行时按照优先级，而综合编译器则会优化case语句中多余的逻辑。为了保持仿真与综合的一致性，SV提供了<strong>unique</strong>和<strong>priority</strong>的声明，结合case,casex和casez来进一步实现case对应的硬件电路。</p><ul><li><strong>unique case</strong><ul><li>unique case要求每次case选择必须只能满足一条case选项</li><li>unique case不能有重叠的选项，即多个满足条件的选项<div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211211654619.png " width="60%" height="60%"></div></li><li>unique case可以并行执行，并且case选项必须完备<div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211211655398.png " width="60%" height="60%"></div></li></ul></li><li><strong>priority case</strong><ul><li>priority case则表示必须至少有一个case选项满足要求。如果有多个case选项满足时，第一个满足的分支将会被执行</li><li>priority case的逻辑同if..else的逻辑一致。</li></ul></li></ul><h1 id="2-接口"><a href="#2-接口" class="headerlink" title="2. 接口"></a>2. 接口</h1><p>SV添加了新的抽象端口类型interface。interface允许多个信号被整合到一起用来表示一个单一的抽象端口。多个模块因此可以使用同一个interface，继而避免分散的多个端口信号连接。</p><h2 id="2-1-接口的内容"><a href="#2-1-接口的内容" class="headerlink" title="2.1 接口的内容"></a>2.1 接口的内容</h2><ul><li>接口不单单可以包含变量或者线网，它还可以封装模块之间通信的协议。</li><li>接口中可以嵌入与协议有关的断言检查、功能覆盖率收集等模块。</li><li>接口不同于模块(module)的地方在于，接口不允许包含设计层次，即接口无法例化module，但是接口可以例化接口。</li><li>接口中可以进一步声明modport来约束不同模块连接时的信号方向。</li></ul><h2 id="2-2-接口的声明"><a href="#2-2-接口的声明" class="headerlink" title="2.2 接口的声明"></a>2.2 接口的声明</h2><ul><li>接口的定义同模块定义类似。</li><li>接口也可以有端口，例如外部接入的时钟或者复位信号。</li><li>接口内部可以声明所有的变量或者线网类型。</li></ul><h2 id="2-3-接口的例化"><a href="#2-3-接口的例化" class="headerlink" title="2.3 接口的例化"></a>2.3 接口的例化</h2><ul><li>接口的例化方式同模块例化一致。</li><li>模块的端口如果声明为input、output或者inout，那么在例化时可以不连接。</li><li>模块的端口如果声明为interface，那么在例化时则必须连接到一个接口实例，或者另外一个接口端口。</li><li>如果一个模块拥有一个接口类型端口，那么要索引该接口中的信号，需要通过以下方式进行:</li></ul><pre class=" language-systemverilog"><code class="language-systemverilog"><port_name>.<internal_interface_signal_name>always @(posedge bus.clock , negedge bus.resetN)</code></pre><h2 id="2-4-modport"><a href="#2-4-modport" class="headerlink" title="2.4 modport"></a>2.4 modport</h2><ul><li>接口中的变量或者线网信号，对于连接到该接口的不同模块则可能具备这不同的连接方向。接口引入了modport来作为module port的缩写，表示不同的模块看到同一组信号时的视角(连接方向)。</li><li>在接口中声明modport，需要指明modport中各个信号的方向。</li><li>当一个模块在例化时，可以选择连接到interface端口中具体的某一个modport。这种方式可以降低方向连接错误的可能，进而避免信号多驱动的情况。</li></ul><h1 id="3-问答题"><a href="#3-问答题" class="headerlink" title="3. 问答题"></a>3. 问答题</h1><p><strong>1.结构体和接口之间的联系和差别有哪些地方?</strong><br><strong>答</strong>：<br><strong>同</strong>：①均可以声明变量或线网类型；②结构体同样可以集合一些变量<br><strong>异</strong>：结构体中不能指定信号方向，接口中用modport来约束不同模块连接时的信号方向。</p><hr><p><strong>2.模块和接口之间的相近的地方有哪些?又有哪些差别?</strong><br><strong>答</strong>：<br><strong>同</strong>：①接口的定义同模块定义类似；②接口的例化方式同模块例化一致；③均可以声明变量或线网类型。<br><strong>异</strong>：①接口不同于模块(module)的地方在于，接口不允许包含设计层次，即接口无法例化module，但是接口可以例化接口。②接口中可以进一步声明modport来约束不同模块连接时的信号方向。③接口不单单可以包含变量或者线网，它还可以封装模块之间通信的协议。④接口中还可以嵌入与协议有关的断言检查、功能覆盖率收集等模块。</p><hr><p><strong>3.将DUT, Interface,TB在顶层连接起来时，要完成哪些步骤?</strong><br><strong>答</strong>：①声明变量；②例化Interface，TB，DUT；③将TB，DUT与Interface连接；</p>]]></content>
      
      
      <categories>
          
          <category> 数字IC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字前端 </tag>
            
            <tag> SystemVerilog验证 </tag>
            
            <tag> 接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机常见命令</title>
      <link href="/2022/09/13/xu-ni-ji-chang-jian-ming-ling/"/>
      <url>/2022/09/13/xu-ni-ji-chang-jian-ming-ling/</url>
      
        <content type="html"><![CDATA[<h2 id="1）pwd命令"><a href="#1）pwd命令" class="headerlink" title="1）pwd命令"></a>1）pwd命令</h2><ul><li><strong>作用</strong>：显示当前所在的工作目录【显示所在的位置】</li><li><strong>格式</strong>：直接执行pwd即可</li></ul><hr><h2 id="2）cd命令"><a href="#2）cd命令" class="headerlink" title="2）cd命令"></a>2）cd命令</h2><ul><li><strong>作用</strong>：切换目录</li><li><strong>格式</strong>：cd &nbsp;目标</li></ul><blockquote><p>举例</p><p>#1 切换到根目录<br>cd /</p><p>#2 切换到home目录<br>cd /home</p><p>#3 切换到tmp目录<br>cd /tmp</p><p>#4 切换到/etc/sysconfig<br>cd /etc/sysconfig</p><p>#5 切换到上一级目录<br>cd ..</p><p>#6 切换上次所在的目录<br>cd -</p></blockquote><hr><h2 id="3）ls命令"><a href="#3）ls命令" class="headerlink" title="3）ls命令"></a>3）ls命令</h2><ol><li><strong>作用</strong>：查看目录下有哪些文件</li><li><strong>格式</strong>：ls &nbsp;[选项] &nbsp;[路径]<br><strong>3.路径</strong>：</li></ol><ul><li>在执行命令的时候，如果不指定路径，则查看的是当前目录下的文件；如果指定路径，则查看指定路径下的文件<br><strong>4.选项：</strong></li><li>-l：显示文件的属性</li><li>-a：显示所有的文件，包括隐藏文件【linux默认是不会显示隐藏文件的】</li></ul><blockquote><p>举例</p><p>#1 查看当前位置下有哪些文件<br>ls</p><p>#2 查看etc下有哪些文件<br>方法1：先切换到etc下，然后执行ls<br>[root@localhost home]# cd /etc<br>[root@localhost etc]# ls</p><p>方法2：在执行ls的时候，指定路径<br>[root@localhost home]# ls /etc</p><p>#3 查看根下有哪些文件<br>方法1：<br>[root@localhost home]# cd /<br>[root@localhost /]# ls</p><p>方法2：<br>[root@localhost home]# ls /</p><p>#4 查看home目录下的所有的文件的文件名<br>[root@localhost /]# ls /home</p><p>#5 查了根目录下所有文件的属性，包括隐藏文件<br>[root@localhost /]# ls -al /  &nbsp;</p></blockquote><p><strong>补充知识1：</strong>linux中，文件的类型主要有两种</p><ul><li>一般文件：通常是可以进行内容写入和编辑的文件，例如windows中的doc、txt</li><li>目录文件：其实就是文件夹</li></ul><p><strong>补充知识2：</strong>Linux中，文件的后缀对与文件的属性没有任何影响</p><ul><li>文件的属性仅仅和创建这个文件的命令相关<hr><h2 id="4）touch命令"><a href="#4）touch命令" class="headerlink" title="4）touch命令"></a>4）touch命令</h2><strong>作用</strong>：创建空白一般文件</li></ul><p>&nbsp; &nbsp; &nbsp; &nbsp;<strong>格式</strong>：</p><blockquote><p>格式1：touch &nbsp;文件名 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 在当前位置下创建文件<br>格式2：touch &nbsp;/路径/文件名 &nbsp; &nbsp; &nbsp;# 在指定的位置下创建文件</p></blockquote><blockquote><p><strong>例子</strong>：</p><p>#1 创建文件qq.txt<br>[root@localhost home]# touch qq.txt</p><p>#2 在tmp下创建qq.txt<br>方法1：先切换到tmp下，然后创建<br>[root@localhost home]# cd /tmp<br>[root@localhost tmp]# touch qq.txt</p><p>方法2：[root@localhost home]# touch /tmp/qq.txt</p><p>#3 解释下面的命令<br>touch &nbsp;baidu.txt &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 在当前位置下创建baidu.txt<br>touch &nbsp;/baidu.txt &nbsp; &nbsp; &nbsp; &nbsp; # 在根下创建baidu.txt<br>touch &nbsp;/home/baidu.txt &nbsp; &nbsp;# 在home下创建baidu.txt</p></blockquote><hr><h2 id="5）mkdir命令"><a href="#5）mkdir命令" class="headerlink" title="5）mkdir命令"></a>5）mkdir命令</h2><p><strong>作用</strong>：创建目录【创建文件夹】</p><p><strong>格式</strong>：</p><blockquote><p>格式1：mkdir&nbsp; [选项]   目录名<br>格式2：mkdir &nbsp;[选项] &nbsp; /路径/目录名</p></blockquote><p><strong>选项：</strong></p><ul><li>-p：在父目录不存在的情况下，先创建父目录，然后依次创建子目录</li></ul><blockquote><p>举例：</p><p>#1 创建目录book1<br>mkdir &nbsp;book1</p><p>#2 在home下创建目录book2<br>方法1：先切换，在创建<br>cd /home<br>mkdir book2</p><p>方法2：<br>mkdir /home/book2</p><p>#3 在根下创建目录book3<br>mkdir /book3</p><p>#4 创建一组文件夹d1/d2/d3/d4<br>方法1：逐个创建<br>mkdir d1<br>mkdir d1/d2<br>mkdir d1/d2/d3<br>mkdir d1/d2/d3/d4</p><p>方法2：逐个创建<br>mkdir -p d1/d2/d3/d4</p></blockquote><hr><p><strong>6）clear命令</strong></p><p><strong>作用</strong>：清屏</p><p><strong>快捷键</strong>：ctrl+l</p><hr><h2 id="7）cp命令"><a href="#7）cp命令" class="headerlink" title="7）cp命令"></a>7）cp命令</h2><p><strong>作用</strong>：复制文件和目录<br><strong>格式</strong>：</p><blockquote><p>格式1：cp &nbsp;[选项] &nbsp;源文件 &nbsp;目标位置 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 复制过去后，名字不变<br>格式2：cp &nbsp;[选项] &nbsp;源文件 &nbsp;目标位置/新名字 &nbsp; &nbsp; 复制过去后，名字改为新的</p></blockquote><p><strong>选项</strong>：</p><ul><li>-r：用于复制目录【必须用-r，才能复制目录】</li><li>-a：在复制过程中，保持文件的属性不变</li></ul><blockquote><p>举例：</p><p>#1 将/etc/passwd 复制到home下<br>[root@localhost tmp]# cp /etc/passwd /home/</p><p>#2 将/etc/passwd 复制到根下<br>[root@localhost tmp]# cp /etc/passwd &nbsp;/</p><p>#3 将/etc/passwd 复制到home下，复制后的名字变成qq<br>[root@localhost tmp]# cp /etc/passwd /home/qq</p><p>#4 将tmp下的目录d1复制到home下【d1是前面的例子中创建的】<br>[root@localhost tmp]# cp &nbsp;-a &nbsp;/tmp/d1 &nbsp;/home/</p></blockquote><h2 id="8）mv命令"><a href="#8）mv命令" class="headerlink" title="8）mv命令"></a>8）mv命令</h2><p><strong>作用</strong>：移动文件和目录<br><strong>格式：</strong></p><blockquote><p><strong>mv &nbsp;源文件 &nbsp;目标位置<br>mv &nbsp;原文件 &nbsp;目标位置/新名字</strong></p></blockquote><blockquote><p>举例</p><p>#1 在home下新建一个测试文件，t.txt<br>[root@localhost tmp]# touch /home/t.txt</p><p>#2 将上例中的t.txt移动到根下<br>[root@localhost tmp]# mv /home/t.txt /</p><p>#3 将上例中的t.txt移动到根下，并改名为tt.txt<br>[root@localhost tmp]# mv /home/t.txt /tt.txt</p><p>#4 将根下的tt.txt 改名为ttt.txt【原地改名】<br>[root@localhost tmp]# mv &nbsp;/tt.txt &nbsp;/ttt.txt</p></blockquote><hr><h2 id="9）rm命令"><a href="#9）rm命令" class="headerlink" title="9）rm命令"></a>9）rm命令</h2><p><strong>作用</strong>：删除文件</p><p><strong>格式</strong>：</p><blockquote><p>格式1：rm &nbsp;[选项] &nbsp;文件<br>格式2：rm &nbsp;[选项] &nbsp;路径/文件</p></blockquote><p><strong>选项</strong>：</p><ul><li><p>-r：用于删除目录</p></li><li><p>-f：强制执行删除操作【不需要再输入y进行确实删除了】</p></li></ul><blockquote><p>举例</p><p>#1 删除当前目录下的a.txt<br>rm &nbsp;-rf &nbsp;a.txt</p><p>#2 删除根目录下的a.txt<br>rm &nbsp;-fr /a.txt</p><p>#3 删除home下的a.txt<br>rm &nbsp;-r -f /home/a.txt</p></blockquote><p><strong>注意</strong>：</p><ul><li><p>如果不指定路径，则默认路径是当前位置</p></li><li><p>如果指定了路径，就去指定的路径下找文件</p></li></ul><blockquote><p>touch &nbsp;a &nbsp; &nbsp; &nbsp; &nbsp; 在当前位置下，创建文件a<br>touch &nbsp;/home/a &nbsp; 在home目录下，创建文件a</p><p>mkdir b<br>mkdir /home/b</p><p>cp c &nbsp; &nbsp; &nbsp; /home/ &nbsp; 将当前目录下的c复制到home目录下<br>cp /tmp/c &nbsp;/home &nbsp; &nbsp;将tmp目录下的c复制到home下</p><p>mv d &nbsp; &nbsp; &nbsp; /home &nbsp; &nbsp;将当前目录下的d移动home目录下<br>md /tmp/d &nbsp;/home &nbsp; &nbsp;将tmp目录下的d移动到home目录下</p></blockquote><h2 id="10）通配符"><a href="#10）通配符" class="headerlink" title="10）通配符"></a>10）通配符</h2><ul><li><p>通配符：就是具有特殊含义的符号</p></li><li><p>主要有两个</p></li></ul><blockquote><p>* &nbsp;代表的是任意多个任意的字符【0个、1个、多个】<br>? &nbsp;代表的是任意一个字符【1个】</p></blockquote><h2 id="11）cat命令"><a href="#11）cat命令" class="headerlink" title="11）cat命令"></a>11）cat命令</h2><p><strong>作用</strong>：读取文件的内容【比较合适读取行数较少的文件】</p><p><strong>格式</strong>：</p><blockquote><p>cat &nbsp;路径/文件名</p></blockquote><blockquote><p>案例</p><p># 准备测试文件<br>[root@localhost ~]# cp /etc/passwd /home/</p><p># 查看home下的passwd文件中的内容<br>[root@localhost ~]# cat /home/passwd&nbsp;</p></blockquote><h2 id="12）head命令"><a href="#12）head命令" class="headerlink" title="12）head命令"></a>12）head命令</h2><p><strong>作用</strong>：查看文件的前若干行，默认是看前10行</p><p><strong>格式</strong>：</p><blockquote><p>head &nbsp;[选项] &nbsp; 路径/文件</p></blockquote><p><strong>选项</strong>：</p><ul><li>-n #：指定看前几行</li></ul><blockquote><p># 准备测试文件<br>[root@localhost home]# for i in {1..500}; do echo $i &gt;&gt; /home/qq.txt ;done</p><p># 操作示例<br>[root@localhost home]# head qq.txt &nbsp; &nbsp; &nbsp; &nbsp;# 看前10行<br>[root@localhost home]# head -n20 qq.txt &nbsp; # 看前20行<br>[root@localhost home]# head -n3 qq.txt &nbsp; &nbsp;# 看前3行</p></blockquote><h2 id="13）tail命令"><a href="#13）tail命令" class="headerlink" title="13）tail命令"></a>13）tail命令</h2><p><strong>作用</strong>：查看文件的最后若干行，默认是看最后10行</p><p><strong>格式</strong>：</p><blockquote><p>tail &nbsp;[选项] &nbsp; 路径/文件</p></blockquote><p><strong>选项</strong>：</p><ul><li>-n #：指定看后几行</li></ul><h2 id="14）more命令"><a href="#14）more命令" class="headerlink" title="14）more命令"></a>14）more命令</h2><p><strong>作用</strong>：实现分屏查看大文件</p><p><strong>格式</strong>：</p><blockquote><p>more &nbsp;路径/文件名</p></blockquote><p><strong>操作</strong>：</p><ul><li><p>回车：显示下一行</p></li><li><p>空格：显示下一屏</p></li><li><p>b：显示上一屏</p></li><li><p>/目标字符：在文件中搜索内容</p></li><li><p>n：继续向后进行搜索</p></li><li><p>q：退出</p></li></ul><h2 id="15）less命令"><a href="#15）less命令" class="headerlink" title="15）less命令"></a>15）less命令</h2><p><strong>作用</strong>：实现分屏查看大文件</p><p><strong>格式</strong>：</p><blockquote><p>less &nbsp;路径/文件名</p></blockquote><p><strong>操作</strong>：</p><ul><li><p>回车：显示下一行</p></li><li><p>空格：显示下一屏</p></li><li><p>b：显示上一屏</p></li><li><p>/目标字符：在文件中搜索内容</p></li><li><p>n：继续向后进行搜索</p></li><li><p>q：退出</p></li></ul><h2 id="16）wc命令"><a href="#16）wc命令" class="headerlink" title="16）wc命令"></a>16）wc命令</h2><p><strong>作用</strong>：用于统计文件中有多少行、多少个单词、多少个字符</p><p><strong>格式</strong>：</p><blockquote><p>wc &nbsp;[选项] &nbsp;路径/文件名</p></blockquote><p><strong>选项</strong>：</p><ul><li><p>-l：统计行数 【line】</p></li><li><p>-w：统计单词数【word】</p></li><li><p>-c：统计字符数【character】</p></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 数字IC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字前端 </tag>
            
            <tag> SystemVerilog验证 </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FPGA学习方法</title>
      <link href="/2022/09/12/fpga-xue-xi-fang-fa/"/>
      <url>/2022/09/12/fpga-xue-xi-fang-fa/</url>
      
        <content type="html"><![CDATA[<p><strong>学习视频</strong>：<a href="https://www.bilibili.com/video/BV1aK4y1E7nc?spm_id_from=333.999.0.0&amp;vd_source=83d80c57e4377b69f911cc68016fb835">入行十年，我总结了这份FPGA学习路线：搞定这四点，你也能轻松进阶_哔哩哔哩_bilibili</a><br><strong>mindmap</strong>:<br><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202209302036004.png"></p><h1 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h1><h2 id="硬件描述语言"><a href="#硬件描述语言" class="headerlink" title="硬件描述语言"></a>硬件描述语言</h2><ul><li>VHDL<br>  语法更加严谨</li><li>Verilog<br>  语法更加灵活<ul><li>Verilog推荐书籍<br>  [[Verilog数字系统设计教程(第二版)+夏宇闻.pdf]]</li><li>Verilog刷题网站<br>  <a href="https://hdlbits.01xz.net/wiki/Main_Page">HDLBits (01xz.net)</a></li></ul></li><li>Systemverilog<br>  加入了Verilog中不支持但是非常有用的功能，简化了Verilog语法表达<ul><li>推荐书籍<br>  [[SystemVerilog验证测试平台编写指南.pdf]]</li></ul></li></ul><h2 id="Verilog-x2F-VHDL语法"><a href="#Verilog-x2F-VHDL语法" class="headerlink" title="Verilog /VHDL语法"></a>Verilog /VHDL语法</h2><ul><li>可综合部分：语句可生成对应的硬件电路</li><li>不可综合部分：主要用于设计与验证</li></ul><h2 id="仿真工具"><a href="#仿真工具" class="headerlink" title="仿真工具"></a>仿真工具</h2><ul><li>Modelsim</li><li>Questa</li></ul><h2 id="网页工具"><a href="#网页工具" class="headerlink" title="网页工具"></a>网页工具</h2><ul><li>EDAplayground</li><li>iVerilog（网上开源工具）</li></ul><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="专业基础课"><a href="#专业基础课" class="headerlink" title="专业基础课"></a>专业基础课</h2><ul><li>电路</li><li>数电（优先）</li><li>计算机体系结构</li><li>数字信号处理</li></ul><h2 id="FPGA相关"><a href="#FPGA相关" class="headerlink" title="FPGA相关"></a>FPGA相关</h2><ul><li>了解FPGA芯片结构以及基本组成单元：查找表、逻辑单元、逻辑块、DSP、存储器（推荐看FPGA官方文档）</li><li>了解FPGA开发流程<ul><li>RTL设计</li><li>仿真验证</li><li>逻辑综合</li><li>布局布线</li><li>时序收敛</li><li>硬件测试</li></ul></li></ul><h1 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h1><ul><li>VIVADO（AMD）</li><li>Quartus(Intel)</li></ul><h1 id="动手实验"><a href="#动手实验" class="headerlink" title="动手实验"></a>动手实验</h1><p>结合开发板与参考书实验</p>]]></content>
      
      
      <categories>
          
          <category> 数字IC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> 学习路线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SystemVerilog学习笔记(二)</title>
      <link href="/2022/09/11/systemverilog-xue-xi-bi-ji-er/"/>
      <url>/2022/09/11/systemverilog-xue-xi-bi-ji-er/</url>
      
        <content type="html"><![CDATA[<h1 id="1-SestemVerilog概述"><a href="#1-SestemVerilog概述" class="headerlink" title="1. SestemVerilog概述"></a>1. SestemVerilog概述</h1><h2 id="1-1-发展历史"><a href="#1-1-发展历史" class="headerlink" title="1.1 发展历史"></a>1.1 发展历史</h2><h1 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. 数据类型</h1><h3 id="2-1Verilog的数据类型"><a href="#2-1Verilog的数据类型" class="headerlink" title="2.1Verilog的数据类型"></a>2.1Verilog的数据类型</h3><p>Verilog语言提供两种基本的数据类型，即<strong>变量类型(variables</strong>)和**线网类型(nets)**，==这两种类型都是四值逻辑==，即可表示0、1、X和Z值。</p><ul><li><strong>变量类型(variables)</strong><ul><li>变量类型保存在initial、always、task 和function内赋的值。变量只能用过程赋值来赋值。</li><li>类型是integer 或time的变量一般像有相同数量位数的reg—样运转。</li><li>在表达式中integer的值作为有符号数处理，而reg或time的值作为无符号数处理。</li><li>用reg描述逻辑，integer 描述循环变量和计算，real在系统模型中使用，time和realtime保存测试装置的仿真时间。</li></ul></li><li><strong>线网类型(nets)</strong><ul><li>线网用于建模结构化描述中的连接线路和总线线网的值由线网的驱动器决定。</li><li>驱动器可以是门或模块的实例或者连续赋值的输出。</li><li></li></ul></li></ul><h2 id="2-2-SystemVerilog新添加的数据类型"><a href="#2-2-SystemVerilog新添加的数据类型" class="headerlink" title="2.2 SystemVerilog新添加的数据类型"></a>2.2 SystemVerilog新添加的数据类型</h2><ul><li>Verilog并没有严格区分信号的类型，变量和线网类型均是四值逻辑。SV添加了许多新的数据类型来帮助设计和验证工程师。</li><li>SV将硬件信号区分为 <code>类型</code>和<code>数据类型</code><ul><li><code>类型</code>即表示该信号为<strong>变量(variables</strong>)或者**线网类型(nets)**。<ul><li>对于<strong>变量类型</strong>赋值可以使用连续赋值、或者过程赋值。</li><li>对于<strong>线网类型</strong>赋值只能使用连续赋值语句(assign) 。</li></ul></li><li><code>数据类型</code>则表示该数据是<strong>四值逻辑(logic</strong>)还是<strong>二值逻辑(bit)</strong> 。</li></ul></li><li>TIPS<br>  避坑指南:简而言之，你可以在testbench (module)中大量使用logic类型变量，而很少使用wire。什么时候需要wire呢?多于一个驱动源的时候，或者设计模块端口是双向( inout)的时候。</li></ul><h2 id="2-3-四值逻辑数据类型"><a href="#2-3-四值逻辑数据类型" class="headerlink" title="2.3 四值逻辑数据类型"></a>2.3 四值逻辑数据类型</h2><ul><li>在Verilog中,reg经常用来表示存储组合逻辑或者时序逻辑的变量，不过初学者容易混淆其综合后的硬件单元。实际上,reg并不一定会被综合为register，而它只是用原来与线网类型相对，表示存储数据的变量。</li><li>在SV中，我们可以直接使用logic(数据类型)来达到==通用的存储硬件数据==的目的</li></ul><pre class=" language-systemverilog"><code class="language-systemverilog">logic resetN; //l a 1-bit wide 4-state variablelogic [63:0] data; //a 64-bit wide variablelogic [0:7] array [0:255]; // an array of 8-bit variables</code></pre><ul><li>logic虽然只是表示数据类型，而在声明时，它==默认会表示变量类型(variable)==，用户也可以显示声明其类型</li></ul><pre class=" language-systemverilog"><code class="language-systemverilog">var logic [63:0] addr; //a 64-bit wide variablewire wire logic [63:0]data; //a 64-bit wide net</code></pre><h2 id="2-4-二值逻辑数据类型"><a href="#2-4-二值逻辑数据类型" class="headerlink" title="2.4 二值逻辑数据类型"></a>2.4 二值逻辑数据类型</h2><p>SV添加了二值逻辑数据类型，用来对在RTL更高抽象级的模型建模，例如系统级或者事务级模型</p><ul><li>二值逻辑数据类型<ul><li><strong>bit</strong><br>  a 1-bit 2-state integer    //==双状态，单比特==</li><li><strong>byte</strong><br>  an 8-bit 2-state integer,similar to a c char    //==双状态，8比特有符号整数==</li><li><strong>shortint</strong><br>  a 16-bit 2-state integer,similar to a c shortint : a 32-bit 2-state integer, similar to a c int    //==双状态，16比特有符号整数==</li><li><strong>longint</strong><br>  a 64-bit 2-state integer,similar to a c longlong    //==双状态，64比特有符号整数==</li></ul></li><li>在RTL级别，X值用来捕捉设计错误，例如寄存器未初始化，Z值用来表示未连接或者三态的设计逻辑,但是在系统级或者事务级，Z和X很少被使用。</li><li>类似于logic类型默认为变量类型，bit类型默认也为变量类型。</li></ul><h2 id="2-5-有符号类型和无符号类型"><a href="#2-5-有符号类型和无符号类型" class="headerlink" title="2.5 有符号类型和无符号类型"></a>2.5 有符号类型和无符号类型</h2><ul><li>logic或者bit构成的向量(vector)是无符号类型。</li><li>integer、byte、shortint、int、longint为有符号类型。可以在有符号类型后添加unsigned来表示无符号类型</li></ul><pre class=" language-ad-example"><code class="language-ad-example">title: 示例byte有符号类型，表示的数值范围是[-128,127]。byte unsigned表示无符号类型，等同于bit[7:0]，表示的数值范围是[0，255]。</code></pre><ul><li>在构建验证环境总线功能模型(BFM,Bus-Functional Model)时，无需关注硬件底层逻辑(X或者Z值)，所以可使用二值逻辑实现。</li><li>同样，SV在与C发生语言交互时，也可以使用二值逻辑来使得两种语言的边界数据传输更为简单。</li></ul><h2 id="2-6-内建数据类型"><a href="#2-6-内建数据类型" class="headerlink" title="2.6 内建数据类型"></a>2.6 内建数据类型</h2><ul><li>按照四值逻辑的类型和二值逻辑的类型划分<ul><li>四值逻辑类型: integer、logic、reg、net-type(例如wire、tri)</li><li>二值逻辑类型: byte、shortint、int、longint、bit</li></ul></li><li>按照有符号和无符号的类型进行划分<ul><li>有符号类型: byte、shortint、int、longint、integer</li><li>无符号类型: bit、logic、reg、net-type(例如wire、tri)</li></ul></li></ul><h2 id="2-7-仿真行为"><a href="#2-7-仿真行为" class="headerlink" title="2.7 仿真行为"></a>2.7 仿真行为</h2><ul><li>四值逻辑变量例如reg、logic或者integer等，在仿真开始时的初值为X。</li><li>二值逻辑变量例如bit等，在仿真开始时的初值为0。</li><li>如果四值逻辑与二值逻辑的数据类型之间发生的默认转换，那么Z和X值将转换为0。</li><li>二值逻辑也可以用来实现可综合电路，只是二值逻辑由于没有X和Z值，因此可能会出现仿真行为同综合电路结果不一致的情况。</li></ul><h2 id="2-8-其他类型"><a href="#2-8-其他类型" class="headerlink" title="2.8 其他类型"></a>2.8 其他类型</h2><ul><li>SV添加void类型来表示空类型，经常用在函数定义时表示不会返回数值，同C语言的void使用方法。</li><li>SV添加shortreal表示32位单精度浮点类型，同C语言的float;而Verilog的real类型表示双精度浮点类型，同C语言的double.</li></ul><h1 id="3-自定义类型"><a href="#3-自定义类型" class="headerlink" title="3. 自定义类型"></a>3. 自定义类型</h1><p>通过用户自定义类型，以往Verilog的代码将可以通过更少的代码来表示更多的功能。用户自定义类型使得代码自身的可读性更好。</p><h2 id="3-1-通过typedef来创建用户自定义类型。"><a href="#3-1-通过typedef来创建用户自定义类型。" class="headerlink" title="3.1 通过typedef来创建用户自定义类型。"></a>3.1 通过<code>typedef</code>来创建用户自定义类型。</h2><p>Verilog不允许用户定义新的数据类型。SystemVerilog通过使用typedef提供了一种方法来定义新的数据类型。</p><pre class=" language-systemverilog"><code class="language-systemverilog">typedef int unsigned uint;//uint为int undesign的指代uint a, b;</code></pre><h2 id="3-2-通过enum来创建枚举类型。"><a href="#3-2-通过enum来创建枚举类型。" class="headerlink" title="3.2 通过enum来创建枚举类型。"></a>3.2 通过<code>enum</code>来创建枚举类型。</h2><p>枚举类型(enum)提供方法来描述抽象变量的合法值范围，其每一个值都需要提供一个用户自定义的名字。</p><ul><li>默认的枚举类型是int，即32位的二值逻辑数据类型</li><li>为了能够更准确地描述硬件，SV允许指明枚举类型的数据类型，例如:<br>![[Pasted image 20220920173106.png|500]]</li><li>如果一个枚举类型数值被赋值，那么所赋的值必须符合其数据类型。<br>![[Pasted image 20220920173149.png|400]]<br>如果枚举类型是四值逻辑数据类型，那么对枚举值赋为X或者Z也是合法的。<br>![[Pasted image 20220920173240.png|400]]</li><li>自定义枚举类型<ul><li>枚举类型也可以声明为自定义类型，这就使得可以用同一个枚举类型来声明多个变量或者线网.<br>![[Pasted image 20220920173452.png|500]]</li><li>如果枚举类型并没有伴随着typedef，那么该枚举类型指的则是一个匿名枚举类型(anonymous enumerated type)。</li><li>枚举类型赋值时则相对严格，例如下面的例子中，赋值操作符”=“的左右两侧应该尽量为相同的枚举类型。<br>  ![[Pasted image 20220920173624.png|500]]</li></ul></li></ul><h2 id="3-3-通过struct来创建结构体类型。"><a href="#3-3-通过struct来创建结构体类型。" class="headerlink" title="3.3 通过struct来创建结构体类型。"></a>3.3 通过<code>struct</code>来创建结构体类型。</h2><p>Verilog语言没有方便的特性可以将相关的信号收集整理到一个信号组中。SV添加了同C一样的结构体struct，而结构体的成员可以是任何变量类型，包括自定义类型或者其它常量类型。<br>![[Pasted image 20220920173802.png|500]]</p><ul><li>结构体类型的变量可以用来索引到其内部的变量，索引方式同C语言一致<br>![[Pasted image 20220920173912.png|500]]</li><li>结构体类型默认也是变量类型，用户也可以显示声明其为var或者wire类型。</li><li>自定义结构体类型<br>![[Pasted image 20220920174028.png|500]]</li><li>赋值<br>结构体变量可以通过索引其各个成员做依次的成员赋值，也可以通过分号′和花括号{}来实现整体赋初值:<br>![[Pasted image 20220920174212.png|500]]</li></ul><h1 id="4-字符串类型"><a href="#4-字符串类型" class="headerlink" title="4. 字符串类型"></a>4. 字符串类型</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><ul><li>默认的枚举类型是int，即32位的二值逻辑数据类型。为了能够更准确地描述硬件，SV允许指明枚举类型的数据类型</li><li>字符串类型变量的存储单元为byte类型。</li><li>字符串类型变量长度为N时，其字符成员索引值为从O到N-1.</li><li>不同于C函数，字符串结尾没有”空字符”即null字符”\O”。</li><li>字符串的内存是动态分配的，用户无需担心内存空间管理。</li></ul><h2 id="4-2-字符串内建方法"><a href="#4-2-字符串内建方法" class="headerlink" title="4.2 字符串内建方法"></a>4.2 字符串内建方法</h2><ul><li>str.len():返回字符串的长度。</li><li>str.putc(i, c):将第i个字符替换为字符c，等同于str[i]=c。</li><li>str.getc(i):返回第i个字符。</li><li>str.substr(i, j):将从第i个字符到第j个字符的字符串返回。</li><li>str.{atoi(), atohex(), atooct, atobin}:将字符串转变为十进制、十六进制、八进制或者二进制数据。</li></ul><h1 id="5-问答题"><a href="#5-问答题" class="headerlink" title="5. 问答题"></a>5. 问答题</h1><ul><li>在状态机或者组着电路中的case语句中的default分支或者if-else if-else中的else分支语句，有时会把变量赋值为’×’，这实际上只会影响仿真，但对综合电路不会产生影响，试问这么做是为什么?不影响电路综合可能是由于什么原因?</li><li>四值逻辑的数据类型应该在哪些地方声明，例如硬件部分，还是软件部分，或者是其它结构中?为什么需要这么做?<br>  四值逻辑的数据类型用于表征硬件电路，信号共有4种状态”0、1、x、z”，分别表示低电平、高电平、不确定态和高阻态。采用四值逻辑可以表征电路中不稳定的状态或者无驱动状态。如果用二值逻辑表示硬件电路，尽管能综合但综合电路与实际电路有出入，建模过程中存在失真问题。通常二值逻辑用于较高抽象级的模型建模，四值逻辑用于较低抽象级。</li><li>在处理枚举类型变量和整形变量的相互赋值情况中，应该注意哪些容易出错的地方?在从整形到枚举类型转换的过程中,有哪些方法?</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数字IC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字前端 </tag>
            
            <tag> SystemVerilog验证 </tag>
            
            <tag> 数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SystemVerilog学习笔记(一)</title>
      <link href="/2022/09/10/systemverilog-xue-xi-bi-ji-yi/"/>
      <url>/2022/09/10/systemverilog-xue-xi-bi-ji-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="1-相关名词"><a href="#1-相关名词" class="headerlink" title="1. 相关名词"></a>1. 相关名词</h2><ul><li>验证： verify/verification (国外也称为validation)<ul><li>pre-silicon validation: 流片之前做的验证</li><li>post-silicon validation: 流片之后做的测试</li><li>国内公司区分验证与测试较明确，或将流片后的测试工作外包；国外通常将验证与测试归为同一岗位。</li></ul></li><li>TestBench：测试平台，为了检验待测设计（design under test，DUT）而搭建的验证环境。</li><li>DUT(Design under Test)/DUV(design under Verification)：待测设计</li><li>&nbsp;Stimulator：激励发生器</li><li>monitor：监测DUT的输入</li><li>test case：测试用例</li><li>Emulator :硬件加速器</li></ul><h2 id="2-芯片开发概述"><a href="#2-芯片开发概述" class="headerlink" title="2. 芯片开发概述"></a>2. 芯片开发概述</h2><h3 id="2-1-验证的概念"><a href="#2-1-验证的概念" class="headerlink" title="2.1 验证的概念"></a>2.1 验证的概念</h3><ul><li>用来证明设计功能正确，符合设计功能描述的流程</li></ul><h3 id="2-2-测试平台"><a href="#2-2-测试平台" class="headerlink" title="2.2 测试平台"></a>2.2 测试平台</h3><div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211211630064.png" width="50%" height="50%"></div>* 对DUT创建测试序列 ，Stimulator利用Clock发送激励(Stimulus)。* monitor观察DUT的输入* Checker对DUT的输出数据与预期数据进行比对* 报告检查结果<p>硬件验证区别于软件软件在于时序</p><h3 id="2-3-设计与验证"><a href="#2-3-设计与验证" class="headerlink" title="2.3 设计与验证"></a>2.3 设计与验证</h3><div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211211631775.png " width="50%" height="50%"></div>设计和验证要独立工作<h3 id="2-4-芯片体积有多大"><a href="#2-4-芯片体积有多大" class="headerlink" title="2.4 芯片体积有多大"></a>2.4 芯片体积有多大</h3><p>职业规划：事业第一个五年把IP的项目整<br>个流程与SoC项目的整个流程都过一遍</p><h3 id="2-5-芯片开发流程"><a href="#2-5-芯片开发流程" class="headerlink" title="2.5 芯片开发流程"></a>2.5 芯片开发流程</h3><ul><li>市场人员与客户沟通，了解用户需求</li><li>系统设计人员按照功能划分为各个子系统</li><li>子系统进一步被划分为功能模块，由设计团队人员实现</li><li>验证人员对设计功能展开验证，发现设计缺陷，交由设计人员修正。验证人员需要写两部分代码<ul><li><strong>验证环境文件</strong>：写验证组件</li><li><strong>测试代码</strong>：产生数据、配置等</li></ul></li><li>验证没有出现漏洞后，交由后端人员进行综合、布局、布线。</li><li>后端人员将核心数据交由FAB进行流片。<div align="center"><img src=" https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211211632744.png" width="50%" height="50%"></div></li></ul><h3 id="2-6-验证和设计的紧密关系"><a href="#2-6-验证和设计的紧密关系" class="headerlink" title="2.6 验证和设计的紧密关系"></a>2.6 验证和设计的紧密关系</h3><ul><li>验证最好能够懂设计</li><li>验证相比设计入门更加容易，但验证与设计同样重要，验证的行业天花板持平设计甚至更高。</li><li>设计和验证都需要围绕功能文档。</li><li>尽量在流水线中做并行的工作（设计初步实现之后需要验证入场），尽量提前芯片开发的周期。</li><li>验证发现结果不符合预期时，如果漏洞明显可交由设计修正，待返回再测试；如果功能实现与设计存在分歧，则需共同回顾功能描述，统一对功能的理解。</li></ul><h3 id="2-7-验证人员的工作"><a href="#2-7-验证人员的工作" class="headerlink" title="2.7 验证人员的工作"></a>2.7 验证人员的工作</h3><p>在设计人员根据设计功能描述，实现各个模式RTL代码之后，开始构建验证环境，做几项工作来检查设计:</p><ul><li>设计文件是否正确地按照功能描述文挡去实施了?</li><li>硬件设计人员是否有遗漏掉的边界情况(corner case) ?</li><li>硬件设计是否足够稳定来处理一些错误情况(errorresponse) ?</li></ul><h3 id="2-8-验证与设计的协作"><a href="#2-8-验证与设计的协作" class="headerlink" title="2.8 验证与设计的协作"></a>2.8 验证与设计的协作</h3><ul><li>验证和设计都需要认真阅读功能描述文档</li><li>设计会将功能描述文档翻译为RTL模型</li><li>验证会按照其功能发送激励和比较结果<div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211211633127.png " width="50%" height="50%"></div></li></ul><h2 id="3-芯片验证概述"><a href="#3-芯片验证概述" class="headerlink" title="3. 芯片验证概述"></a>3. 芯片验证概述</h2><h3 id="3-1-验证的目标"><a href="#3-1-验证的目标" class="headerlink" title="3.1 验证的目标"></a>3.1 验证的目标</h3><ul><li>“<strong>按时保质低耗</strong>“完成目标硬件设计的验证工作<ul><li><strong>按时</strong><ul><li>按照项目预先的进度来考虑验证的节点(milestone)，即系统、子系统、模块等的deadline</li><li>模块之间相互关联，个人的延时会影响团队的延时</li></ul></li><li><strong>保质</strong><ul><li>尽可能少将缺陷暴露在流片之后，缺陷暴露在不同阶段造成的损呈指数增长</li><li>被市场发现缺陷会对芯片设计公司和客户双方造成消极影响</li></ul></li><li><strong>低耗</strong><ul><li>更短的时间、更少的人力来完成芯片设计任务</li><li>控制缺陷暴露的阶段</li></ul></li></ul></li></ul><h3 id="3-2-验证的重要性"><a href="#3-2-验证的重要性" class="headerlink" title="3.2 验证的重要性"></a>3.2 验证的重要性</h3><ul><li>缺陷率增长曲线<ul><li>重大缺陷造成额外的成本损失是越靠后越巨大</li><li>缺陷率增长曲线的曲率又是逐渐减小的</li><li>快而全地提供缺陷率增长是理想目标</li></ul></li><li>二次流片<br>一旦芯片在出片以后被检测出的严重缺陷会直接导致芯片的二次流片，这对于成本控制是—种额外的损失，消耗时间和人力资源。一方面，重新流片带来的成本巨大；另一方面，涉及到Fab厂产能、排期等复杂因素，重新流片的时间窗口至少为3个月。<div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211211634918.png " width="50%" height="50%"></div></li></ul><h3 id="3-3-验证的环节"><a href="#3-3-验证的环节" class="headerlink" title="3.3 验证的环节"></a>3.3 验证的环节</h3><div align="center"><img src="https://cloudpicture-1313887899.cos.ap-chongqing.myqcloud.com/blog_picture/202211211634540.png" width="50%" height="50%"></div>1. 拿功能详述文档创建验证计划2. 开发验证环境(实验1-2)3. 调试环境和HDL文件4. 递归测试：避免“拆东墙补西墙”5. 硅后测试6. 展开逃逸分析<p>具体为：<br>1）了解spec，即代码的规格说明书，有结构模型、功能描述、信号端口、寄存器定义等，它是设计和验证对接工作的桥梁。<br>2）制定testplan，一个完整的验证计划需要考虑的东西有很多，它为后续工作的进行提供了方向。<br>3）构建testbench，根据具体验证需求选择相应的组件，搭建出尽量可重用的验证环境。<br>4）编写testcase，根据之前定制的验证计划，coding相应的测试用例，debug fail case，把全部case调试至pass。<br>5）收集coverage，跑regression回归，根据覆盖率来决定是否加case，直到满足RTL freeze要求。</p><h1 id="4-问答题"><a href="#4-问答题" class="headerlink" title="4. 问答题"></a>4. 问答题</h1><p>1.<strong>设计人员和验证人员他们的协作关系体现在哪些地方?</strong></p><p>答:主要体现在功能模块的共同实现上：设计人员根据功能描述文档将模块功能以RTL代码实现，给出HDL文件；验证人员同样需要阅读功能描述文档，根据模块的功能发送激励展开验证，判断设计是否满足要求等。<br>若满足要求即可交予后端人员进行下一步操作，结果不符合预期时，如果漏洞明显可交由设计修正，待返回再测试；如果功能实现与设计存在分歧，则需共同回顾功能描述，统一对功能的理解。因此，验证人员与设计人员共同完成功能模块的实现。</p><p>2.<strong>为什么芯片验证的重要性目前越来越高?</strong></p><p>答：芯片验证的目的是”按时保质低耗”完成目标硬件设计的验证工作。其中，最重要的一点是通过芯片验证能够将尽可能少将缺陷暴露在流片之后。根据额外成本与缺陷发现时间关系曲线分析可知， 重大缺陷造成额外的成本损失靠后呈指数递增。若在RTL级发现缺陷交予设计人员修正即可；若在流片之后发现严重缺陷，可能导致芯片的二次流片。一方面，重新流片带来的成本巨大；另一方面，涉及到Fab厂产能、排期等复杂因素，重新流片的时间窗口至少为3个月。若在投入市场后发现重大缺陷，或给芯片设计厂与客户都带来巨大损失。因此，通过芯片验证尽可能早发现缺陷对于成本的控制具有重要意义。</p><p>3.<strong>在一个完成的验证周期中，有哪些工作需要完成呢?</strong></p><p>答：验证人员首先根据功能描述文档制订验证计划，接着开发验证环境，编写并调试验证环境文件与测试代码，写测试用例。接着进行递归测试，完成后进行流片前完备性检查。流片以后进行硅后系统测试，最后进行展开逃逸分析，吸取教训。</p>]]></content>
      
      
      <categories>
          
          <category> 数字IC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字前端 </tag>
            
            <tag> SystemVerilog验证 </tag>
            
            <tag> 概述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Obsidan(三) 插件用法</title>
      <link href="/2022/09/09/obsidan-san-cha-jian-yong-fa/"/>
      <url>/2022/09/09/obsidan-san-cha-jian-yong-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="一、dataview使用方法"><a href="#一、dataview使用方法" class="headerlink" title="一、dataview使用方法"></a>一、dataview使用方法</h1><h2 id="搜索用法"><a href="#搜索用法" class="headerlink" title="搜索用法"></a>搜索用法</h2><pre><code>* 直接搜索关键字* 搜索包含多个关键字的文档（空格间隔）* 搜索包含某一个关键字的文档（OR）* 指定搜索范围    * 搜索文件名 file:word    * 搜索文本内容 contant:word    * 搜索标签 tag:word     * 搜索同一行中的关键词 line:word1 word2    * 搜索同一章节中的多个关键字 section:word1 word2    * 搜索同一段落（块）中的多个关键词 block:word1 word2 </code></pre><h2 id="数据库用法"><a href="#数据库用法" class="headerlink" title="数据库用法"></a>数据库用法</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>Obsidian资料库中的查询工具/插件<ul><li>查询对象：Obsidian数据库</li><li>查询依据: <ul><li><a href="%E5%8F%AF%E8%87%AA%E5%AE%9A%E4%B9%89">[01 Obsidan学习笔记/04 YAML|YAML]</a></li><li>[[03 meatainfo|meatainfo}]](文件属性，不可自定义）</li></ul></li></ul></li></ul><h3 id="完整语法"><a href="#完整语法" class="headerlink" title="完整语法"></a>完整语法</h3><p>![[Pasted image 20220909154144.png]]</p><h3 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h3><p><strong>示例1:</strong> 检索文件夹中内容：</p><blockquote><pre class=" language-dataview"><code class="language-dataview">list from "00 Obsidan学习笔记"</code></pre></blockquote><hr><p><strong>示例2:</strong> 增加条件检索文件夹中内容</p><blockquote><pre class=" language-dataview"><code class="language-dataview">list from # dataview查询依据where rating > 5</code></pre></blockquote><hr><p><strong>示例3：</strong> 检索文件夹中内容，升/降序排列（按文件名称）：</p><blockquote><pre class=" language-dataview"><code class="language-dataview">list from # dataview查询依据where rating > 5sort file.name asc</code></pre></blockquote><hr><p><strong>示例4：</strong> 检索文件夹中内容，升/降序排列，以表格形式展现：</p><blockquote><pre class=" language-dataview"><code class="language-dataview">table file.size as 文件大小 , rating as 评分from #dataview查询依据where rating > 5sort file.name asc</code></pre></blockquote><hr><h1 id="二、Admination插件用法"><a href="#二、Admination插件用法" class="headerlink" title="二、Admination插件用法"></a>二、Admination插件用法</h1><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>放置折叠框</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><pre class=" language-markdown"><code class="language-markdown">```ad-<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">></span></span> # Admonition type. See below for a list of available types.title:                  # Admonition title.collapse:               # Create a collapsible admonition.icon:                   # Override the icon.color:                  # Override the color.Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla.</code></pre><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ul><li><strong>Admonition类型</strong><br>![[Pasted image 20220909184056.png]]</li></ul><pre class=" language-ad-example"><code class="language-ad-example">title: 示例type=example</code></pre><pre class=" language-ad-quote"><code class="language-ad-quote">title: 语录type=quote</code></pre><pre class=" language-ad-abstract"><code class="language-ad-abstract">title: 摘要type=abstract</code></pre><pre class=" language-ad-bug"><code class="language-ad-bug">title: BUGtype=bug</code></pre><pre class=" language-ad-info"><code class="language-ad-info">title: 信息type=info</code></pre><pre class=" language-ad-warning"><code class="language-ad-warning">title: 警告type=warning</code></pre><pre class=" language-ad-failure"><code class="language-ad-failure">title: 失败type=failure</code></pre><pre class=" language-ad-important"><code class="language-ad-important">title: 重要type=important</code></pre><pre class=" language-ad-question"><code class="language-ad-question">title: 问题type=question</code></pre><pre class=" language-ad-danger"><code class="language-ad-danger">title: 危险type=danger</code></pre><ul><li><strong>title</strong>:       # Admonition title. 键入标题</li></ul><pre class=" language-ad-note"><code class="language-ad-note">title: 输入标题(若标题字段留空仅显示文本内容)[输入文本内容]</code></pre><ul><li><strong>collapse</strong>:    # Create a collapsible admonition. 使用 collapse参数创建可折叠的admonition。<ul><li><code>collapse: open</code>  默认打开，可折叠</li><li><code>collapse: on</code>  默认折叠，可打开</li><li>如果参数为空白，则 collapse 参数将不执行任何操作。</li><li>默认情况下，在设置中，admonition可以设置为可折叠。</li></ul></li></ul><pre class=" language-ad-note"><code class="language-ad-note">title: 示例：默认打开，可折叠collapse: open[输入文本内容]</code></pre><pre class=" language-ad-note"><code class="language-ad-note">title: 示例：默认折叠，可打开collapse: on[输入文本内容]</code></pre><ul><li><strong>icon</strong>:        # Override the icon. 改变图标</li></ul><pre class=" language-ad-note"><code class="language-ad-note">icon: triforce[输入文本内容]</code></pre><ul><li><strong>color</strong>:       # Override the color. 改变颜色<br>可以使用该参数设置Admonition颜色。<strong>输入的颜色必须是 RGB 三元组。</strong></li></ul><pre class=" language-ad-note"><code class="language-ad-note">color: 1000, 100, 100[输入文本内容]</code></pre><ul><li><strong>嵌套使用</strong></li></ul><pre class=" language-ad-note"><code class="language-ad-note">title: Nested Admonitionscollapse: openHello!````ad-notetitle: This admonition is nested.This is a nested admonition!```ad-warningtitle: This admonition is closed.collapse: close```````This is in the original admonition.</code></pre><ul><li><strong>在Admonitions中显示代码块</strong></li></ul><p>对于单个层，可以使用标记代码块语法：<code>~~~</code></p><pre class=" language-ad-info"><code class="language-ad-info">```ad-bugtitle: I'm Nested!~~~javascriptthrow new Error("Oops, I'm a bug.");~~~``````javascriptconsole.log("Hello!");```</code></pre>]]></content>
      
      
      <categories>
          
          <category> 猎奇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Obsidian </tag>
            
            <tag> dataview </tag>
            
            <tag> Admination </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Obsidan(二) Markdown语法笔记</title>
      <link href="/2022/09/09/obsidan-er-markdown-yu-fa-bi-ji/"/>
      <url>/2022/09/09/obsidan-er-markdown-yu-fa-bi-ji/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="1-代码块"><a href="#1-代码块" class="headerlink" title="1.代码块"></a>1.代码块</h1><pre class=" language-markdown"><code class="language-markdown"></code></pre><h1 id="2-标题"><a href="#2-标题" class="headerlink" title="2.标题"></a>2.标题</h1><h1 id="3-字体"><a href="#3-字体" class="headerlink" title="3.字体"></a>3.字体</h1><h2 id="3-1样式"><a href="#3-1样式" class="headerlink" title="3.1样式"></a>3.1样式</h2><p>在 Markdown 语法中，使用&nbsp;<code>&lt;font&gt;</code>&nbsp;标签的&nbsp;<code>face</code>&nbsp;属性修改文字字体。字体在不同环境中支持程度不同，表现结果可能也不同。</p><pre class=" language-markdown"><code class="language-markdown"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">face</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>HEI<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>这里是黑体<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">face</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>KAI<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>这里是楷体<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">face</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>GB18030 Bitmap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>这里是扩展字体<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span></code></pre><p><font face="HEI">这里是黑体</font><br><font face="KAI">这里是楷体</font><br><font face="GB18030 Bitmap">这里是扩展字体</font></p><h2 id="3-2字号"><a href="#3-2字号" class="headerlink" title="3.2字号"></a>3.2字号</h2><p>Markdown 有三种主要方式：</p><h3 id="3-2-1使用-lt-font-gt-标签；"><a href="#3-2-1使用-lt-font-gt-标签；" class="headerlink" title="3.2.1使用&nbsp;<font>&nbsp;标签；"></a>3.2.1使用&nbsp;<code>&lt;font&gt;</code>&nbsp;标签；</h3><p>使用&nbsp;<code>&lt;font&gt;</code>&nbsp;标签&nbsp;<code>size</code>&nbsp;属性修改局部字号</p><pre class=" language-markdown"><code class="language-markdown"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>1号字 最小<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>2号字<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>3<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>3号字 默认<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>4<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>4号字<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>5<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>5号字<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>6<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>6号字<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>7<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>7号字 最大<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span></code></pre><p><font size="1">1号字 最小</font><br><font size="2">2号字</font><br><font size="3">3号字 默认</font><br><font size="4">4号字</font><br><font size="5">5号字</font><br><font size="6">6号字</font><br><font size="7">7号字 最大</font></p><h3 id="3-2-2通过-lt-big-gt-或者-lt-small-gt-标签"><a href="#3-2-2通过-lt-big-gt-或者-lt-small-gt-标签" class="headerlink" title="3.2.2通过&nbsp;<big>&nbsp;或者&nbsp;<small>&nbsp;标签"></a>3.2.2通过&nbsp;<code>&lt;big&gt;</code>&nbsp;或者&nbsp;<code>&lt;small&gt;</code>&nbsp;标签</h3><h3 id="3-2-3通过修改-style-样式实现。"><a href="#3-2-3通过修改-style-样式实现。" class="headerlink" title="3.2.3通过修改&nbsp;style&nbsp;样式实现。"></a>3.2.3通过修改&nbsp;<code>style</code>&nbsp;样式实现。</h3><h2 id="3-3字体颜色"><a href="#3-3字体颜色" class="headerlink" title="3.3字体颜色"></a>3.3字体颜色</h2><p>在 Markdown 语法中，使用&nbsp;<code>&lt;font&gt;</code>&nbsp;标签的&nbsp;<code>color</code>&nbsp;属性修改文字颜色。</p><pre class=" language-markdown"><code class="language-markdown"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>red<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>红色<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>green<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>绿色<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>blue<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>蓝色<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>rgb(200, 100, 100)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>使用 rgb 颜色值<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#FF00BB<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>使用十六进制颜色值<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span></code></pre><p><font color="red">红色</font><br><font color="green">绿色</font><br><font color="blue">蓝色</font><br><font color="rgb(200, 100, 100)">使用 rgb 颜色值</font><br><font color="#FF00BB">使用十六进制颜色值</font></p><pre class=" language-markdown"><code class="language-markdown"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">background</span><span class="token punctuation">:</span> <span class="token function">linear-gradient</span><span class="token punctuation">(</span> to right, <span class="token hexcode">#ff1616</span>, <span class="token hexcode">#ff7716</span>, <span class="token hexcode">#ffdc16</span>, <span class="token hexcode">#36c945</span>, <span class="token hexcode">#10a5ce</span>, <span class="token hexcode">#0f0096</span>, <span class="token hexcode">#a51eff</span>, <span class="token hexcode">#ff1616</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>这是七色光彩背景颜色<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span></code></pre><p><font style="background: linear-gradient( to right, #ff1616, #ff7716, #ffdc16, #36c945, #10a5ce, #0f0096, #a51eff, #ff1616);">这是七色光彩背景颜色</font></p><h2 id="3-4粗体斜体"><a href="#3-4粗体斜体" class="headerlink" title="3.4粗体斜体"></a>3.4粗体斜体</h2><p>使用 <code>*</code> 和 <code>**</code> 分别表示斜体和粗体，例如<br><em>斜体</em><br><strong>粗体</strong><br><em><strong>又斜又粗</strong></em></p><h2 id="3-5-高亮"><a href="#3-5-高亮" class="headerlink" title="3.5 高亮"></a>3.5 高亮</h2><p>==高亮==</p><h2 id="3-6跨行注释"><a href="#3-6跨行注释" class="headerlink" title="3.6跨行注释"></a>3.6跨行注释</h2><p>这里是行内注释：<br>%%预览模式下你将看不到这句话%%<br>这里是跨行注释：<br>%% 所谓跨行<br>就是可以有很多行 %%</p><h1 id="4-分割线"><a href="#4-分割线" class="headerlink" title="4.分割线"></a>4.分割线</h1><pre class=" language-markdown"><code class="language-markdown"><span class="token italic"><span class="token punctuation">*</span><span class="token punctuation">*</span><span class="token punctuation">*</span></span> 或者 ---</code></pre><hr><hr><h1 id="5-删除线"><a href="#5-删除线" class="headerlink" title="5.删除线"></a>5.删除线</h1><p>使用<code>~~双波浪线~~</code>表示删除线<br><del>删除线</del></p><h1 id="6-列表"><a href="#6-列表" class="headerlink" title="6.列表"></a>6.列表</h1><h2 id="6-1有序列表"><a href="#6-1有序列表" class="headerlink" title="6.1有序列表"></a>6.1有序列表</h2><p>语法：<code>数字</code>＋<code>.</code>＋<code>空格</code></p><pre class=" language-markdown"><code class="language-markdown">1. 2. 3. </code></pre><ol><li>第一</li><li>第二</li><li>第三</li></ol><h2 id="6-2无序列表"><a href="#6-2无序列表" class="headerlink" title="6.2无序列表"></a>6.2无序列表</h2><p>语法： <code>-</code> 或者<code>+</code> 或者<code>*</code> ＋<code>space</code></p><pre class=" language-markdown"><code class="language-markdown">* - + </code></pre><ul><li>第一</li></ul><ul><li>第二</li></ul><ul><li>第三</li></ul><h2 id="6-3列表嵌套"><a href="#6-3列表嵌套" class="headerlink" title="6.3列表嵌套"></a>6.3列表嵌套</h2><p>table键控制缩进，shift＋table取消缩进</p><ul><li>第一层 1<ul><li>第二层 1<ul><li>第三层 1<ul><li>第四层 1<ul><li>第五层 1</li></ul></li></ul></li><li>第三层 2</li></ul></li><li>第二层 2</li></ul></li></ul><h1 id="7-引用"><a href="#7-引用" class="headerlink" title="7.引用"></a>7.引用</h1><p>使用 <code>&gt;</code> 表示，可以有多个 <code>&gt;</code>，表示层级更深，例如</p><blockquote><p>第一层</p><blockquote><p>第二层</p><blockquote><p>第三层</p><blockquote><p>第四层</p></blockquote></blockquote></blockquote></blockquote><h1 id="8-代码样式"><a href="#8-代码样式" class="headerlink" title="8.代码样式"></a>8.代码样式</h1><h2 id="8-1行内代码"><a href="#8-1行内代码" class="headerlink" title="8.1行内代码"></a>8.1行内代码</h2><p>使用 「反引号&nbsp;<code>`</code>」符号定义行内代码。<br><code>行内代码</code></p><h2 id="8-2代码块"><a href="#8-2代码块" class="headerlink" title="8.2代码块"></a>8.2代码块</h2><p>使用四个空格缩进表示代码块，例如<br>    print(‘hello,world’)<br>    print(‘hello,world’)<br>        print(‘hello,world’)<br>        print(‘hello,world’)<br>        print(‘hello,world’)</p><h1 id="8-超链接"><a href="#8-超链接" class="headerlink" title="8.超链接"></a>8.超链接</h1><p>语法：<code>中括号[链接名称](目标链接)</code></p><pre class=" language-markdown"><code class="language-markdown">[Stephen<span class="token italic"><span class="token punctuation">_</span>Dai的个人空间<span class="token punctuation">_</span></span>哔哩哔哩](https://space.bilibili.com/444343706?spm<span class="token italic"><span class="token punctuation">_</span>id<span class="token punctuation">_</span></span>from=333.1007.0.0)</code></pre><p><a href="https://space.bilibili.com/444343706?spm_id_from=333.1007.0.0">Stephen_Dai的个人空间_哔哩哔哩</a></p><p>==TIPS: 若超链接为视频，可在<strong>阅读模式</strong>下Ctrl+单击链接，在软件内打开==</p><h1 id="9-表格"><a href="#9-表格" class="headerlink" title="9.表格"></a>9.表格</h1><p><strong>Markdown 表格包含三个部分：表头、分割线、数据。</strong></p><ul><li><strong>表头</strong>&nbsp;用来对列名对象进行描述，也就是通常所说的列名；</li><li><strong>数据</strong>&nbsp;用来展示每行的具体内容，数据是表格的核心；</li><li><strong>分割线</strong>&nbsp;用来区分表头和数据，也是 Markdown 中表格定义的最基本语法要求。</li></ul><p><strong>Markdown 表格由 「竖线&nbsp;<code>|</code>」、「减号&nbsp;<code>-</code>」、「冒号&nbsp;<code>:</code>」三种符号组成。</strong></p><ul><li><strong>竖线</strong>&nbsp;用来定义列，每两个竖线之间为一个单元格元素；</li><li><strong>减号</strong>&nbsp;用来定义分割线，也就是分割表头和数据体；</li><li><strong>冒号</strong>&nbsp;配合减号使用，用于定义列数据的对齐属性。</li></ul><pre class=" language-markdown"><code class="language-markdown">|商品|数量|单价||---|---:|:---:||苹果|10|\$1||电脑|1|\$1999|</code></pre><table><thead><tr><th>商品</th><th>数量</th><th>单价</th></tr></thead><tbody><tr><td>苹果</td><td>10</td><td>$1</td></tr><tr><td>电脑</td><td>1</td><td>$1999</td></tr></tbody></table><h1 id="10-数学公式"><a href="#10-数学公式" class="headerlink" title="10.数学公式"></a>10.数学公式</h1><p>Markdown 中的数学公式支持支持 <strong>LaTeX</strong>，分为「行中公式」和「独立公式」两种。</p><p>行中公式用两个单独的「美元符&nbsp;<code>$</code>」表示。</p><p>世界上最难的问题$1+1=2$，如何证明？</p><p>独立公式用两个连续的「美元符&nbsp;<code>$$</code>」表示，换行通过&nbsp;<code>\</code>&nbsp;实现。</p><p>平均数符号：$overline{xyz}$<br>开二次方符号：$sqrt x$<br>开方符号：$sqrt[3]{x+y}$<br>对数符号：$log(x)$<br>极限符号：$lim^{x to infty}<em>{y to 0}{frac{x}{y}}$<br>极限符号：$displaystyle lim^{x to infty}</em>{y to 0}{frac{x}{y}}$<br>求和符号：$sum^{x to infty}<em>{y to 0}{frac{x}{y}}$<br>求和符号：$displaystyle sum^{x to infty}</em>{y to 0}{frac{x}{y}}$<br>积分符号：$int^{infty}<em>{0}{xdx}$<br>积分符号：$displaystyle int^{infty}</em>{0}{xdx}$ </p>]]></content>
      
      
      <categories>
          
          <category> 猎奇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Obsidan </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Obsidan(一) 双向链接</title>
      <link href="/2022/09/08/obsidan-yi-shuang-xiang-lian-jie/"/>
      <url>/2022/09/08/obsidan-yi-shuang-xiang-lian-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="双链"><a href="#双链" class="headerlink" title="双链"></a>双链</h1><ul><li><strong>入链</strong>：从哪个链接跳转过来的 (<strong>反向链接</strong>)</li><li><strong>出链</strong>：即将跳转的链接</li></ul><hr><h1 id="创建链接步骤"><a href="#创建链接步骤" class="headerlink" title="创建链接步骤"></a>创建链接步骤</h1><ol><li>创建一个标准链接来指向其他笔记 </li><li>指向另一篇笔记中的某个分级标题、具体段落、具体某一块</li><li>链接创建别名<br>![[Pasted image 20220907162921.png]]<br> 示例：[[01 markdown语法#^abe080|《markdown语法中的标题语法》]]</li></ol><hr><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ol><li>自定义块编号并引用：<br> 示例：[[01 markdown语法#^lianjie|自定义链接]]</li><li>显示链接内容: 链接前面添加英文感叹号!<br> 示例：![[01 markdown语法#^lianjie|自定义链接]]</li></ol><h1 id="双链的意义"><a href="#双链的意义" class="headerlink" title="双链的意义"></a>双链的意义</h1><p>Obsidan以内容为基础，链接为核心。建立不同知识之间的连接，将不同知识相关性程度可视化，形成知识网络。<br>![[Pasted image 20220908161959.png]]</p>]]></content>
      
      
      <categories>
          
          <category> 猎奇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Obsidan </tag>
            
            <tag> 笔记管理 </tag>
            
            <tag> 双向链接 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
